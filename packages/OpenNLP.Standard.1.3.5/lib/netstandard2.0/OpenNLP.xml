<?xml version="1.0"?>
<doc>
    <assembly>
        <name>OpenNLP</name>
    </assembly>
    <members>
        <member name="T:OpenNLP.Tools.Chunker.ChunkerEventReader">
            <summary> 
            Class for creating an event reader out of data files for training a chunker. 
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Chunker.ChunkerEventReader.#ctor(SharpEntropy.ITrainingDataReader{System.String})">
            <summary>
            Creates a new event reader based on the specified data reader.
            </summary>
            <param name="dataReader">
            The data reader for this event reader.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Chunker.ChunkerEventReader.#ctor(SharpEntropy.ITrainingDataReader{System.String},OpenNLP.Tools.Chunker.IChunkerContextGenerator)">
            <summary>
            Creates a new event reader based on the specified data reader using the specified context generator.
            </summary>
            <param name="dataReader">
            The data reader for this event reader.
            </param>
            <param name="contextGenerator">
            The context generator which should be used in the creation of events for this event reader.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Chunker.ChunkerEventReader.ReadNextEvent">
            <summary> 
            Returns the next TrainingEvent object held in this TrainingEventReader.
            </summary>
            <returns>
            the TrainingEvent object which is next in this TrainingEventReader
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Chunker.ChunkerEventReader.HasNext">
            <summary> 
            Test whether there are any TrainingEvents remaining in this TrainingEventReader.
            </summary>
            <returns>
            true if this TrainingEventReader has more TrainingEvents
            </returns>
        </member>
        <member name="T:OpenNLP.Tools.Chunker.Dechunker">
            <summary>
            Abstract class implementing the Dechunk operation which plugs backs
            chunks given a collection of DechunkOperations
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Chunker.Dechunker.GetDechunkerOperations(System.String[])">
            <summary>
            Computes the collection of DechunkOperations to glue back
            the collection of chunks given in input.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Chunker.Dechunker.Dechunk(System.String[],System.String)">
            <summary>
            Glues back together a collection of chunks
            </summary>
            <param name="chunks">A collection of chunks</param>
            <param name="splitMarker">The marker to insert between chunks</param>
            <returns>The chunks glued together in a string</returns>
        </member>
        <member name="T:OpenNLP.Tools.Chunker.DefaultChunkerContextGenerator">
            <summary>
            Features based on chunking model described in Fei Sha and Fernando Pereira. Shallow 
            parsing with conditional random fields. In Proceedings of HLT-NAACL 2003. Association 
            for Computational Linguistics, 2003.
            </summary>
            <author> 
            Tom Morton
            </author>
        </member>
        <member name="M:OpenNLP.Tools.Chunker.DefaultChunkerContextGenerator.#ctor">
            <summary>
            Creates the default context generator for a chunker.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Chunker.DefaultChunkerContextGenerator.GetContext(System.Object)">
            <summary>
            Returns the contexts for chunking of the specified index.
            </summary>
            <param name="input">
            An object array containing:
            at index [0]: integer value, the index of the token in the tokens array for which the context should be constructed.
            at index [1]: object array, the ToString() methods of these objects make up the tokens of the sentence
            at index [2]: a Util.Sequence of previous decisions
            at index [3]: a string array, the POS tags for the specified tokens 
            </param>
            <returns>
            An array of predictive contexts on which a model bases its decisions.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Chunker.DefaultChunkerContextGenerator.GetContext(System.Int32,System.String[],System.String[],System.Object[])">
            <summary>
            Returns the contexts for chunking of the specified index.
            </summary>
            <param name="index">
            The index of the token in the specified tokens array for which the context should be constructed. 
            </param>
            <param name="sequence">
            The tokens of the sentence.  The <code>ToString</code> methods of these objects should return the token text.
            </param>
            <param name="priorDecisions">
            The previous decisions made in the tagging of this sequence.  Only indices less than index will be examined.
            </param>
            <param name="additionalContext">
            Object array of additional context information. The first object in the array is expected to be a string array
            containing the POS tags for the the specified tokens.
            </param>
            <returns>
            An array of predictive contexts on which a model bases its decisions.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Chunker.DefaultChunkerContextGenerator.GetContext(System.Int32,System.String[],System.String[],System.String[])">
            <summary>
            Returns the contexts for chunking of the specified index.
            </summary>
            <param name="tokenIndex">
            The index of the token in the specified tokens array for which the context should be constructed. 
            </param>
            <param name="tokens">
            The tokens of the sentence.  The <code>ToString</code> methods of these objects should return the token text.
            </param>
            <param name="tags">
            The POS tags for the the specified tokens.
            </param>
            <param name="predicates">
            The previous decisions made in the tagging of this sequence.  Only indices less than tokenIndex will be examined.
            </param>
            <returns>
            An array of predictive contexts on which a model bases its decisions.
            </returns>
        </member>
        <member name="T:OpenNLP.Tools.Chunker.EnglishTreebankChunker">
            <summary>
            This is a chunker based on the CONLL chunking task which uses Penn Treebank constituents as the basis for the chunks.
            See   http://cnts.uia.ac.be/conll2000/chunking/ for data and task definition.
            </summary>
            <author> 
            Tom Morton
            </author>
        </member>
        <member name="M:OpenNLP.Tools.Chunker.EnglishTreebankChunker.#ctor(System.String)">
            <summary>
            Creates an English Treebank Chunker which uses the specified model file.
            </summary>
            <param name="modelFile">
            The name of the maxent model to be used.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Chunker.EnglishTreebankChunker.ValidOutcome(System.String,OpenNLP.Tools.Util.Sequence)">
            <summary>
            This method determines whether the outcome is valid for the preceding sequence.  
            This can be used to implement constraints on what sequences are valid.  
            </summary>
            <param name="outcome">
            The outcome.
            </param>
            <param name="sequence">
            The preceding sequence of outcome assignments. 
            </param>
            <returns>
            true if the outcome is valid for the sequence, false otherwise.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Chunker.EnglishTreebankChunker.GetChunks(System.String[],System.String[])">
            <summary>
            Gets formatted chunk information for a specified sentence.
            </summary>
            <param name="tokens">
            string array of tokens in the sentence
            </param>
            <param name="tags">
            string array of POS tags for the tokens in the sentence
            </param>
            <returns>
            A string containing the formatted chunked sentence
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Chunker.EnglishTreebankChunker.GetChunks(System.String)">
            <summary>
            Gets formatted chunk information for a specified sentence.
            </summary>
            <param name="data">
            a string containing a list of tokens and tags, separated by / characters. For example:
            Battle-tested/JJ Japanese/NNP industrial/JJ managers/NNS 
            </param>
            <returns>
            A string containing the formatted chunked sentence
            </returns>
        </member>
        <member name="T:OpenNLP.Tools.Chunker.IChunker">
            <summary>
            The interface for chunkers which provide chunk tags for a sequence of tokens.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Chunker.IChunker.Chunk(System.String[],System.String[])">
            <summary>
            Generates chunk tags for the given sequence returning the result in an array.
            </summary>
            <param name="tokens">
            an array of the tokens or words of the sequence.
            </param>
            <param name="tags">
            an array of the pos tags of the sequence.
            </param>
            <returns>
            an array of chunk tags for each token in the sequence.
            </returns>
        </member>
        <member name="T:OpenNLP.Tools.Chunker.IChunkerContextGenerator">
            <summary>
            Context generator interface for chunkers.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Chunker.IChunkerContextGenerator.GetContext(System.Int32,System.String[],System.String[],System.String[])">
            <summary>
            Returns the contexts for chunking of the specified index.
            </summary>
            <param name="tokenIndex">
            The index of the token in the specified toks array for which the context should be constructed. 
            </param>
            <param name="tokens">
            The tokens of the sentence.  The <code>ToString</code> methods of these objects should return the token text.
            </param>
            <param name="tags">
            The POS tags for the the specified tokens.
            </param>
            /// <param name="previousDecisions">
            The previous decisions made in the tagging of this sequence.  Only indices less than tokenIndex will be examined.
            </param>
            <returns>
            An array of predictive contexts on which a model basis its decisions.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Chunker.IDechunker.GetDechunkerOperations(System.String[])">
            <summary>
            Find the dechunker operations corresponding to the input chunks
            </summary>
            <param name="chunks">the chunks to glue back together</param>
            <returns>the merge operations to detokenize the input chunks</returns>
        </member>
        <member name="M:OpenNLP.Tools.Chunker.IDechunker.Dechunk(System.String[],System.String)">
            <summary>
            Detokenize the input chunks into a string. Tokens which
            are connected without a space inbetween can be separated by
            a split marker.
            </summary>
            <param name="chunks"></param>
            <param name="splitMarker">the split marker or null</param>
            <returns></returns>
        </member>
        <member name="T:OpenNLP.Tools.Chunker.DechunkOperation">
            <summary>
            This enum contains an operation for every token to merge the
            tokens together to their detokenized form.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Chunker.DechunkOperation.MERGE_TO_RIGHT">
            <summary>
            The current chunk should be attached to the begin token on the right side.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Chunker.DechunkOperation.MERGE_TO_LEFT">
            <summary>
            The current chunk should be attached to the string on the left side.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Chunker.DechunkOperation.MERGE_BOTH">
            <summary>
            The current chunk should be attached to the string on the left side, as
            well as to the begin token on the right side.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Chunker.DechunkOperation.MERGE_BOTH_IF_SURROUNDED_BY_WORDS">
            <summary>
            The current chunk should be attached to the string on the left and the right sides
            only if both are words (with letters)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Chunker.DechunkOperation.RIGHT_LEFT_MATCHING">
            <summary>
            Attaches the chunk to the right token on first occurrence, and
            to the token on the left side on the second occurrence.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Chunker.DechunkOperation.NO_OPERATION">
            <summary>
            Do not perform a merge operation for this chunk, but is possible that another
            token can be attached to the left or right side of this one.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Chunker.MaximumEntropyChunker">
            <summary>
            This class represents a maximum-entropy-based chunker.  Such a chunker can be used to
            find flat structures based on sequence inputs such as noun phrases or named entities.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Chunker.MaximumEntropyChunker.Beam">
            <summary>
            The beam used to search for sequences of chunk tag assignments.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Chunker.MaximumEntropyChunker.Model">
            <summary>
            The model used to assign chunk tags to a sequence of tokens.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Chunker.MaximumEntropyChunker.#ctor(SharpEntropy.IMaximumEntropyModel)">
            <summary>Creates a chunker using the specified model</summary>
            <param name="model">The maximum entropy model for this chunker</param>
        </member>
        <member name="M:OpenNLP.Tools.Chunker.MaximumEntropyChunker.#ctor(SharpEntropy.IMaximumEntropyModel,OpenNLP.Tools.Chunker.IChunkerContextGenerator)">
            <summary>
            Creates a chunker using the specified model and context generator.
            </summary>
            <param name="model">The maximum entropy model for this chunker</param>
            <param name="contextGenerator">The context generator to be used by the specified model</param>
        </member>
        <member name="M:OpenNLP.Tools.Chunker.MaximumEntropyChunker.#ctor(SharpEntropy.IMaximumEntropyModel,OpenNLP.Tools.Chunker.IChunkerContextGenerator,System.Int32)">
            <summary>
            Creates a chunker using the specified model and context generator and decodes the
            model using a beam search of the specified size.
            </summary>
            <param name="model">The maximum entropy model for this chunker</param>
            <param name="contextGenerator">The context generator to be used by the specified model</param>
            <param name="beamSize">The size of the beam that should be used when decoding sequences</param>
        </member>
        <member name="M:OpenNLP.Tools.Chunker.MaximumEntropyChunker.Chunk(System.String[],System.String[])">
            <summary>Performs a chunking operation</summary>
            <param name="tokens">Object array of tokens</param>
            <param name="tags">string array of POS tags corresponding to the tokens in the object array</param>
            <returns>string array containing a value for each token, indicating the chunk that that token belongs to</returns>
        </member>
        <member name="M:OpenNLP.Tools.Chunker.MaximumEntropyChunker.AllTags">
            <summary>Gets a list of all the possible chunking tags</summary>
            <returns>String array, each entry containing a chunking tag</returns>
        </member>
        <member name="M:OpenNLP.Tools.Chunker.MaximumEntropyChunker.ValidOutcome(System.String,OpenNLP.Tools.Util.Sequence)">
            <summary>
            This method determines wheter the outcome is valid for the preceding sequence.  
            This can be used to implement constraints on what sequences are valid.  
            </summary>
            <param name="outcome">The outcome</param>
            <param name="sequence">The preceding sequence of outcomes assignments</param>
            <returns>true if the outcome is valid for the sequence, false otherwise</returns>
        </member>
        <member name="M:OpenNLP.Tools.Chunker.MaximumEntropyChunker.ValidOutcome(System.String,System.String[])">
            <summary>
            This method determines wheter the outcome is valid for the preceeding sequence.  
            This can be used to implement constraints on what sequences are valid.  
            </summary>
            <param name="outcome">The outcome</param>
            <param name="sequence">The preceding sequence of outcomes assignments</param>
            <returns>true if the outcome is valid for the sequence, false otherwise</returns>
        </member>
        <member name="M:OpenNLP.Tools.Chunker.MaximumEntropyChunker.Train(SharpEntropy.ITrainingEventReader)">
            <summary>
            Trains the chunker.
            Training file should be one word per line where each line consists of a
            space-delimited triple of "word pos outcome".
            Sentence breaks are indicated by blank lines.
            </summary>
            <param name="eventReader">The chunker event reader</param>
            <returns>Trained model</returns>
        </member>
        <member name="M:OpenNLP.Tools.Chunker.MaximumEntropyChunker.Train(SharpEntropy.ITrainingEventReader,System.Int32,System.Int32)">
            <summary>
            Trains the chunker.
            Training file should be one word per line where each line consists of a
            space-delimited triple of "word pos outcome".
            Sentence breaks are indicated by blank lines.
            </summary>
            <param name="eventReader">The chunker event reader</param>
            <param name="iterations">The number of iterations to perform</param>
            <param name="cutoff">
            The number of times a predicate must be seen in order
            to be relevant for training.
            </param>
            <returns>Trained model</returns>
        </member>
        <member name="T:OpenNLP.Tools.Chunker.MaximumEntropyChunker.ChunkBeamSearch">
            <summary>
            This class implements the abstract BeamSearch class to allow for the chunker to use
            the common beam search code. 
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.AbstractLinker">
            <summary>
            Provides a default implementation of many of the methods in <code>ILinker</code> that
            most implementations of <code>ILinker</code> will want to extend.  
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.AbstractLinker.mMentionFinder">
            <summary>
            The mention finder used to find mentions.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.AbstractLinker.mMode">
            <summary>The mode in which this linker is running. </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.AbstractLinker.mResolvers">
            <summary>The resolvers used by this Linker. </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.AbstractLinker.mEntities">
            <summary>Array used to store the results of each call made to the linker. </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.AbstractLinker.mSingularPronounIndex">
            <summary>The index of resolver which is used for singular pronouns. </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.AbstractLinker.mCoreferenceProjectName">
            <summary>The name of the project where the coreference models are stored. </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.AbstractLinker.mHeadFinder">
            <summary>The head finder used in this linker. </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.AbstractLinker.mUseDiscourseModel">
            <summary>Specifies whether coreferent mentions should be combined into a single entity. 
            Set this to true to combine them, false otherwise.  
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.AbstractLinker.mRemoveUnresolvedMentions">
            <summary>Specifies whether mentions for which no resolver can be used should be added to the
            discourse model.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.AbstractLinker.#ctor(System.String,OpenNLP.Tools.Coreference.LinkerMode)">
            <summary> 
            Creates a new linker using the models in the specified project directory and using the specified mode.
            </summary>
            <param name="project">
            The location of the models or other data needed by this linker.
            </param>
            <param name="mode">
            The mode the linker should be run in: testing, training, or evaluation.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.AbstractLinker.#ctor(System.String,OpenNLP.Tools.Coreference.LinkerMode,System.Boolean)">
            <summary> 
            Creates a new linker using the models in the specified project directory, using the specified mode, 
            and combining coreferent entities based on the specified value.
            </summary>
            <param name="project">
            The location of the models or other data needed by this linker.
            </param>
            <param name="mode">
            The mode the linker should be run in: testing, training, or evaluation.
            </param>
            <param name="useDiscourseModel">
            Specifies whether coreferent mention should be combined or not.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.AbstractLinker.Resolve(OpenNLP.Tools.Coreference.Mention.MentionContext,OpenNLP.Tools.Coreference.DiscourseModel)">
            <summary>
            Removes the specified mention to an entity in the specified discourse model or creates a new entity for the mention.
            </summary>
            <param name="mention">
            The mention to resolve.
            </param>
            <param name="discourseModel">
            The discourse model of existing entities.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.AbstractLinker.UpdateExtent(OpenNLP.Tools.Coreference.DiscourseModel,OpenNLP.Tools.Coreference.Mention.MentionContext,OpenNLP.Tools.Coreference.DiscourseEntity,System.Boolean)">
            <summary>
            Updates the specified discourse model with the specified mention as coreferent with the specified entity. 
            </summary>
            <param name="discourseModel">
            The discourse model
            </param>
            <param name="mention">
            The mention to be added to the specified entity.
            </param>
            <param name="entity">
            The entity which is mentioned by the specified mention.  
            </param>
            <param name="useDiscourseModel">
            Whether the mentions should be kept as an entiy or simply co-indexed.
            </param>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.DefaultLinker">
            <summary>
            This class perform coreference for treebank style parses or for noun-phrase chunked data.    
            Non-constituent entites such as pre-nominal named-entities and sub entities in simple coordinated
            noun phases will be created.  This linker requires that named-entity information also be provided.   
            This information can be added to the parse using the -parse option with EnglishNameFinder. 
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.DefaultLinker.#ctor(System.String,OpenNLP.Tools.Coreference.LinkerMode)">
            <summary>
            Creates a new linker with the specified model directory, running in the specified mode.
            </summary>
            <param name="modelDirectory">
            The directory where the models for this linker are kept.
            </param>
            <param name="mode">
            The mode that this linker is running in.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.DefaultLinker.#ctor(System.String,OpenNLP.Tools.Coreference.LinkerMode,System.Boolean)">
            <summary>
            Creates a new linker with the specified model directory, running in the specified mode which uses a discourse model
            based on the specified parameter.
            </summary>
            <param name="modelDirectory">
            The directory where the models for this linker are kept.
            </param>
            <param name="mode">
            The mode that this linker is running in.
            </param>
            <param name="useDiscourseModel">
            Whether the model should use a discourse model or not.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.DefaultLinker.#ctor(System.String,OpenNLP.Tools.Coreference.LinkerMode,System.Boolean,System.Double)">
            <summary>
            Creates a new linker with the specified model directory, running in the specified mode which uses a discourse model
            based on the specified parameter and uses the specified fixed non-referential probability.
            </summary>
            <param name="modelDirectory">
            The directory where the models for this linker are kept.
            </param>
            <param name="mode">
            The mode that this linker is running in.
            </param>
            <param name="useDiscourseModel">
            Whether the model should use a discourse model or not.
            </param>
            <param name="fixedNonReferentialProbability">
            The probability which resolvers are required to exceed to posit a coreference relationship.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.DefaultLinker.InitializeResolvers(OpenNLP.Tools.Coreference.LinkerMode,System.Double)">
            <summary>
            Initializes the resolvers used by this linker.
            </summary>
            <param name="mode">
            The mode in which this linker is being used.
            </param>
            <param name="fixedNonReferentialProbability">
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.DefaultLinker.InitializeHeaderFinder">
            <summary> 
            Initializes the head finder for this linker.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.DefaultLinker.InitializeMentionFinder">
            <summary> 
            Initializes the mention finder for this linker.  
            This can be overridden to change the space of mentions used for coreference. 
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.DiscourseElement">
            <summary>
            Represents an item in which can be put into the discourse model.  Object which are
            to be placed in the discourse model should extend this class.
            </summary>
            <seealso cref="T:OpenNLP.Tools.Coreference.DiscourseModel">
            </seealso>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.DiscourseElement.RecentMentions">
            <summary>
            An iterator over the mentions which iteratates through them based on which were most recently mentioned.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.DiscourseElement.Mentions">
            <summary>
            An iterator over the mentions which iteratates through them based on their occurance in the document.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.DiscourseElement.MentionCount">
            <summary>
            The number of mentions in this element.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.DiscourseElement.LastExtent">
            <summary>
            The last mention for this element.  For appositives this will be the
            first part of the appositive.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.DiscourseElement.Id">
            <summary>
            The id associated with this element.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.DiscourseElement.#ctor(OpenNLP.Tools.Coreference.Mention.MentionContext)">
            <summary>
            Creates a new discourse element which contains the specified mention.
            </summary>
            <param name="mention">
            The mention which begins this discourse element.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.DiscourseElement.AddMention(OpenNLP.Tools.Coreference.Mention.MentionContext)">
            <summary>
            Adds the specified mention to this discourse element.
            </summary>
            <param name="mention">
            The mention to be added.
            </param>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.DiscourseEntity">
            <summary>
            Represents an entity in a discourse model.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.DiscourseEntity.Category">
            <summary>
            The semantic category of this entity.  This field is used to associated named-entity categories with an entity.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.DiscourseEntity.Synsets">
            <summary>
            The set of synsets associated with this entity.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.DiscourseEntity.Gender">
            <summary>
            The gender associated with this entity.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.DiscourseEntity.GenderProbability">
            <summary>
            The probability for the gender associated with this entity.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.DiscourseEntity.Number">
            <summary>
            The number associated with this entity.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.DiscourseEntity.NumberProbability">
            <summary>
            The probability for the number associated with this entity.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.DiscourseEntity.#ctor(OpenNLP.Tools.Coreference.Mention.MentionContext,OpenNLP.Tools.Coreference.Similarity.GenderEnum,System.Double,OpenNLP.Tools.Coreference.Similarity.NumberEnum,System.Double)">
            <summary>
            Creates a new entity based on the specified mention and its specified gender and number properties.
            </summary>
            <param name="mention">
            The first mention of this entity.
            </param>
            <param name="gender">
            The gender of this entity.
            </param>
            <param name="genderProbability">
            The probability that the specified gender is correct.
            </param>
            <param name="number">
            The number for this entity.
            </param>
            <param name="numberProbability">
            The probability that the specified number is correct.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.DiscourseEntity.#ctor(OpenNLP.Tools.Coreference.Mention.MentionContext)">
            <summary>
            Creates a new entity based on the specified mention.
            </summary>
            <param name="mention">
            The first mention of this entity.
            </param>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.DiscourseModel">
            <summary>
            Represents the elements which are part of a discourse.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.DiscourseModel.EntityCount">
            <summary>
            The number of entities in this discourse model
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.DiscourseModel.Entities">
            <summary>
            The entities in the discourse model
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.DiscourseModel.#ctor">
            <summary> 
            Creates a new discourse model.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.DiscourseModel.MentionEntity(OpenNLP.Tools.Coreference.DiscourseEntity)">
            <summary>
            Indicates that the specified entity has been mentioned.</summary>
            <param name="entity">
            The entity which has been mentioned.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.DiscourseModel.GetEntity(System.Int32)">
            <summary>
            Returns the entity at the specified index.
            </summary>
            <param name="index">
            the index of the entity to be returned.
            </param>
            <returns>
            the entity at the specified index.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.DiscourseModel.AddEntity(OpenNLP.Tools.Coreference.DiscourseEntity)">
            <summary>
            Adds the specified entity to this discourse model.
            </summary>
            <param name="entity">
            the entity to be added to the model. 
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.DiscourseModel.MergeEntities(OpenNLP.Tools.Coreference.DiscourseEntity,OpenNLP.Tools.Coreference.DiscourseEntity,System.Single)">
            <summary>
            Merges the specified entities into a single entity with the specified confidence.
            </summary>
            <param name="firstEntity">
            The first entity. 
            </param>
            <param name="secondEntity">
            The second entity.
            </param>
            <param name="confidence">
            The confidence.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.DiscourseModel.Clear">
            <summary>
            Removes all elements from this discourse model.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Linker.Descriptor">
            <summary>
            string constant used to label a mention which is a description.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Linker.IsA">
            <summary>
            string constant used to label an mention in an appositive relationship. 
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Linker.CombinedNounPhrases">
            <summary>
            string constant used to label a mention which consists of two or more noun phrases. 
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Linker.SingleNounPhrase">
            <summary>
            string constant used to label a mention which consists of a single noun phrase. 
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Linker.ProperNounModifier">
            <summary>
            string constant used to label a mention which is a proper noun modifing another noun. 
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Linker.PronounModifier">
            <summary>
            string constatant used to label a mention which is a pronoun.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Linker.SingularThirdPersonPronounPattern">
            <summary>
            Regular expression for English singular third person pronouns.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Linker.PluralThirdPersonPronounPattern">
            <summary>
            Regular expression for English plural third person pronouns. 
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Linker.SpeechPronounPattern">
            <summary>
            Regular expression for English speech pronouns.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Linker.MalePronounPattern">
            <summary>
            Regular expression for English male pronouns. 
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Linker.FemalePronounPattern">
            <summary>
            Regular expression for English female pronouns. 
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Linker.NeuterPronounPattern">
            <summary>
            Regular expression for English nueter pronouns. 
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Linker.FirstPersonPronounPattern">
            <summary>
            Regular expression for English first person pronouns. 
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Linker.SecondPersonPronounPattern">
            <summary>
            Regular expression for English singular second person pronouns.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Linker.ThirdPersonPronounPattern">
            <summary>
            Regular expression for English third person pronouns.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Linker.SingularPronounPattern">
            <summary>
            Regular expression for English singular pronouns. 
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Linker.PluralPronounPattern">
            <summary>
            Regular expression for English plural pronouns.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Linker.HonorificsPattern">
            <summary>
            Regular expression for English honorifics. 
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Linker.DesignatorsPattern">
            <summary>
            Regular expression for English corporate designators. 
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.ILinker">
            <summary>
            A linker provides an interface for finding mentions, {@link #MentionFinder MentionFinder}, 
            and creating entities out of those mentions, {@link #GetEntitiesFromMentions getEntitiesFromMentions}.  This interface also allows
            for the training of a resolver with the method {@link #SetEntititesFromMentions setEntititesFromMentions} which is used to give the
            resolver mentions whose entityId fields indicate which mentions refer to the same entity and the 
            {@link #Train Train} method which compiles all the information provided via calls to 
            {@link #SetEntititesFromMentions SetEntititesFromMentions} into a model.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.ILinker.MentionFinder">
            <summary>
            The mention finder for this linker.  This can be used to get the mentions of a Parse.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.ILinker.HeadFinder">
            <summary>
            The head finder associated with this linker.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.ILinker.SetEntitiesFromMentions(OpenNLP.Tools.Coreference.Mention.Mention[])">
            <summary>
            Indicated that the specified mentions can be used to train this linker.
            This requires that the coreference relationship between the mentions have been labeled
            in the mention's id field.
            </summary>
            <param name="mentions">
            The mentions to be used to train the linker.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.ILinker.GetEntitiesFromMentions(OpenNLP.Tools.Coreference.Mention.Mention[])">
            <summary>
            Returns a list of entities which group the mentions into entity classes.
            </summary>
            <param name="mentions">A array of mentions. 
            </param>
            <returns>
            An array of discourse entities.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.ILinker.ConstructMentionContexts(OpenNLP.Tools.Coreference.Mention.Mention[])">
            <summary>
            Creates mention contexts for the specified mention exents.  These are used to compute coreference features over.
            </summary>
            <param name="mentions">
            The mention of a document.
            </param>
            <returns>
            mention contexts for the specified mention exents.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.ILinker.Train">
            <summary>
            Trains the linker based on the data specified via calls to {@link #SetEntities SetEntities}.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.LinkerMode">
            <summary>
            Enumeration of modes in which a linker can run.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.LinkerMode.Test">
            <summary>
            Testing mode, used to identify coreference relationships in un-annotated text. 
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.LinkerMode.Train">
            <summary>
            Training mode, used to learn coreference relationships in annotated text.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.LinkerMode.Eval">
            <summary>
            Evaluation mode, used to evaluate identifed coreference relationships based on annotated text.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.LinkerMode.Sim">
            <summary>
            Training mode, used to learn coreference relationships in annotated text.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.Mention.AbstractMentionFinder">
            <summary>
            Provides default implementation of many of the methods in the IMentionFinder interface.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Mention.AbstractMentionFinder.ConstructHeadMap(System.Collections.Generic.List{OpenNLP.Tools.Coreference.Mention.IParse})">
            <summary>
            Assigns head relations between noun phrases and the child noun phrase
            which is their head.
            </summary>
            <param name="nounPhrases">
            List of valid noun phrases for this mention finder.
            </param>
            <returns>
            mapping from noun phrases and the child noun phrase which is their head
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Mention.AbstractMentionFinder.GetNamedEntities(OpenNLP.Tools.Coreference.Mention.IParse)">
            <summary>
            Return all noun phrases which are contained by <code>parse</code>.
            </summary>
            <param name="parse">
            The parse in which to find the noun phrases. 
            </param>
            <returns>
            A list of <code>IParse</code> objects which are noun phrases contained by <code>parse</code>.
            </returns>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.Mention.AbstractParse">
            <summary>
            Provides default implemenation of many of the methods in the IParse interface.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.Mention.DefaultParse">
            <summary>
            This class is a wrapper for {@link OpenNLP.Tools.Parser.Parse} mapping it to the API specified in
            {@link OpenNLP.Tools.Coreference.Mention.Parse}.
            This allows coreference to be done on the output of the parser.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.Mention.DictionaryFactory">
            <summary>
            Factory class used to get an instance of a dictionary object.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Mention.DictionaryFactory.GetDictionary(System.String)">
            <summary>
            Returns the default implementation of the Dictionary interface.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.Mention.IDictionary">
            <summary>
            Interface to provide dictionary information to the coreference module assuming a
            hierarchically structured dictionary (such as WordNet) is available. 
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Mention.IDictionary.GetLemmas(System.String,System.String)">
            <summary>
            Returns the lemmas of the specified word with the specified part-of-speech.
            </summary>
            <param name="word">
            The word whose lemmas are desired.
            </param>
            <param name="partOfSpeech">The part-of-speech of the specified word.
            </param>
            <returns>
            The lemmas of the specified word given the specified part-of-speech.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Mention.IDictionary.GetSenseKey(System.String,System.String,System.Int32)">
            <summary> 
            Returns a key indicating the specified sense number of the specified 
            lemma with the specified part-of-speech.  
            </summary>
            <param name="lemma">
            The lemmas for which the key is desired.
            </param>
            <param name="partOfSpeech">
            The part of speech for which the key is desired.
            </param>
            <param name="senseNumber">
            The sense number for which the key is desired.
            </param>
            <returns> 
            a key indicating the specified sense number of the specified 
            lemma with the specified part-of-speech.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Mention.IDictionary.GetSenseCount(System.String,System.String)">
            <summary> 
            Returns the number of senses in the dictionry for the specified lemma.
            </summary>
            <param name="lemma">
            A lemmatized form of the word to look up.
            </param>
            <param name="partOfSpeech">
            The part-of-speech for the lemma.
            </param>
            <returns> the number of senses in the dictionary for the specified lemma.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Mention.IDictionary.GetParentSenseKeys(System.String,System.String,System.Int32)">
            <summary>
            Returns an array of keys for each parent of the specified sense number of the specified 
            lemma with the specified part-of-speech.
            </summary>
            <param name="lemma">
            A lemmatized form of the word to look up.
            </param>
            <param name="partOfSpeech">
            The part-of-sppech for the lemma.
            </param>
            <param name="senseNumber">
            The sense number for which the parent keys are desired.
            </param>
            <returns>
            an array of keys for each parent of the specified sense number of the specified lemma 
            with the specified part-of-speech.
            </returns>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.Mention.IHeadFinder">
            <summary>
            Interface for finding head words in noun phrases and head noun-phrases in parses.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Mention.IHeadFinder.GetHead(OpenNLP.Tools.Coreference.Mention.IParse)">
            <summary>
            Returns the child parse which contains the lexical head of the specifie parse.
            </summary>
            <param name="parse">
            The parse in which to find the head.
            </param>
            <returns>
            The parse containing the lexical head of the specified parse.  If no head is
            available or the constituent has no sub-components that are eligible heads then null is returned.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Mention.IHeadFinder.GetHeadIndex(OpenNLP.Tools.Coreference.Mention.IParse)">
            <summary>
            Returns which index the specified list of token is the head word.
            </summary>
            <param name="parse">
            The parse in which to find the head index.
            </param>
            <returns>
            The index of the head token.  
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Mention.IHeadFinder.GetLastHead(OpenNLP.Tools.Coreference.Mention.IParse)">
            <summary>
            Returns the parse bottom-most head of a <code>IParse</code>.  If no
            head is available which is a child of <code>parse</code> then
            <code>parse</code> is returned. 
            </summary>
            <param name="parse">
            Parse to find the head of.
            </param>
            <returns>
            bottom-most head of parse.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Mention.IHeadFinder.GetHeadToken(OpenNLP.Tools.Coreference.Mention.IParse)">
            <summary>
            Returns head token for the specified nounPhrase parse.
            </summary>
            <param name="nounPhrase">The noun parse to get head from.
            </param>
            <returns> head token parse.
            </returns>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.Mention.IMentionFinder">
            <summary>
            Specifies the interface that objects that determine the space of mentions for coreference should implement.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Mention.IMentionFinder.PrenominalNamedEntitiesCollection">
            <summary>
            Specifies whether pre-nominal named-entities should be collected as mentions.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Mention.IMentionFinder.CoordinatedNounPhrasesCollection">
            <summary>
            Specifies whether coordinated noun phrases should be collected as mentions.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Mention.IMentionFinder.GetMentions(OpenNLP.Tools.Coreference.Mention.IParse)">
            <summary>
            Returns an array of mentions.
            </summary>
            <param name="parse">
            A top level parse from which mentions are gathered.
            </param>
            <returns>
            An array of mentions.
            </returns>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.Mention.IParse">
            <summary>
            Interface for syntactic and named-entity information to be used in coreference annotation.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Mention.IParse.SentenceNumber">
            <summary>
            Returns the index of the sentence which contains this parse.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Mention.IParse.NounPhrases">
            <summary>
            Returns a list of the all noun phrases contained by this parse.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Mention.IParse.NamedEntities">
            <summary>
            Returns a list of all the named entities contained by this parse.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Mention.IParse.Children">
            <summary>
            Returns a list of the children to this object.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Mention.IParse.SyntacticChildren">
            <summary>
            Returns a list of the children to this object which are constituents or tokens.
            This allows implementations which contain addition nodes for things such as semantic 
            categories to hide those nodes from the components which only care about syntactic nodes. 
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Mention.IParse.Tokens">
            <summary>
            Returns a list of the tokens contained by this object.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Mention.IParse.SyntacticType">
            <summary>
            Returns the syntactic type of this node. Typically this is the part-of-speech or 
            constituent labeling.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Mention.IParse.EntityType">
            <summary>
            Returns the named-entity type of this node.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Mention.IParse.ParentNac">
            <summary>
            Determines whether this has an ancestor of type NAC.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Mention.IParse.Parent">
            <summary>
            Returns the parent parse of this parse node.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Mention.IParse.IsNamedEntity">
            <summary>
            Specifies whether this parse is a named-entity.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Mention.IParse.IsNounPhrase">
            <summary>
            Specifies whether this parse is a noun phrase.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Mention.IParse.IsSentence">
            <summary>
            Specifies whether this parse is a sentence.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Mention.IParse.IsCoordinatedNounPhrase">
            <summary>
            Specifies whether this parse is a coordinated noun phrase.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Mention.IParse.IsToken">
            <summary>
            Specifies whether this parse is a token.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Mention.IParse.EntityId">
            <summary>
            Returns an entity id associated with this parse and coreferent parses.  This is only used for training on
            already annotated coreference annotation.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Mention.IParse.Span">
            <summary>
            Returns the character offsets of this parse node.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Mention.IParse.PreviousToken">
            <summary>
            Returns the first token which is not a child of this parse.  If the first token of a sentence is
            a child of this parse then null is returned.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Mention.IParse.NextToken">
            <summary>
            Returns the next token which is not a child of this parse.  If the last token of a sentence is
            a child of this parse then null is returned.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.Mention.Mention">
            <summary>
            Data structure representation of a mention.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Mention.Mention.mSpan">
            <summary>
            Represents the character offset for this extent.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Mention.Mention.mType">
            <summary>
            A string representing the type of this extent.  This is helpful for determining
            which piece of code created a particular extent.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Mention.Mention.mId">
            <summary>
            The entity id indicating which entity this extent belongs to.  This is only
            used when training a coreference classifier.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Mention.Mention.mHeadSpan">
            <summary>
            Represents the character offsets of the the head of this extent. 
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Mention.Mention.mParse">
            <summary>
            The parse node that this extent is based on. 
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Mention.Mention.mNameType">
            <summary>
            A string representing the name type for this extent. 
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Mention.Mention.Span">
            <summary>
            Returns the character offsets for this extent.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Mention.Mention.HeadSpan">
            <summary>
            Returns the character offsets for the head of this extent.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Mention.Mention.Parse">
            <summary>
            The parse node that this extent is based on or null if the extent is newly created.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Mention.Mention.Id">
            <summary>
            Returns the id associated with this mention.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Mention.Mention.NameType">
            <summary>
            The named-entity category associated with this mention.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.Mention.MentionContext">
            <summary>
            Data structure representation of a mention with additional contextual information.  The contextual
            information is used in performing coreference resolution.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Mention.MentionContext.HeadTokenParse">
            <summary>
            Returns the parse of the head token for this mention.
            </summary>
            <returns> 
            the parse of the head token for this mention.
            </returns>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Mention.MentionContext.IndexSpan">
            <summary>
            Returns a sentence-based token span for this mention.  If this mention consist
            of the third, fourth, and fifth token, then this span will be 2..4.   
            </summary>
            <returns>
            a sentence-based token span for this mention.
            </returns>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Mention.MentionContext.NounPhraseSentenceIndex">
            <summary>
            Returns the index of the noun phrase for this mention in a sentence.
            </summary>
            <returns> 
            the index of the noun phrase for this mention in a sentence.
            </returns>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Mention.MentionContext.NounPhraseDocumentIndex">
            <summary> 
            Returns the index of the noun phrase for this mention in a document.
            </summary>
            <returns> 
            the index of the noun phrase for this mention in a document.
            </returns>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Mention.MentionContext.MaxNounPhraseSentenceIndex">
            <summary> 
            Returns the index of the last noun phrase in the sentence containing this mention.
            This is one less than the number of noun phrases in the sentence which contains this mention. 
            </summary>
            <returns> 
            the index of the last noun phrase in the sentence containing this mention.
            </returns>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Mention.MentionContext.SentenceNumber">
            <summary>
            Returns the index of the sentence which contains this mention.
            </summary>
            <returns>
            the index of the sentence which contains this mention.
            </returns>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Mention.MentionContext.FirstToken">
            <summary>
            Returns the parse for the first token in this mention.
            </summary>
            <returns> 
            The parse for the first token in this mention.
            </returns>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Mention.MentionContext.FirstTokenText">
            <summary>
            Returns the text for the first token of the mention.
            </summary>
            <returns> 
            The text for the first token of the mention.
            </returns>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Mention.MentionContext.FirstTokenTag">
            <summary> 
            Returns the pos-tag of the first token of this mention. 
            </summary>
            <returns>
            the pos-tag of the first token of this mention.
            </returns>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Mention.MentionContext.TokenParses">
            <summary>
            Returns the parses for the tokens which are contained in this mention.
            </summary>
            <returns> 
            An array of parses, in order, for each token contained in this mention.
            </returns>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Mention.MentionContext.GenderProbability">
            <summary>
            Returns the probability associated with the gender assignment.
            </summary>
            <returns> 
            The probability associated with the gender assignment.
            </returns>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Mention.MentionContext.NumberProbability">
            <summary>
            Returns the probability associated with the number assignment.
            </summary>
            <returns>
            The probability associated with the number assignment.
            </returns>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Mention.MentionContext.mHeadToken">
            <summary>
            The parse of the mention's head word. 
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Mention.MentionContext.mGender">
            <summary>
            The gender assigned to this mention. 
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Mention.MentionContext._number">
            <summary>
            The number assigned to this mention. 
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Mention.MentionContext.#ctor(OpenNLP.Tools.Coreference.Mention.Mention,System.Int32,System.Int32,System.Int32,System.Int32,OpenNLP.Tools.Coreference.Mention.IHeadFinder)">
            <summary> 
            Constructs context information for the specified mention.
            </summary>
            <param name="mention">
            The mention object on which this object is based.
            </param>
            <param name="mentionIndexInSentence">
            The mention's position in the sentence.
            </param>
            <param name="mentionsInSentence">
            The number of mentions in the sentence.
            </param>
            <param name="mentionIndexInDocument">
            The index of this mention with respect to the document.
            </param>
            <param name="sentenceIndex">
            The index of the sentence which contains this mention.
            </param>
            <param name="headFinder">
            An object which provides head information.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Mention.MentionContext.ToText">
            <summary> 
            Returns the text of this mention. 
            </summary>
            <returns>
            A space-delimited string of the tokens of this mention.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Mention.MentionContext.SetGender(OpenNLP.Tools.Coreference.Similarity.GenderEnum,System.Double)">
            <summary>
            Assigns the specified gender with the specified probability to this mention.
            </summary>
            <param name="gender">
            The gender to be given to this mention.
            </param>
            <param name="probability">
            The probability assosicated with the gender assignment.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Mention.MentionContext.GetGender">
            <summary>
            Returns the gender of this mention.</summary>
            <returns> 
            The gender of this mention.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Mention.MentionContext.SetNumber(OpenNLP.Tools.Coreference.Similarity.NumberEnum,System.Double)">
            <summary> 
            Assigns the specified number with the specified probability to this mention.
            </summary>
            <param name="number">
            The number to be given to this mention.
            </param>
            <param name="probability">
            The probability assosicated with the number assignment.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Mention.MentionContext.GetNumber">
            <summary> Returns the number of this mention.</summary>
            <returns> The number of this mention.
            </returns>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.Mention.PennTreebankHeadFinder">
            <summary>
            Finds head information from Penn Treebank style parses.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Mention.PennTreebankHeadFinder.Instance">
            <summary>
            Returns an instance of this head finder.
            </summary>
            <returns>
            An instance of this head finder.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Mention.PennTreebankHeadFinder.GetLastHead(OpenNLP.Tools.Coreference.Mention.IParse)">
            <summary>
            Returns the bottom-most head of a <code>IParse</code>.  If no
            head is available which is a child of <code>parse</code> then
            <code>parse</code> is returned. 
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.Mention.PennTreebankMentionFinder">
            <summary>
            Finds mentions from Penn Treebank style parses.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Mention.PennTreebankMentionFinder.#ctor(OpenNLP.Tools.Coreference.Mention.IHeadFinder)">
            <summary>
            Creates a new mention finder with the specified head finder.
            </summary>
            <param name="headFinder">
            The head finder.
            </param>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.Mention.ShallowParseMentionFinder">
            <summary> 
            Finds mentions from shallow np-chunking based parses. 
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.Mention.WordnetDictionary">
            <summary> 
            An implementation of the Dictionary interface using the SharpWordnet library. </summary>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.Resolver.AbstractResolver">
            <summary>
            Default implementation of some methods in the {@link IResolver} interface.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Resolver.AbstractResolver.mNumberEntitiesBack">
            <summary>
            The number of previous entities that resolver should consider.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Resolver.AbstractResolver.mShowExclusions">
            <summary>
            Debugging variable which specifies whether error output is generated if a class excludes as possibly coreferent mentions which are in-fact coreferent.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Resolver.AbstractResolver.mDistances">
            <summary>
            Debugging variable which holds statistics about mention distances durring training.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Resolver.AbstractResolver.mNumberSentencesBack">
            <summary>
            The number of sentences back this resolver should look for a referent.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Resolver.AbstractResolver.NumberSentencesBack">
            <summary>
            The number of sentences back this resolver should look for a referent.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Resolver.AbstractResolver.ShowExclusions">
            <summary>
            Debugging variable which holds statistics about mention distances durring training.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Resolver.AbstractResolver.Distances">
            <summary>
            Debugging variable which holds statistics about mention distances durring training.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Resolver.AbstractResolver.GetNumberEntitiesBack">
            <summary>
            Returns the number of previous entities that resolver should consider.
            </summary>
            <returns>
            the number of previous entities that resolver should consider.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Resolver.AbstractResolver.GetNumberEntitiesBack(OpenNLP.Tools.Coreference.DiscourseModel)">
            <summary>
            The number of entites that should be considered for resolution with the specified discourse model.
            </summary>
            <param name="discourseModel">
            The discourse model.
            </param>
            <returns>
            number of entites that should be considered for resolution.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Resolver.AbstractResolver.GetHead(OpenNLP.Tools.Coreference.Mention.MentionContext)">
            <summary>
            Returns the head parse for the specified mention.
            </summary>
            <param name="mention">
            The mention.
            </param>
            <returns>
            the head parse for the specified mention.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Resolver.AbstractResolver.GetHeadIndex(OpenNLP.Tools.Coreference.Mention.MentionContext)">
            <summary>
            Returns the index for the head word for the specified mention.
            </summary>
            <param name="mention">
            The mention.
            </param>
            <returns>
            the index for the head word for the specified mention.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Resolver.AbstractResolver.GetHeadString(OpenNLP.Tools.Coreference.Mention.MentionContext)">
            <summary>
            Returns the text of the head word for the specified mention.
            </summary>
            <param name="mention">
            The mention.
            </param>
            <returns>
            The text of the head word for the specified mention.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Resolver.AbstractResolver.IsOutOfRange(OpenNLP.Tools.Coreference.Mention.MentionContext,OpenNLP.Tools.Coreference.DiscourseEntity)">
            <summary>
            Determines if the specified entity is too far from the specified mention to be resolved to it.  
            Once an entity has been determined to be out of range subsequent entities are not considered.
            </summary>
            <seealso cref="M:OpenNLP.Tools.Coreference.Resolver.AbstractResolver.IsExcluded(OpenNLP.Tools.Coreference.Mention.MentionContext,OpenNLP.Tools.Coreference.DiscourseEntity)">
            </seealso>
            <param name="mention">
            The mention which is being considered.
            </param>
            <param name="entity">
            The entity to which the mention is to be resolved.
            </param>
            <returns>
            true is the entity is in range of the mention, false otherwise.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Resolver.AbstractResolver.IsExcluded(OpenNLP.Tools.Coreference.Mention.MentionContext,OpenNLP.Tools.Coreference.DiscourseEntity)">
            <summary>
            Excludes entities which you are not compatible with the entity under consideration.  The default 
            implementation excludes entties whose last extent contains the extent under consideration.
            This prevents posessive pronouns from referring to the noun phrases they modify and other 
            undesirable things.
            </summary>
            <param name="mention">
            The mention which is being considered as referential.
            </param>
            <param name="entity">
            The entity to which the mention is to be resolved.
            </param>
            <returns>
            true if the entity should be excluded, false otherwise.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Resolver.AbstractResolver.GetFeatureString(OpenNLP.Tools.Coreference.Mention.MentionContext)">
            <summary>
            Returns the string of "_" delimited tokens for the specified mention.
            </summary>
            <param name="mention">
            The mention.
            </param>
            <returns>
            the string of "_" delimited tokens for the specified mention.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Resolver.AbstractResolver.StripNounPhrase(OpenNLP.Tools.Coreference.Mention.MentionContext)">
            <summary>
            Returns a string for the specified mention with punctuation, honorifics, designators, and determiners removed.
            </summary>
            <param name="mention">
            The mention to be stripped.
            </param>
            <returns>
            a normalized string representation of the specified mention.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Resolver.AbstractResolver.GetPronounGender(System.String)">
            <summary>
            Returns a string representing the gender of the specifed pronoun.
            </summary>
            <param name="pronoun">
            An English pronoun. 
            </param>
            <returns>
            the gender of the specifed pronoun.
            </returns>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.Resolver.CommonNounResolver">
            <summary>
            Resolves coreference between common nouns.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.Resolver.DefaultNonReferentialResolver">
            <summary> 
            Default implementation of the {@link INonReferentialResolver} interface.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Resolver.DefaultNonReferentialResolver.GetNonReferentialFeatures(OpenNLP.Tools.Coreference.Mention.MentionContext)">
            <summary>
            Returns a list of features used to predict whether the specified mention is non-referential.
            </summary>
            <param name="mention">
            The mention under considereation.
            </param>
            <returns> 
            a list of featues used to predict whether the specified mention is non-referential.
            </returns>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.Resolver.DefiniteNounResolver">
            <summary> Resolves coreference between definite noun-phrases. </summary>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.Resolver.FixedNonReferentialResolver">
            <summary> Implementation of non-referential classifier which uses a fixed-value threshold. </summary>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.Resolver.INonReferentialResolver">
            <summary>
            Provides the interface for a object to provide a resolver with a non-referential
            probability.  Non-referential resolvers compute the probability that a particular mention refers
            to no antecedent.  This probability can then compete with the probability that
            a mention refers with a specific antecedent. 
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Resolver.INonReferentialResolver.GetNonReferentialProbability(OpenNLP.Tools.Coreference.Mention.MentionContext)">
            <summary>
            Returns the probability that the specified mention doesn't refer to any previous mention.
            </summary>
            <param name="mention">
            The mention under consideration.
            </param>
            <returns>
            A probability that the specified mention doesn't refer to any previous mention. 
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Resolver.INonReferentialResolver.AddEvent(OpenNLP.Tools.Coreference.Mention.MentionContext)">
            <summary>
            Designates that the specified mention be used for training.
            </summary>
            <param name="mention">
            The mention to be used.  The mention id is used to determine
            whether this mention is referential or non-referential.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Resolver.INonReferentialResolver.Train">
            <summary>
            Trains a model based on the events given to this resolver via AddEvent.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.Resolver.IResolver">
            <summary>
            Interface for coreference resolvers.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Resolver.IResolver.CanResolve(OpenNLP.Tools.Coreference.Mention.MentionContext)">
            <summary>
            Returns true if this resolver is able to resolve the referening experession of the same type
            as the specified mention.
            </summary>
            <param name="mention">
            The mention being considered for resolution. 
            </param>
            <returns>
            true if the resolver handles this type of referring
            expression, false otherwise.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Resolver.IResolver.Resolve(OpenNLP.Tools.Coreference.Mention.MentionContext,OpenNLP.Tools.Coreference.DiscourseModel)">
            <summary>
            Resolve this referirng expression to a discourse entity in the discourse model.
            </summary>
            <param name="expression">
            the referring expression. 
            </param>
            <param name="discourseModel">
            the discourse model.
            </param>
            <returns>
            the discourse entity which the resolver beleives this
            referring expression refers to or null if no discourse entity is
            coreferent with the referring expression. 
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Resolver.IResolver.Retain(OpenNLP.Tools.Coreference.Mention.MentionContext,OpenNLP.Tools.Coreference.DiscourseModel)">
            <summary>
            Uses the specified mention and discourse model to train this resolver.
            All mentions sent to this method need to have their id fields set to indicate coreference
            relationships.    
            </summary>
            <param name="mention">
            The mention which is being used for training.
            </param>
            <param name="model">
            the discourse model.
            </param>
            <returns>
            the discourse entity which is referred to by the referring
            expression or null if no discourse entity is referenced.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Resolver.IResolver.Train">
            <summary>
            Retrains model on examples for which retain was called.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.Resolver.IsAResolver">
            <summary>  Resolves coreference between appositives. </summary>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.Resolver.MaximumEntropyResolver">
            <summary> 
            Provides common functionality used by classes which implement the {@link IResolver} interface
            and use maximum entropy models to make resolution decisions.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Resolver.MaximumEntropyResolver.Same">
            <summary>
            Outcomes when two mentions are coreferent.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Resolver.MaximumEntropyResolver.Diff">
            <summary>
            Outcome when two mentions are not coreferent.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Resolver.MaximumEntropyResolver.Default">
            <summary>
            Default feature value.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Resolver.MaximumEntropyResolver.PreferFirstReferent">
            <summary>
            When true, this designates that the resolver should use the first referent encountered which it
            more preferable than non-reference.  When false, all non-excluded referents within this resolver's range
            are considered. 
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Resolver.MaximumEntropyResolver.PairedSampleSelection">
            <summary>
            When true, this designates that training should consist of a single positive and a single negative example
            (when possible) for each mention. 
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Resolver.MaximumEntropyResolver.UseSameModelForNonRef">
            <summary>
            When true, this designates that the same maximum entropy model should be used non-reference
            events (the pairing of a mention and the "null" reference) as is used for potentially 
            referential pairs.  When false a seperate model is created for these events.  
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Resolver.MaximumEntropyResolver.NonReferentialResolver">
            <summary>
            The model for computing non-referential probabilities.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Resolver.MaximumEntropyResolver.#ctor(System.Int32,System.Boolean)">
            <summary>
            Creates a maximum-entropy-based resolver which will look the specified number of entities back
            for a referent.
            This constructor is only used for unit testing.
            </summary>
            <param name="numberOfEntitiesBack">
            </param>
            <param name="preferFirstReferent">
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Resolver.MaximumEntropyResolver.#ctor(System.String,System.String,OpenNLP.Tools.Coreference.Resolver.ResolverMode,System.Int32,System.Boolean,OpenNLP.Tools.Coreference.Resolver.INonReferentialResolver)">
            <summary>
            Creates a maximum-entropy-based resolver with the specified model name, using the 
            specified mode, which will look the specified number of entities back for a referent and
            prefer the first referent if specified.
            </summary>
            <param name="modelDirectory">
            The name of the directory where the resover models are stored.
            </param>
            <param name="name">
            The name of the file where this model will be read or written.
            </param>
            <param name="mode">
            The mode this resolver is being using in (training, testing).
            </param>
            <param name="numberOfEntitiesBack">
            The number of entities back in the text that this resolver will look
            for a referent.
            </param>
            <param name="preferFirstReferent">
            Set to true if the resolver should prefer the first referent which is more
            likly than non-reference.  This only affects testing.
            </param>
            <param name="nonReferentialResolver">
            Determines how likly it is that this entity is non-referential.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Resolver.MaximumEntropyResolver.#ctor(System.String,System.String,OpenNLP.Tools.Coreference.Resolver.ResolverMode,System.Int32)">
            <summary>
            Creates a maximum-entropy-based resolver with the specified model name, using the 
            specified mode, which will look the specified number of entities back for a referent.
            </summary>
            <param name="modelDirectory">
            The name of the directory where the resolver models are stored.
            </param>
            <param name="modelName">
            The name of the file where this model will be read or written.
            </param>
            <param name="mode">
            The mode this resolver is being using in (training, testing).
            </param>
            <param name="numberEntitiesBack">
            The number of entities back in the text that this resolver will look
            for a referent.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Resolver.MaximumEntropyResolver.defaultReferent(OpenNLP.Tools.Coreference.DiscourseEntity)">
            <summary>
            Returns whether the specified entity satisfies the criteria for being a default referent.
            This criteria is used to perform sample selection on the training data and to select a single
            non-referent entity. Typically the criteria is a hueristic for a likely referent.
            </summary>
            <param name="discourseEntity">
            The discourse entity being considered for non-reference.
            </param>
            <returns>
            True if the entity should be used as a default referent, false otherwise. 
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Resolver.MaximumEntropyResolver.GetFeatures(OpenNLP.Tools.Coreference.Mention.MentionContext,OpenNLP.Tools.Coreference.DiscourseEntity)">
            <summary>
            Returns a list of features for deciding whether the specified mention refers to the specified discourse entity.
            </summary>
            <param name="mention">
            the mention being considers as possibly referential. 
            </param>
            <param name="entity">
            The discourse entity with which the mention is being considered referential.  
            </param>
            <returns>
            a list of features used to predict reference between the specified mention and entity.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Resolver.MaximumEntropyResolver.GetCompatibilityFeatures(OpenNLP.Tools.Coreference.Mention.MentionContext,OpenNLP.Tools.Coreference.DiscourseEntity)">
            <summary>
            Returns features indicating whether the specified mention and the specified entity are compatible.
            </summary>
            <param name="mention">
            The mention.
            </param>
            <param name="entity">
            The entity.
            </param>
            <returns> 
            list of features indicating whether the specified mention and the specified entity are compatible.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Resolver.MaximumEntropyResolver.GetContextFeatures(OpenNLP.Tools.Coreference.Mention.MentionContext)">
            <summary>
            Returns a list of features based on the surrounding context of the specified mention.
            </summary>
            <param name="mention">
            the mention whose surround context the features model. 
            </param>
            <returns>
            a list of features based on the surrounding context of the specified mention
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Resolver.MaximumEntropyResolver.IsDefiniteArticle(System.String,System.String)">
            <summary>
            Returns whether the specified token is a definite article.</summary>
            <param name="token">
            The token.
            </param>
            <param name="tag">
            The pos-tag for the specified token.
            </param>
            <returns> 
            whether the specified token is a definite article.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Resolver.MaximumEntropyResolver.GetDistanceFeatures(OpenNLP.Tools.Coreference.Mention.MentionContext,OpenNLP.Tools.Coreference.DiscourseEntity)">
            <summary>
            Returns distance features for the specified mention and entity.
            </summary>
            <param name="mention">
            The mention.
            </param>
            <param name="entity">
            The entity.
            </param>
            <returns>
            list of distance features for the specified mention and entity.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Resolver.MaximumEntropyResolver.GetPronounMatchFeatures(OpenNLP.Tools.Coreference.Mention.MentionContext,OpenNLP.Tools.Coreference.DiscourseEntity)">
            <summary>
            Returns features indicating whether the specified mention is compatible with the pronouns
            of the specified entity.
            </summary>
            <param name="mention">
            The mention.
            </param>
            <param name="entity">
            The entity.
            </param>
            <returns> 
            list of features indicating whether the specified mention is compatible with the pronouns
            of the specified entity.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Resolver.MaximumEntropyResolver.GetStringMatchFeatures(OpenNLP.Tools.Coreference.Mention.MentionContext,OpenNLP.Tools.Coreference.DiscourseEntity)">
            <summary>
            Returns string-match features for the the specified mention and entity.</summary>
            <param name="mention">
            The mention.
            </param>
            <param name="entity">
            The entity.
            </param>
            <returns>
            list of string-match features for the the specified mention and entity.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Resolver.MaximumEntropyResolver.GetWordFeatures(OpenNLP.Tools.Coreference.Mention.IParse)">
            <summary>
            Returns a list of word features for the specified tokens.
            </summary>
            <param name="token">
            The token for which features are to be computed.
            </param>
            <returns>
            a list of word features for the specified tokens.
            </returns>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.Resolver.PerfectResolver">
            <summary> Resolver used in training to update the discourse model based on the coreference annotation.  </summary>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.Resolver.PluralNounResolver">
            <summary> Resolves coreference between plural nouns. </summary>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.Resolver.PluralPronounResolver">
            <summary> Resolves coreference between plural pronouns and their referents.</summary>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.Resolver.ProperNounResolver">
            <summary> Resolves coreference between proper nouns.</summary>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.Resolver.ResolverMode">
            <summary> Enumerated type specifying the modes if a resolver. </summary>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.Resolver.SingletonNonReferentialResolver">
            <summary>
            This class allows you to share a single instance of a non-referential resolver
            amoung several resolvers.   
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.Resolver.SingularPronounResolver">
            <summary> This class resolver singlular pronouns such as "he", "she", "it" and their various forms. </summary>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.Resolver.SpeechPronounResolver">
            <summary> Resolves pronouns specific to quoted speech such as "you", "me", and "I".  </summary>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.Similarity.Context">
            <summary>
            Specifies the context of a mention for computing gender, number, and semantic compatibility.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Coreference.Similarity.Context.HeadTokenIndex">
            <summary>
            The token index in the head word of this mention.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.Similarity.GenderEnum">
            <summary>
            Enumeration of gender types.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Similarity.GenderEnum.Male">
            <summary>
            Male gender.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Similarity.GenderEnum.Female">
            <summary>
            Female gender.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Similarity.GenderEnum.Neuter">
            <summary>
            Neuter gender.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Similarity.GenderEnum.Unknown">
            <summary>
            Unknown gender.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.Similarity.GenderModel">
            <summary>
            Class which models the gender of a particular mentions and entities made up of mentions.
            </summary>
            <author> 
            Tom Morton
            </author>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Similarity.GenderModel.GetGender(OpenNLP.Tools.Coreference.Similarity.Context)">
            <summary>
            Heuristic computation of gender for a mention context using pronouns and honorifics.
            </summary>
            <param name="mention">
            The mention whose gender is to be computed.
            </param>
            <returns>
            The heuristically determined gender or unknown.
            </returns>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.Similarity.ITestGenderModel">
            <summary> Interface for testing a gender model. </summary>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.Similarity.ITestNumberModel">
            <summary> 
            Interface for testing a number model.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.Similarity.ITestSimilarityModel">
            <summary>
            Interface for testing a similarity model.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.Similarity.ITrainSimilarityModel">
            <summary> 
            Interface for training a similarity, gender, or number model. 
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Similarity.ITrainSimilarityModel.SetExtents(OpenNLP.Tools.Coreference.Similarity.Context[])">
            <summary>
            Creates similarity training pairs based on the specified extents.
            Extents are considered compatible if they are in the same coreference chain,
            have the same named-entity tag, or share a common head word.  Incompatible extents are chosen at random 
            from the set of extents which don't meet this criteria.
            </summary>
            <param name="extents">
            </param>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.Similarity.NumberEnum">
            <summary> Enumeration of number types. </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Similarity.NumberEnum.Singular">
            <summary>
            Singular number type. 
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Similarity.NumberEnum.Plural">
            <summary>
            Plural number type.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Similarity.NumberEnum.Unknown">
            <summary>
            Unknown number type. 
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.Similarity.NumberModel">
            <summary> 
            Class which models the number of particular mentions and the entities made up of mentions. 
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Similarity.SemanticEnum.Compatible">
            <summary>
            Semantically compatible. 
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Similarity.SemanticEnum.Incompatible">
            <summary>
            Semantically incompatible.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Coreference.Similarity.SemanticEnum.Unknown">
            <summary>
            Semantic compatibility Unknown. 
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Coreference.Similarity.SimilarityModel">
            <summary>
            Models semantic similarity between two mentions and returns a score based on 
            how semantically comparible the mentions are with one another.  
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Similarity.SimilarityModel.ConstructHeadSet(System.Collections.Generic.IEnumerable{OpenNLP.Tools.Coreference.Similarity.Context})">
            <summary> 
            Produces a set of head words for the specified list of mentions.
            </summary>
            <param name="mentions">
            The mentions to use to construct the 
            </param>
            <returns> 
            A set containing the head words of the sepecified mentions.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Similarity.SimilarityModel.ConstructExclusionSet(System.Int32,OpenNLP.Tools.Util.HashList{System.Int32,OpenNLP.Tools.Coreference.Similarity.Context},System.Collections.Generic.Dictionary{System.Int32,OpenNLP.Tools.Util.Set{System.String}},System.Collections.Generic.Dictionary{System.Int32,OpenNLP.Tools.Util.Set{System.String}},System.Collections.Generic.IEnumerable{OpenNLP.Tools.Coreference.Similarity.Context})">
            <summary>
            Constructs a set of entities which may be semantically compatible with the entity indicated by
            the specified entityKey.
            </summary>
            <param name="entityKey">
            The key of the entity for which the set is being constructed. 
            </param>
            <param name="entities">
            A mapping between entity keys and their mentions. 
            </param>
            <param name="headSets">
            A mapping between entity keys and their head sets.
            </param>
            <param name="nameSets">
            A mapping between entity keys and their name sets.
            </param>
            <param name="singletons">
            A list of all entities which consists of a single mention.
            </param>
            <returns>
            A set of mentions for all the entities which might be semantically compatible 
            with entity indicated by the specified key. 
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Similarity.SimilarityModel.ConstructHeadSets(OpenNLP.Tools.Util.HashList{System.Int32,OpenNLP.Tools.Coreference.Similarity.Context})">
            <summary>
            Constructs a mapping between the specified entities and their head set.
            </summary>
            <param name="entities">
            Mapping between a key and a list of mentions which compose an entity.
            </param>
            <returns> 
            a mapping between the keys of the secified entity mapping and the head set 
            generatated from the mentions associated with that key.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Similarity.SimilarityModel.ConstructNameSet(System.Collections.Generic.IEnumerable{OpenNLP.Tools.Coreference.Similarity.Context})">
            <summary> 
            Produces the set of name types associated with each of the specified mentions.
            </summary>
            <param name="mentions">
            A list of mentions.
            </param>
            <returns>
            A set of name types assigned to the specified mentions.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Similarity.SimilarityModel.ConstructNameSets(OpenNLP.Tools.Util.HashList{System.Int32,OpenNLP.Tools.Coreference.Similarity.Context})">
            <summary> 
            Constructs a mappng between the specified entities and the names associated with these entities.
            </summary>
            <param name="entities">
            A mapping between a key and a list of mentions.
            </param>
            <returns>
            a mapping between each key in the specified entity map and the name types associated with the each mention of that entity.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Similarity.SimilarityModel.AreCompatible(OpenNLP.Tools.Coreference.Similarity.Context,OpenNLP.Tools.Coreference.Similarity.Context)">
            <summary> 
            Returns a number between 0 and 1 which represents the models belief that the specified mentions are
            compatible.
            Value closer to 1 are more compatible, while values closer to 0 are less compatible.
            </summary>
            <param name="firstMention">
            The first mention to be considered.
            </param>
            <param name="secondMention">
            The second mention to be considered.
            </param>
            <returns> 
            a number between 0 and 1 which represents the models belief that the specified mentions are compatible.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Coreference.Similarity.SimilarityModel.TrainModel">
            <summary>Train a model based on the previously supplied evidence</summary>
        </member>
        <member name="T:OpenNLP.Tools.Lang.English.TreebankLinker">
            <summary>
            This class perform coreference for treebank style parses.  
            It will only perform coreference over constituents defined in the trees and
            will not generate new constituents for pre-nominal entities or sub-entities in 
            simple coordinated noun phrases.  This linker requires that named-entity information also be provided.  
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Lang.English.TreebankLinker.GetCoreferenceParse(System.String[])">
            <summary>
            Identitifies coreference relationships for parsed input.
            </summary>
            <param name="parsedSentences">Array of parsed sentences.</param>
            <returns></returns>
        </member>
        <member name="M:OpenNLP.Tools.Lang.English.TreebankLinker.GetCoreferenceParse(OpenNLP.Tools.Parser.Parse[])">
            <summary>
            Identitifies coreference relationships for parsed input.
            </summary>
            <param name="parsedSentences">Array of parsed sentences.</param>
            <returns></returns>
        </member>
        <member name="T:OpenNLP.Tools.Graphs.ConnectedComponents">
            <summary>
            Finds connected components in the graph, currently uses inefficient list for
            variable 'verticesLeft'. It might give a problem for big graphs
            
            @author sonalg 08/08/11
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Graphs.DirectedMultiGraph`2">
            <summary>
            Simple graph library; this is directed for now. This class focuses on time
            efficiency rather than memory efficiency.
            
            @author sonalg
            @author John Bauer
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
            <typeparam name="V">Type of vertices</typeparam>
            <typeparam name="E">Type of edges.</typeparam>
        </member>
        <member name="M:OpenNLP.Tools.Graphs.DirectedMultiGraph`2.#ctor(OpenNLP.Tools.Graphs.DirectedMultiGraph{`0,`1})">
            <summary>
            Creates a copy of the given graph. This will copy the entire data structure (this may be slow!), 
            but will not copy any of the edge or vertex objects.
            </summary>
            <param name="graph">The graph to copy into this object.</param>
        </member>
        <member name="M:OpenNLP.Tools.Graphs.DirectedMultiGraph`2.GetHashCode">
            Be careful hashing these. They are mutable objects, and changing the object
            will throw off the hash code, messing up your hash table
        </member>
        <member name="M:OpenNLP.Tools.Graphs.DirectedMultiGraph`2.AddVertex(`0)">
            <summary>
            For adding a zero degree vertex
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Graphs.DirectedMultiGraph`2.Add(`0,`0,`1)">
            <summary>
            adds vertices (if not already in the graph) and the edge between them
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Graphs.DirectedMultiGraph`2.RemoveVertex(`0)">
            <summary>
            remove a vertex (and its edges) from the graph.
            </summary>
            <returns>true if successfully removes the node</returns>
        </member>
        <member name="M:OpenNLP.Tools.Graphs.DirectedMultiGraph`2.GetNeighbors(`0)">
            <summary>
            Gets both parents and children nodes
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Graphs.DirectedMultiGraph`2.Clear">
            <summary>
            clears the graph, removes all edges and nodes
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Graphs.DirectedMultiGraph`2.IsEdge(`0,`0)">
            <summary>
            Only checks if there is an edge from source to dest.
            To check if it is connected in either direction, use isNeighbor
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Graphs.DirectedMultiGraph`2.IsEmpty">
            <summary>
            False if there are any vertices in the graph, true otherwise.
            Does not care about the number of edges.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Graphs.DirectedMultiGraph`2.RemoveZeroDegreeNodes">
            <summary>
            Deletes nodes with zero incoming and zero outgoing edges
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Graphs.DirectedMultiGraph`2.GetShortestPath(`0,`0)">
            <summary>
            Direction insensitive (the paths can go "up" or through the parents)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Graphs.DirectedMultiGraph`2.GetShortestPath(`0,`0,System.Boolean)">
            <summary>
            Can specify the direction sensitivity
            </summary>
            <param name="directionSensitive">whether the path can go through the parents</param>
            <returns>the list of nodes you get through to get there</returns>
        </member>
        <member name="M:OpenNLP.Tools.Graphs.DirectedMultiGraph`2.ToMap">
            <summary>
            Cast this multi-graph as a map from vertices, to the outgoing data along edges out of those vertices.
            </summary>
            <returns>A map representation of the graph.</returns>
        </member>
        <member name="T:OpenNLP.Tools.Graphs.IGraph`2">
            <summary>
            @author Sonal Gupta
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
            <typeparam name="V">Type of the vertices</typeparam>
            <typeparam name="E">Type of the edges</typeparam>
        </member>
        <member name="M:OpenNLP.Tools.Graphs.IGraph`2.Add(`0,`0,`1)">
            <summary>
            Adds vertices (if not already in the graph) and the edge between them.
            (If the graph is undirected, the choice of which vertex to call source and dest is arbitrary.)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Graphs.IGraph`2.AddVertex(`0)">
            <summary>
            For adding a zero degree vertex
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Graphs.IGraph`2.RemoveVertex(`0)">
            <summary>
            Remove a vertex (and its edges) from the graph.
            </summary>
            <returns>true if successfully removes the node</returns>
        </member>
        <member name="M:OpenNLP.Tools.Graphs.IGraph`2.GetOutgoingEdges(`0)">
            <summary>
            For undirected graph, it is just the edges from the node
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Graphs.IGraph`2.GetIncomingEdges(`0)">
            <summary>
            For undirected graph, it is just the edges from the node
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Graphs.IGraph`2.GetParents(`0)">
            <summary>
            For undirected graph, it is just the neighbors
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Graphs.IGraph`2.GetChildren(`0)">
            <summary>
            For undirected graph, it is just the neighbors
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Graphs.IGraph`2.Clear">
            <summary>
            Clears the graph, removes all edges and nodes
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Graphs.IGraph`2.IsEdge(`0,`0)">
            <summary>
            Only checks if there is an edge from source to dest.
            To check if it is connected in either direction, use isNeighbor
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Graphs.IGraph`2.IsEmpty">
            <summary>
            False if there are any vertices in the graph, true otherwise.
            Does not care about the number of edges.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Graphs.IGraph`2.RemoveZeroDegreeNodes">
            <summary>
            Deletes nodes with zero incoming and zero outgoing edges
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Graphs.IGraph`2.GetInDegree(`0)">
            <summary>
            For undirected graph, it should just be the degree
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations">
            <summary>
            Set of common annotations for {@link CoreMap}s. The classes
            defined here are typesafe keys for getting and setting annotation
            values. These classes need not be instantiated outside of this
            class. e.g {@link TextAnnotation}.class serves as the key and a
            <code>string</code> serves as the value containing the corresponding word.
            
            New types of {@link CoreAnnotation} can be defined anywhere that is
            convenient in the source tree - they are just classes. This file exists to
            hold widely used "core" annotations and others inherited from the
            {@link Label} family. In general, most keys should be placed in this file as
            they may often be reused throughout the code. This architecture allows for
            flexibility, but in many ways it should be considered as equivalent to an
            enum in which everything should be defined
            
            The getType method required by CoreAnnotation must return the same class type
            as its value type parameter. It feels like one should be able to get away
            without that method, but because Java erases the generic type signature, that
            info disappears at runtime. See {@link ValueAnnotation} for an example.
            
            @author dramage
            @author rafferty
            @author bethard
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.TextAnnotation">
            <summary>
            The CoreMap key identifying the annotation's text.
            
            Note that this key is intended to be used with many different kinds of
            annotations - documents, sentences and tokens all have their own text.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.LemmaAnnotation">
            <summary>
            The CoreMap key for getting the lemma (morphological stem) of a token.
            This key is typically set on token annotations.
            TODO: merge with StemAnnotation?
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.PartOfSpeechAnnotation">
            <summary>
            The CoreMap key for getting the Penn part of speech of a token.
            This key is typically set on token annotations.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.NamedEntityTagAnnotation">
            <summary>
            The CoreMap key for getting the token-level named entity tag (e.g., DATE, PERSON, etc.)
            This key is typically set on token annotations.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.StackedNamedEntityTagAnnotation">
            <summary>
            The CoreMap key for getting the token-level named entity tag (e.g., DATE, PERSON, etc.) 
            from a previous NER tagger. NERFeatureFactory is sensitive to this tag 
            and will turn the annotations from the previous NER tagger into
            new features. This is currently used to implement one level of stacking --
            we may later change it to take a list as needed.
            This key is typically set on token annotations.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.TrueCaseAnnotation">
            <summary>
            The CoreMap key for getting the token-level true case annotation (e.g., INIT_UPPER)
            This key is typically set on token annotations.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.TrueCaseTextAnnotation">
            <summary>
            The CoreMap key identifying the annotation's true-cased text.
             Note that this key is intended to be used with many different kinds of
            annotations - documents, sentences and tokens all have their own text.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.TokensAnnotation">
            <summary>
            The CoreMap key for getting the tokens contained by an annotation.
            This key should be set for any annotation that contains tokens. It can be
            done without much memory overhead using List.subList.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.GenericTokensAnnotation">
            <summary>
            The CoreMap key for getting the tokens (can be words, phrases or anything that are of type CoreMap) contained by an annotation.
            This key should be set for any annotation that contains tokens (words, phrases etc). It can be
            done without much memory overhead using List.subList.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.SentencesAnnotation">
            <summary>
            The CoreMap key for getting the sentences contained by an annotation.
            This key is typically set only on document annotations.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.ParagraphsAnnotation">
            <summary>
            The CoreMap key for getting the paragraphs contained by an annotation.
            This key is typically set only on document annotations.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.TokenBeginAnnotation">
            <summary>
            The CoreMap key identifying the first token included in an annotation.
            The token with index 0 is the first token in the document.
            This key should be set for any annotation that contains tokens.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.TokenEndAnnotation">
            <summary>
            The CoreMap key identifying the last token after the end of an annotation.
            The token with index 0 is the first token in the document.
            This key should be set for any annotation that contains tokens.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.CalendarAnnotation">
            <summary>
            The CoreMap key identifying the date and time associated with an annotation.
            This key is typically set on document annotations.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.DocIdAnnotation">
            <summary>
            This refers to the unique identifier for a "document", 
            where document may vary based on your application.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.IndexAnnotation">
            <summary>
            This indexes a token number inside a sentence.  Standardly, tokens are
            indexed within a sentence starting at 1 (not 0: we follow common parlance
            whereby we speak of the first word of a sentence).
            This is generally an individual word or feature index - it is local, and
            may not be uniquely identifying without other identifiers such as sentence
            and doc. However, if these are the same, the index annotation should be a
            unique identifier for differentiating objects.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.BeginIndexAnnotation">
            <summary>
            This indexes the beginning of a span of words, e.g., a constituent in a
            tree. See {@link edu.stanford.nlp.trees.Tree#indexSpans(int)}.
            This annotation counts tokens.
            It standardly indexes from 1 (like IndexAnnotation).  The reasons for
            this are: (i) Talking about the first word of a sentence is kind of
            natural, and (ii) We use index 0 to refer to an imaginary root in dependency output.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.EndIndexAnnotation">
            <summary>
            This indexes the end of a span of words, e.g., a constituent in a tree.
            See {@link edu.stanford.nlp.trees.Tree#indexSpans(int)}. This annotation
            counts tokens.  It standardly indexes from 1 (like IndexAnnotation).
            The end index is not a fencepost: its value is equal to the
            IndexAnnotation of the last word in the span.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.ForcedSentenceUntilEndAnnotation">
            <summary>
            This indicates that starting at this token, the sentence should not be ended until
            we see a ForcedSentenceEndAnnotation.  Used to force the ssplit annotator
            (eg the WordToSentenceProcessor) to keep tokens in the same sentence
            until ForcedSentenceEndAnnotation is seen.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.ForcedSentenceEndAnnotation">
            <summary>
            This indicates the sentence should end at this token.
            Used to force the ssplit annotator (eg the WordToSentenceProcessor) to
            start a new sentence at the next token.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.SentenceIndexAnnotation">
            <summary>
            Unique identifier within a document for a given sentence.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.LineNumberAnnotation">
            <summary>
            Line number for a sentence in a document delimited by newlines
            instead of punctuation.  May skip numbers if there are blank
            lines not represented as sentences.  Indexed from 1 rather than 0.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.ValueAnnotation">
            <summary>
            Contains the "value" - an ill-defined string used widely in MapLabel.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.OriginalTextAnnotation">
            <summary>
            The exact original surface form of a token.  This is created in the
            invertible PTBTokenizer. The tokenizer may normalize the token form to
            match what appears in the PTB, but this key will hold the original characters.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.BeforeAnnotation">
            <summary>
            Annotation for the whitespace characters appearing before this word.
            This can be filled in by the tokenizer so that the original text string can be reconstructed.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.AfterAnnotation">
            <summary>
            Annotation for the whitespace characters appear after this word. 
            This can be filled in by the tokenizer so that the original 
            text string can be reconstructed.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.CoarseTagAnnotation">
            <summary>
            CoNLL dep parsing - coarser POS tags.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.CoNllDepAnnotation">
            <summary>
            CoNLL dep parsing - the dependency type
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.CoNllPredicateAnnotation">
            <summary>
            CoNLL SRL/dep parsing - whether the word is a predicate
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.CoNllSrlAnnotation">
            <summary>
            CoNLL SRL/dep parsing - map which, for the current word, 
            specifies its specific role for each predicate
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.CoNllDepTypeAnnotation">
            <summary>
            CoNLL dep parsing - the dependency type
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.CoNllDepParentIndexAnnotation">
            <summary>
            CoNLL dep parsing - the index of the word which is the parent of this word in the dependency tree
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.IdfAnnotation">
            <summary>
            Inverse document frequency of the word this label represents
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.ProjectedCategoryAnnotation">
            <summary>
            The standard key for storing a projected category in the map, as a string.
            For any word (leaf node), the projected category is the syntactic category
            of the maximal constituent headed by the word. Used in SemanticGraph.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.ArgumentAnnotation">
            <summary>
            The standard key for a propbank label which is of type Argument
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.MarkingAnnotation">
            <summary>
            Another key used for propbank - to signify core arg nodes or predicate nodes
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.SemanticHeadWordAnnotation">
            <summary>
            The standard key for Semantic Head Word which is a String
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.SemanticHeadTagAnnotation">
            <summary>
            The standard key for Semantic Head Word POS which is a String
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.VerbSenseAnnotation">
            <summary>
            Probank key for the Verb sense given in the Propbank Annotation, should only be in the verbnode
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.CategoryFunctionalTagAnnotation">
            <summary>
            The standard key for storing category with functional tags.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.NerIdAnnotation">
            <summary>
            This is an NER ID annotation (in case the all caps parsing didn't work out for you...)
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.NormalizedNamedEntityTagAnnotation">
            <summary>
            The key for the normalized value of numeric named entities.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.SrlIdAnnotation">
            <summary>
            The key for semantic role labels (Note: please add to this description if you use this key)
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.ShapeAnnotation">
            <summary>
            The standard key for the "shape" of a word: a string representing the type
            of characters in a word, such as "Xx" for a capitalized word. See
            {@link edu.stanford.nlp.process.WordShapeClassifier} for functions for making shape strings.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.LeftTermAnnotation">
            <summary>
            The Standard key for storing the left terminal number relative to the root
            of the tree of the leftmost terminal dominated by the current node
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.ParentAnnotation">
            <summary>
            The standard key for the parent which is a String
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.SpanAnnotation">
            <summary>
            The standard key for span which is an IntPair
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.AnswerAnnotation">
            <summary>
            The standard key for the answer which is a String
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.GoldAnswerAnnotation">
            <summary>
            The standard key for gold answer which is a String
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.FeaturesAnnotation">
            <summary>
            The standard key for the features which is a Collection
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.InterpretationAnnotation">
            <summary>
            The standard key for the semantic interpretation
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.RoleAnnotation">
            <summary>
            The standard key for the semantic role label of a phrase.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.GazetteerAnnotation">
            <summary>
            The standard key for the gazetteer information
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.StemAnnotation">
            <summary>
            Morphological stem of the word this label represents
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.ChineseCharAnnotation">
            <summary>
            for Chinese: character level information, segmentation
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.ChineseIsSegmentedAnnotation">
            <summary>
            Not sure exactly what this is, but it is different from
            ChineseSegAnnotation and seems to indicate if the text is segmented
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.CharacterOffsetBeginAnnotation">
            <summary>
            The CoreMap key identifying the offset of the first character of an annotation.
            The character with index 0 is the first character in the document.
            This key should be set for any annotation that represents a span of text.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.CharacterOffsetEndAnnotation">
            <summary>
            The CoreMap key identifying the offset of the last character after the end
            of an annotation. The character with index 0 is the first character in the document.
            This key should be set for any annotation that represents a span of text.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.CostMagnificationAnnotation">
            <summary>
            Key for relative value of a word - used in RTE
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.NumTxtSentencesAnnotation">
            <summary>
            Used by RTE to track number of text sentences, to determine when hyp sentences begin.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.TagLabelAnnotation">
            <summary>
            Used in Trees
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.DomainAnnotation">
            <summary>
            Used in CRFClassifier stuff PositionAnnotation should possibly be an int -
            it's present as either an int or string depending on context CharAnnotation
            may be "CharacterAnnotation" - not sure
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.UnknownAnnotation">
            <summary>
            This is not a catchall "unknown" annotation but seems to have a
            specific meaning for sequence classifiers
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.OriginalAnswerAnnotation">
            Seems like this could be consolidated with something else... 
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.OriginalCharAnnotation">
            Seems like this could be consolidated with something else... 
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.SectionAnnotation">
            <summary>
            Section of a document
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.SectionDateAnnotation">
            <summary>
            Date for a section of a document
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.SectionIdAnnotation">
            <summary>
            Id for a section of a document
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.SectionStartAnnotation">
            <summary>
            Indicates that the token starts a new section and the attributes that should go into that section
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.SectionEndAnnotation">
            <summary>
            Indicates that the token end a section and the label of the section
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.BestCliquesAnnotation">
            <summary>
            Used in Task3 Pascal system
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.LabelAnnotation">
            <summary>
            Used in wsd.supwsd package
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.HeightAnnotation">
            <summary>
            Used in srl.unsup
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.LBeginAnnotation">
            <summary>
            Used in Gale2007ChineseSegmenter
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.SpaceBeforeAnnotation">
            <summary>
            Used in Chinese segmenters for whether there was space before a character.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.StateAnnotation">
            <summary>
            The base version of the parser state, like NP or VBZ or ...
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.PrevChildAnnotation">
            <summary>
            Used in binarized trees to say the name of the most recent child
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.FirstChildAnnotation">
            <summary>
            Used in binarized trees to specify the first child in the rule for which this node is the parent
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.UnaryAnnotation">
            <summary>
            whether the node is the parent in a unary rule
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.DoAnnotation">
            <summary>
            annotation stolen from the lex parser
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.HaveAnnotation">
            <summary>
            annotation stolen from the lex parser
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.BeAnnotation">
            <summary>
            annotation stolen from the lex parser
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.NotAnnotation">
            <summary>
            annotation stolen from the lex parser
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.PercentAnnotation">
            <summary>
            annotation stolen from the lex parser
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.GrandparentAnnotation">
            <summary>
            Specifies the base state of the parent of this node in the parse tree
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.HeadWordStringAnnotation">
            <summary>
            The key for storing a Head word as a string rather than a pointer 
            (as in TreeCoreAnnotations.HeadWordAnnotation)
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.MonthAnnotation">
            <summary>
            Used in nlp.coref
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.PriorAnnotation">
            <summary>
            Used in propbank.srl
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.CopyAnnotation">
            <summary>
            Used in nlp.trees. When nodes are duplicated in Stanford Dependencies
            conversion (to represent conjunction of PPs with preposition collapsing,
            this gets set to a positive number on duplicated nodes.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.XmlElementAnnotation">
            <summary>
            Used in SimpleXMLAnnotator. The value is an XML element name string for the
            innermost element in which this token was contained.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.XmlContextAnnotation">
            <summary>
            Used in CleanXMLAnnotator.  The value is a list of XML element names indicating
            the XML tag the token was nested inside.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.TopicAnnotation">
            <summary>
            Used for Topic Assignments from LDA or its equivalent models.
            The value is the topic ID assigned to the current token.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.WordnetSynAnnotation">
            <summary>
            Gets the synonymn of a word in the Wordnet (use a bit differently in sonalg's code)
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.PhraseWordsTagAnnotation">
            <summary>
            to get words of the phrase
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.PhraseWordsAnnotation">
            <summary>
            to get pos tag of the phrase i.e. root of the phrase tree in the parse tree
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.ProtoAnnotation">
            <summary>
            to get prototype feature, see Haghighi Exemplar driven learning
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.CommonWordsAnnotation">
            <summary>
            which common words list does this word belong to
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.DocDateAnnotation">
            <summary>
             Document date, Needed by SUTime
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.DocTypeAnnotation">
            <summary>
            Document type
            What kind of document is it: story, multi-part article, listing, email, etc
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.DocSourceTypeAnnotation">
            <summary>
            Document source type
            What kind of place did the document come from: newswire, discussion forum, web...
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.DocTitleAnnotation">
            <summary>
            Document title
            What is the document title
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.LocationAnnotation">
            <summary>
            Reference location for the document
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.AuthorAnnotation">
            <summary>
            Author for the document
            (really should be a set of authors, but just have single string for simplicity)
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.NumericTypeAnnotation">
            <summary>
            Per token annotation indicating whether the token represents a NUMBER or ORDINAL
            (twenty first => NUMBER ORDINAL)
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.NumericValueAnnotation">
            <summary>
            Per token annotation indicating the numeric value of the token
            (twenty first => 20 1)
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.NumericObjectAnnotation">
            <summary>
            Per token annotation indicating the numeric object associated with an annotation
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.NumericCompositeValueAnnotation">
            <summary>
            Annotation indicating whether the numeric phrase the token is part of
            represents a NUMBER or ORDINAL (twenty first => ORDINAL ORDINAL)
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.NumericCompositeTypeAnnotation">
            <summary>
            Annotation indicating the numeric value of the phrase the token is part of
            (twenty first => 21 21 )
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.NumericCompositeObjectAnnotation">
            <summary>
            Annotation indicating the numeric object associated with an annotation
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.UseMarkedDiscourseAnnotation">
            <summary>
            Used in dcoref to indicate that the it should use the discourse information annotated in the document
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.UtteranceAnnotation">
            <summary>
            Used in dcoref to store discourse information. (marking TURN or quotation)
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.SpeakerAnnotation">
            <summary>
            Used in dcoref to store speaker information.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.ParagraphAnnotation">
            <summary>
            Used in dcoref to store paragraph information.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.LeftChildrenNodeAnnotation">
            <summary>
            Used in incremental DAG parser
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreAnnotations.AntecedentAnnotation">
            <summary>
            The CoreMap key identifying the annotation's antecedent.
            
            The intent of this annotation is to go with words that have been
            linked via coref to some other entity.  For example, if "dog" is
            corefed to "cirrus" in the sentence "Cirrus, a small dog, ate an
            entire pumpkin pie", then "dog" would have the AntecedentAnnotation "cirrus".
            
            This annotation is currently used ONLY in the KBP slot filling project.
            In that project, "cirrus" from the example above would also have an
            AntecedentAnnotation of "cirrus".
            Generally, you want to use the usual coref graph annotations
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreLabel">
            <summary>
            A CoreLabel represents a single word with ancillary information
            attached using CoreAnnotations.  If the proper annotations are set,
            the CoreLabel also provides convenient methods to access tags, lemmas, etc.
            
            A CoreLabel is a Map from keys (which are Class objects) to values,
            whose type is determined by the key.  That is, it is a heterogeneous
            typesafe Map (see Josh Bloch, Effective Java, 2nd edition).
            
            The CoreLabel class in particular bridges the gap between old-style JavaNLP
            Labels and the new CoreMap infrastructure.  Instances of this class can be
            used (almost) anywhere that the now-defunct FeatureLabel family could be
            used.  This data structure is backed by an {@link ArrayCoreMap}.
            
            @author dramage
            @author rafferty
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.CoreLabel.#ctor">
            <summary>
            Default constructor, calls base()
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.CoreLabel.#ctor(System.Int32)">
            <summary>
            Initializes this CoreLabel, pre-allocating arrays to hold
            up to capacity key,value pairs.  This array will grow if necessary.
            </summary>
            <param name="capacity">Initial capacity of object in key,value pairs</param>
        </member>
        <member name="M:OpenNLP.Tools.Ling.CoreLabel.#ctor(OpenNLP.Tools.Ling.CoreLabel)">
            <summary>
            Returns a new CoreLabel instance based on the contents of the given
            CoreLabel.  It copies the contents of the other CoreLabel.
            <i>Implementation note:</i> this is a the same as the constructor
            that takes a CoreMap, but is needed to ensure unique most specific
            type inference for selecting a constructor at compile-time.
            </summary>
            <param name="label">The CoreLabel to copy</param>
        </member>
        <member name="M:OpenNLP.Tools.Ling.CoreLabel.#ctor(OpenNLP.Tools.Util.ICoreMap)">
            <summary>
            Returns a new CoreLabel instance based on the contents of the given
            CoreMap.  It copies the contents of the other CoreMap.
            </summary>
            <param name="label">The CoreMap to copy</param>
        </member>
        <member name="M:OpenNLP.Tools.Ling.CoreLabel.#ctor(OpenNLP.Tools.Ling.ILabel)">
            <summary>
            Returns a new CoreLabel instance based on the contents of the given label.
            Warning: The behavior of this method is a bit disjunctive!
            If label is a CoreMap (including CoreLabel), then its entire
            contents is copied into this label.  But, otherwise, just the
            value() and word iff it implements HasWord is copied.
            </summary>
            <param name="label">Basis for this label</param>
        </member>
        <member name="T:OpenNLP.Tools.Ling.CoreLabel.IGenericAnnotation`1">
            <summary>
            Class that all "generic" annotations extend.
            This allows you to read in arbitrary values from a file as features, for example.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:OpenNLP.Tools.Ling.CoreLabel.Factory">
            <summary>
            Return a factory for this kind of label
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.CoreLabel.GetString(System.Type)">
            <summary>
            Return a non-null string value for a key.
            This method is included for backwards compatibility with AbstractMapLabel.
            It is guaranteed to not return null; if the key is not present or
            has a null value, it returns the empty string ("").  It is only valid to
            call this method when key is paired with a value of type string.
            </summary>
            <param name="key">A key type with a string value to return the value of.</param>
            <returns>
            "" if the key is not in the map or has the value <code>null</code>
            and the string value of the key otherwise
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Ling.CoreLabel.SetFromString(System.String)">
            {@inheritDoc}
        </member>
        <member name="M:OpenNLP.Tools.Ling.CoreLabel.SetWord(System.String)">
            <summary>
            Sets the word value for the label.  
            Also, clears the lemma, since that may have changed if the word changed.
            </summary>
            <param name="word"></param>
        </member>
        <member name="M:OpenNLP.Tools.Ling.CoreLabel.Ner">
            <summary>
            Returns the named entity class of the label (or null if none).
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Ling.CoreLabel.TagSeparator">
            <summary>Tag separator to use by default</summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.CoreLabel.ToString(OpenNLP.Tools.Ling.CoreLabel.OutputFormat)">
            <summary>
            Returns a formatted string representing this label.
            The desired format is passed in as a <code>string</code>.
            Currently supported formats include:
            <ul>
            <li>"value": just prints the value</li>
            <li>"{map}": prints the complete map</li>
            <li>"value{map}": prints the value followed by the contained
            map (less the map entry containing key <code>CATEGORY_KEY</code>)</li>
            <li>"value-index": extracts a value and an integer index from
            the contained map using keys  <code>INDEX_KEY</code>,
            respectively, and prints them with a hyphen in between</li>
            <li>"value-tag"</li>
            <li>"value-tag-index"</li>
            <li>"value-index{map}": a combination of the above; the index is
            displayed first and then not shown in the map that is displayed</li>
            <li>"word": Just the value of HEAD_WORD_KEY in the map</li>
            </ul>
            
            Map is printed in alphabetical order of keys.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.ICoreAnnotation`1">
            <summary>
            The base class for any annotation that can be marked on a {@link CoreMap},
            parameterized by the type of the value associated with the annotation.
            Subclasses of this class are the keys in the {@link CoreMap}, so they are
            instantiated only by utility methods in {@link CoreAnnotations}.
            
            @author dramage
            @author rafferty
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.ICoreAnnotation`1.GetAnnotationType">
            <summary>
            Returns the type associated with this annotation.
            This method must return the same class type as its value type parameter.
            It feels like one should be able to get away without this method, but because Java
            erases the generic type signature, that info disappears at runtime.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.IHasCategory">
            <summary>
            Something that implements the <code>HasCategory</code> interface knows about categories.
            
            @author Christopher Manning
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.IHasCategory.Category">
            <summary>
            Returns the category value of the label (or null if none).
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.IHasCategory.SetCategory(System.String)">
            <summary>
            Sets the category value for the label (if one is stored).
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.IHasContext">
            <summary>
            @author grenager
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.IHasContext.Before">
            <summary>
            Returns the string before the word
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.IHasContext.SetBefore(System.String)">
            <summary>
            Set the whitespace string before the word.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.IHasContext.OriginalText">
            <summary>
            Returns the string which is the original character sequence of the token.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.IHasContext.SetOriginalText(System.String)">
            <summary>
            Set the string which is the original character sequence of the token.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.IHasContext.After">
            <summary>
            Returns the whitespace string after the word.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.IHasContext.SetAfter(System.String)">
            <summary>
            Sets the whitespace string after the word.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.IHasIndex">
            <summary>
            @author grenager
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.IHasLemma">
            <summary>
            Something that implements the <code>HasLemma</code> interface knows about lemmas.
            
            @author John Bauer
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.IHasLemma.Lemma">
            <summary>
            Return the lemma value of the label (or null if none).
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.IHasLemma.SetLemma(System.String)">
            <summary>
            Set the lemma value for the label (if one is stored).
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.IHasOffset">
            <summary>
            Something that implements the <code>HasOffset</code> interface
            bears a offset reference to the original text
            
            @author Richard Eckart (Technische Universitat Darmstadt)
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.IHasOffset.BeginPosition">
            <summary>
            Return the beginning character offset of the label (or -1 if none).
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.IHasOffset.SetBeginPosition(System.Int32)">
            <summary>
            Set the beginning character offset for the label.
            Setting this key to "-1" can be used to indicate no valid value.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.IHasOffset.EndPosition">
            <summary>
            Return the ending character offset of the label (or -1 if none).
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.IHasOffset.SetEndPosition(System.Int32)">
            <summary>
            Set the ending character offset of the label (or -1 if none).
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.IHasTag">
            <summary>
            Something that implements the <code>HasTag</code> interface knows about part-of-speech tags.
            
            @author Christopher Manning
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.IHasTag.Tag">
            <summary>
            Return the tag value of the label (or null if none).
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.IHasTag.SetTag(System.String)">
            <summary>
            Set the tag value for the label (if one is stored).
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.IHasWord">
            <summary>
            Something that implements the <code>HasWord</code> interface knows about words.
            
            @author Christopher Manning
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.IHasWord.GetWord">
            <summary>
            Return the word value of the label (or null if none).
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.IHasWord.SetWord(System.String)">
            <summary>
            Set the word value for the label (if one is stored).
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.ILabel">
            <summary>
            Something that implements the <code>Label</code> interface can act as a
            constituent, node, or word label with linguistic attributes.
            A <code>Label</code> is required to have a "primary" <code>string</code>
            <code>value()</code> (although this may be null).  This is referred to as
            its <code>value</code>.
            
            Implementations of Label split into two groups with
            respect to equality. Classes that extend ValueLabel define equality
            solely in terms of string equality of its value (secondary facets may be
            present but are ignored for purposes of equality), and have equals and
            compareTo defined across all subclasses of ValueLabel. This behavior
            should not be changed. Other classes that implement Label define equality only
            with their own type and require all fields of the type to be equal.
            
            A subclass that extends another Label class <i>should</i> override
            the definition of <code>labelFactory()</code>, since the contract for
            this method is that it should return a factory for labels of the
            exact same object type.
            
            @author Christopher Manning
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.ILabel.Value">
            <summary>
            Return a string representation of just the "main" value of this label.
            </summary>
            <returns>the "value" of the label</returns>
        </member>
        <member name="M:OpenNLP.Tools.Ling.ILabel.SetValue(System.String)">
            <summary>
            Set the value for the label (if one is stored).
            </summary>
            <param name="value">the value for the label</param>
        </member>
        <member name="M:OpenNLP.Tools.Ling.ILabel.ToString">
            <summary>
            Return a string representation of the label.  For a multipart label,
            this will return all parts.  The <code>ToString()</code> method
            causes a label to spill its guts.  It should always return an
            empty string rather than <code>null</code> if there is no value.
            </summary>
            <returns>a text representation of the full label contents</returns>
        </member>
        <member name="M:OpenNLP.Tools.Ling.ILabel.SetFromString(System.String)">
            <summary>
            Set the contents of this label to this <code>string</code> representing the
            complete contents of the label.  A class implementing label may 
            throw an <code>UnsupportedOperationException</code> for this method (only).
            Typically, this method would do some appropriate decoding 
            of the string in a way that sets multiple fields 
            in an inverse of the <code>ToString()</code> method.
            </summary>
            <param name="labelStr">the string that translates into the content of the label</param>
        </member>
        <member name="M:OpenNLP.Tools.Ling.ILabel.LabelFactory">
            <summary>
            Returns a factory that makes labels of the exact same type as this one.
            May return <code>null</code> if no appropriate factory is known.
            </summary>
            <returns>the LabelFactory for this kind of label</returns>
        </member>
        <member name="T:OpenNLP.Tools.Ling.ILabeled">
            <summary>
            A <code>LabeledScoredTreeFactory</code> acts as a factory for creating
            trees with labels and scores.  Unless another <code>LabelFactory</code>
            is supplied, it will use a <code>CoreLabel</code> by default.
            
            @author Christopher Manning
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.ILabeled.Label">
            <summary>
            Returns one of the labels of the object (if there are multiple labels,
            preferably the primary label, if it exists).
            Returns null if there is no label.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.ILabeled.SetLabel(OpenNLP.Tools.Ling.ILabel)">
            <summary>
            Sets the label associated with this object.
            </summary>
            <param name="label">The Label value</param>
        </member>
        <member name="M:OpenNLP.Tools.Ling.ILabeled.Labels">
            <summary>
            Gives back all labels for this thing.
            </summary>
            <returns>
            A Collection of the Object's labels.
            Returns an empty Collection if there are no labels.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Ling.ILabeled.SetLabels(System.Collections.Generic.ICollection{OpenNLP.Tools.Ling.ILabel})">
            <summary>
            Sets the labels associated with this object.
            </summary>
            <param name="labels">The set of Label values</param>
        </member>
        <member name="T:OpenNLP.Tools.Ling.ILabelFactory">
            <summary>
            A <code>LabelFactory</code> object acts as a factory for creating
            objects of class <code>Label</code>, or some descendant class.
            It can also make Labels from Strings, optionally with options.
            
            @author Christopher Manning
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.ILabelFactory.NewLabel(System.String)">
            <summary>
            Make a new label with this <code>string</code> as the <code>value</code>.
            Any other fields of the label would normally be <code>null</code>.
            </summary>
            <param name="labelStr">The string that will be used for value</param>
            <returns>The new Label</returns>
        </member>
        <member name="M:OpenNLP.Tools.Ling.ILabelFactory.NewLabel(System.String,System.Int32)">
            <summary>
            Make a new label with this <code>string</code> as the value, and
            the type determined in an implementation-dependent way from the options value.
            </summary>
            <param name="labelStr">The string that will be used for value</param>
            <param name="options">May determine what kind of label is created</param>
            <returns>The new Label</returns>
        </member>
        <member name="M:OpenNLP.Tools.Ling.ILabelFactory.NewLabelFromString(System.String)">
            <summary>
            Make a new label.  The string argument will be decomposed into
            multiple fields in an implementing class-specific way, in
            accordance with the class's setFromString() method.
            </summary>
            <param name="encodedLabelStr">
            The string that will be used for labelling the object (by decoding it into parts)
            </param>
            <returns>The new Label</returns>
        </member>
        <member name="M:OpenNLP.Tools.Ling.ILabelFactory.NewLabel(OpenNLP.Tools.Ling.ILabel)">
            <summary>
            Create a new <code>Label</code>, where the label is formed from
            the <code>Label</code> object passed in.
            The new Label is guaranteed to at least copy the <code>value()</code> of the
            source label (if non-null); it may also copy other components
            (this is implementation-specific).  However, if oldLabel is of
            the same type as is produced by the factory, then the whole
            label should be cloned, so that the returnedLabel.equals(oldLabel).
            <i>Implementation note:</i> That last sentence isn't true of all
            current implementations (e.g., WordTag), but we should make it so that it is true!
            </summary>
            <param name="oldLabel">The Label that the new label is being created from</param>
            <returns>The new label of a particular type</returns>
        </member>
        <member name="T:OpenNLP.Tools.Ling.IndexedWord">
            <summary>
            This class is mainly for use with RTE in terms of the methods it provides,
            but on a more general level, it provides a {@link CoreLabel} that uses its
            DocIDAnnotation, SentenceIndexAnnotation, and IndexAnnotation to implement
            Comparable/compareTo, hashCode, and equals.  This means no other annotations,
            including the identity of the word, are taken into account when using these
            methods.
            
            The actual implementation is to wrap a <code>CoreLabel</code>.
            This avoids breaking the <code>equals()</code> and
            <code>hashCode()</code> contract and also avoids expensive copying
            when used to represent the same data as the original <code>CoreLabel</code>.
            
            @author rafferty
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Ling.IndexedWord.NoWord">
            <summary>
            The identifier that points to no word.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.IndexedWord.#ctor">
            <summary>
            Default constructor; uses {@link CoreLabel} default constructor
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.IndexedWord.#ctor(OpenNLP.Tools.Ling.ILabel)">
            <summary>
            Copy Constructor - relies on {@link CoreLabel} copy constructor.
            It will set the value, and if the word is not set otherwise, set
            the word to the value.
            </summary>
            <param name="w">A Label to initialize this IndexedWord from</param>
        </member>
        <member name="M:OpenNLP.Tools.Ling.IndexedWord.#ctor(OpenNLP.Tools.Ling.CoreLabel)">
            <summary>
            Construct an IndexedWord from a CoreLabel just as for a CoreMap.
            <i>Implementation note:</i> this is a the same as the constructor
            that takes a CoreMap, but is needed to ensure unique most specific
            type inference for selecting a constructor at compile-time.
            </summary>
            <param name="w">A Label to initialize this IndexedWord from</param>
        </member>
        <member name="M:OpenNLP.Tools.Ling.IndexedWord.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Constructor for setting docID, sentenceIndex, and
            index without any other annotations.
            </summary>
            <param name="docId">The document ID (arbitrary string)</param>
            <param name="sentenceIndex">The sentence number in the document (normally 0-based)</param>
            <param name="index">The index of the word in the sentence (normally 0-based)</param>
        </member>
        <member name="M:OpenNLP.Tools.Ling.IndexedWord.Get(System.Type)">
            TODO: would be nice to get rid of this.  Only used in two places in RTE.  
        </member>
        <member name="M:OpenNLP.Tools.Ling.IndexedWord.Equals(System.Object)">
            <summary>
            This .equals is dependent only on docID, sentenceIndex, and index.
            It doesn't consider the actual word value, but assumes that it is
            validly represented by token position.
            All IndexedWords that lack these fields will be regarded as equal.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.IndexedWord.GetHashCode">
            <summary>
            This hashCode uses only the docID, sentenceIndex, and index. See compareTo for more info.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.IndexedWord.CompareTo(OpenNLP.Tools.Ling.IndexedWord)">
            <summary>
            NOTE: This compareTo is based on and made to be compatible with the one
            from IndexedFeatureLabel.  You <em>must</em> have a DocIDAnnotation,
            SentenceIndexAnnotation, and IndexAnnotation for this to make sense and
            be guaranteed to work properly. Currently, it won't error out and will
            try to return something sensible if these are not defined, but that really
            isn't proper usage!
            
            This compareTo method is based not by value elements like the word(),
            but on passage position. It puts NO_WORD elements first, and then orders
            by document, sentence, and word index.  If these do not differ, it returns equal.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.IndexedWord.ToString">
            <summary>Returns the value-tag of this label.</summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.IScored">
            <summary>
            Scored: This is a simple interface that says that an object can answer
            requests for the score, or goodness of the object.
            
            JavaNLP includes companion classes {@link ScoredObject} which is a simple
            composite of another object and a score, and {@link ScoredComparator}
            which compares Scored objects.
            
            @author Dan Klein
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.IScored.Score">
            <summary>
            Returns the score of this thing.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.LabeledWord">
            <summary>
            A <code>LabeledWord</code> object contains a word and its tag.
            The <code>value()</code> of a TaggedWord is the Word.
            The tag is, and is a Label instead of a String
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.LabeledWord.#ctor">
            <summary>
            Create a new <code>TaggedWord</code>.
            It will have <code>null</code> for its content fields
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.LabeledWord.#ctor(System.String)">
            <summary>
            Create a new <code>TaggedWord</code>.
            </summary>
            <param name="word">The word, which will have a <code>null</code> tag</param>
        </member>
        <member name="M:OpenNLP.Tools.Ling.LabeledWord.#ctor(System.String,OpenNLP.Tools.Ling.ILabel)">
            <summary>
            Create a new <code>TaggedWord</code>.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.LabeledWord.Factory">
            <summary>
            Return a factory for this kind of label.
            </summary>
            <returns>The label factory</returns>
        </member>
        <member name="T:OpenNLP.Tools.Ling.StringLabel">
            <summary>
            A <code>StringLabel</code> object acts as a Label by containing a
            single String, which it sets or returns in response to requests.
            The hashCode() and compareTo() methods for this class assume that this
            string value is non-null.  equals() is correctly implemented
            
            @author Christopher Manning
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Ling.StringLabel._beginPosition">
            <summary>Start position of the word in the original input string</summary>
        </member>
        <member name="F:OpenNLP.Tools.Ling.StringLabel._endPosition">
            <summary>End position of the word in the original input string</summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.StringLabel.#ctor">
            <summary>
            Create a new <code>StringLabel</code> with a null content (i.e., str).
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.StringLabel.#ctor(System.String)">
            <summary>
            Create a new <code>StringLabel</code> with the given content.
            </summary>
            <param name="str">The new label's content</param>
        </member>
        <member name="M:OpenNLP.Tools.Ling.StringLabel.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Create a new <code>StringLabel</code> with the given content.
            </summary>
            <param name="str">The new label's content</param>
            <param name="beginPosition">Start offset in original text</param>
            <param name="endPosition">End offset in original text</param>
        </member>
        <member name="M:OpenNLP.Tools.Ling.StringLabel.#ctor(OpenNLP.Tools.Ling.ILabel)">
            <summary>
            Create a new <code>StringLabel</code> with the
            <code>value()</code> of another label as its label.
            </summary>
            <param name="label">The other label</param>
        </member>
        <member name="M:OpenNLP.Tools.Ling.StringLabel.Value">
            <summary>
            Return the word value of the label (or null if none).
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.StringLabel.SetValue(System.String)">
            <summary>
            Set the value for the label.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.StringLabel.SetFromString(System.String)">
            <summary>
            Set the label from a string.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.StringLabel.LabelFactory">
            <summary>
            Return a factory for this kind of label (i.e., <code>StringLabel</code>).
            The factory returned is always the same one (a singleton).
            </summary>
            <returns>The label factory</returns>
        </member>
        <member name="M:OpenNLP.Tools.Ling.StringLabel.Factory">
            <summary>
            Return a factory for this kind of label.
            </summary>
            <returns>The label factory</returns>
        </member>
        <member name="T:OpenNLP.Tools.Ling.StringLabelFactory">
            <summary>
            A <code>StringLabelFactory</code> object makes a simple
            <code>StringLabel</code> out of a <code>string</code>.
            
            @author Christopher Manning
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.StringLabelFactory.NewLabel(System.String)">
            <summary>
            Make a new label with this <code>string</code> as the "name".
            </summary>
            <param name="labelStr">
            A string that determines the content of the label. For a StringLabel, it is exactly the given string
            </param>
            <returns>The created label</returns>
        </member>
        <member name="M:OpenNLP.Tools.Ling.StringLabelFactory.NewLabel(System.String,System.Int32)">
            <summary>
            Make a new label with this <code>string</code> as the "name".
            </summary>
            <param name="labelStr">
            A string that determines the content of the label. For a StringLabel, it is exactly the given string
            </param>
            <param name="options">The options are ignored by a StringLabelFactory</param>
            <returns>The created label</returns>
        </member>
        <member name="M:OpenNLP.Tools.Ling.StringLabelFactory.NewLabelFromString(System.String)">
            <summary>
            Make a new label with this <code>string</code> as the "name".
            This version does no decoding -- StringLabels just have a value.
            </summary>
            <param name="labelStr">
            A string that determines the content of the label. For a StringLabel, it is exactly the given string
            </param>
            <returns>The created label</returns>
        </member>
        <member name="M:OpenNLP.Tools.Ling.StringLabelFactory.NewLabel(OpenNLP.Tools.Ling.ILabel)">
            <summary>
            Create a new <code>StringLabel</code>, where the label is formed from
            the <code>Label</code> object passed in.  Depending on what fields
            each label has, other things will be <code>null</code>.
            </summary>
            <param name="oldLabel">The Label that the new label is being created from</param>
            <returns>a new label of a particular type</returns>
        </member>
        <member name="T:OpenNLP.Tools.Ling.TaggedWord">
            <summary>
            A <code>TaggedWord</code> object contains a word and its tag.
            The <code>value()</code> of a TaggedWord is the Word.
            The tag is secondary.
            
            @author Christopher Manning
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.TaggedWord.#ctor">
            <summary>
            Create a new <code>TaggedWord</code>. It will have <code>null</code> for its content fields.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.TaggedWord.#ctor(System.String)">
            <summary>
            Create a new <code>TaggedWord</code>.
            </summary>
            <param name="word">The word, which will have a <code>null</code> tag</param>
        </member>
        <member name="M:OpenNLP.Tools.Ling.TaggedWord.#ctor(System.String,System.String)">
            <summary>
            Create a new <code>TaggedWord</code>.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.TaggedWord.#ctor(OpenNLP.Tools.Ling.ILabel)">
            <summary>
            Create a new <code>TaggedWord</code>.
            </summary>
            <param name="oldLabel">
            A Label.  If it implements the HasWord and/or HasTag interface, then the corresponding value will be set
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Ling.TaggedWord.#ctor(OpenNLP.Tools.Ling.ILabel,OpenNLP.Tools.Ling.ILabel)">
            <summary>
            Create a new <code>TaggedWord</code>.
            </summary>
            <param name="word">This word is passed to the supertype constructor</param>
            <param name="tag">The <code>value()</code> of this label is set as the tag of this Label</param>
        </member>
        <member name="M:OpenNLP.Tools.Ling.TaggedWord.SetFromString(System.String)">
            <summary>
            Sets a TaggedWord from decoding the <code>string</code> passed in.
            The string is divided according to the divider character (usually, "/").
            We assume that we can always just divide on the rightmost divider character,
            rather than trying to parse up escape sequences.
            If the divider character isn't found in the word, 
            then the whole string becomes the word, and the tag is <code>null</code>.
            </summary>
            <param name="taggedWord">The word that will go into the <code>Word</code></param>
        </member>
        <member name="M:OpenNLP.Tools.Ling.TaggedWord.LabelFactory">
            <summary>
            Return a factory for this kind of label (i.e., <code>TaggedWord</code>).
            The factory returned is always the same one (a singleton).
            </summary>
            <returns>The label factory</returns>
        </member>
        <member name="M:OpenNLP.Tools.Ling.TaggedWord.Factory">
            <summary>
            Return a factory for this kind of label.
            </summary>
            <returns>The label factory</returns>
        </member>
        <member name="T:OpenNLP.Tools.Ling.TaggedWordFactory">
            <summary>
            A <code>TaggedWordFactory</code> acts as a factory for creating objects of
            class <code>TaggedWord</code>.
            
            @author Christopher Manning
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.TaggedWordFactory.#ctor">
            <summary>
            Create a new <code>TaggedWordFactory</code>. The divider will be taken as '/'.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.TaggedWordFactory.#ctor(System.Char)">
            <summary>
            Create a new <code>TaggedWordFactory</code>.
            </summary>
            <param name="divider">
            This character will be used in calls to the one argument version 
            of <code>newLabel()</code>, to divide the word from the tag.
            Stuff after the last instance of this character will become the tag, 
            and stuff before it will become the label.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Ling.TaggedWordFactory.NewLabel(System.String)">
            <summary>
            Make a new label with this <code>string</code> as the value (word).
            Any other fields of the label would normally be null.
            </summary>
            <param name="labelStr">The string that will be used for value</param>
            <returns>The new TaggedWord (tag will be <code>null</code>)</returns>
        </member>
        <member name="M:OpenNLP.Tools.Ling.TaggedWordFactory.NewLabel(System.String,System.Int32)">
            <summary>
            Make a new label with this <code>string</code> as a value component.
            Any other fields of the label would normally be null.
            </summary>
            <param name="labelStr">The string that will be used for value</param>
            <param name="options">what to make (use labelStr as word or tag)</param>
            <returns>The new TaggedWord (tag or word will be <code>null</code>)</returns>
        </member>
        <member name="M:OpenNLP.Tools.Ling.TaggedWordFactory.NewLabelFromString(System.String)">
            <summary>
            Create a new word, where the label is formed from the <code>string</code> passed in.
            The string is divided according to the divider character.
            We assume that we can always just divide on the rightmost divider character,
            rather than trying to parse up escape sequences.
            If the divider character isn't found in the word, 
            then the whole string becomes the word, and the tag is <code>null</code>.
            </summary>
            <param name="word">The word that will go into the <code>Word</code></param>
            <returns>The new TaggedWord</returns>
        </member>
        <member name="M:OpenNLP.Tools.Ling.TaggedWordFactory.NewLabel(OpenNLP.Tools.Ling.ILabel)">
            <summary>
            Create a new <code>TaggedWord Label</code>, where the label is formed from
            the <code>Label</code> object passed in.
            Depending on what fields each label has, other things will be <code>null</code>.
            </summary>
            <param name="oldLabel">The Label that the new label is being created from</param>
            <returns>a new label of a particular type</returns>
        </member>
        <member name="T:OpenNLP.Tools.Ling.ValueLabel">
            <summary>
            A <code>ValueLabel</code> object acts as a Label with linguistic attributes.
            This is an abstract class, which doesn't actually store or return anything.
            It returns <code>null</code> to any requests. 
            However, it does stipulate that equals() and compareTo() are defined solely with respect to
            value(); this should not be changed by subclasses.
            Other fields of a ValueLabel subclass should be regarded as secondary facets 
            (it is almost impossible to override equals in a useful way while 
            observing the contract for equality defined for Object, in particular, 
            that equality must by symmetric).
            This class is designed to be extended.
            
            @author Christopher Manning
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.ValueLabel.Value">
            <summary>
            Return the value of the label (or null if none).
            The default value returned by an <code>ValueLabel</code> is always <code>null</code>
            </summary>
            <returns>the value for the label</returns>
        </member>
        <member name="M:OpenNLP.Tools.Ling.ValueLabel.SetValue(System.String)">
            <summary>
            Set the value for the label (if one is stored).
            </summary>
            <param name="value">the value for the label</param>
        </member>
        <member name="M:OpenNLP.Tools.Ling.ValueLabel.ToString">
            <summary>
            Return a string representation of the label.
            This will just be the <code>value()</code> if it is non-<code>null</code>,
            and the empty string otherwise.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.ValueLabel.Equals(System.Object)">
            <summary>
            Equality for <code>ValueLabel</code>s is defined in the first instance
            as equality of their <code>string</code> <code>value()</code>.
            Now rewritten to correctly enforce the contract of equals in Object.
            Equality for a <code>ValueLabel</code> is determined simply by String
            equality of its <code>value()</code>.  Subclasses should not redefine
            this to include other aspects of the <code>ValueLabel</code>, or the
            contract for <code>equals()</code> is broken.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.ValueLabel.CompareTo(OpenNLP.Tools.Ling.ValueLabel)">
            <summary>Orders by <code>value()</code>'s lexicographic ordering.</summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.ValueLabel.LabelFactory">
            <summary>
            Returns a factory that makes Labels of the appropriate sort.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Ling.Word">
            <summary>
            A <code>Word</code> object acts as a Label by containing a string.
            This class is in essence identical to a <code>StringLabel</code>, but
            it also uses the value to implement the <code>HasWord</code> interface.
            
            @author Christopher Manning
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Ling.Word.EmptyString">
            <summary>string representation of an empty</summary>
        </member>
        <member name="F:OpenNLP.Tools.Ling.Word.Empty">
            <summary>Word representation of an empty</summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.Word.#ctor">
            <summary>
            Construct a new word with a <code>null</code> value.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.Word.#ctor(System.String)">
            <summary>
            Construct a new word, with the given value.
            </summary>
            <param name="word">string value of the Word</param>
        </member>
        <member name="M:OpenNLP.Tools.Ling.Word.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Construct a new word, with the given value.
            </summary>
            <param name="word">string value of the Word</param>
        </member>
        <member name="M:OpenNLP.Tools.Ling.Word.#ctor(OpenNLP.Tools.Ling.ILabel)">
            <summary>
            Creates a new word whose word value is the value of any 
            class that supports the <code>Label</code> interface.
            </summary>
            <param name="lab">The label to be used as the basis of the new Word</param>
        </member>
        <member name="M:OpenNLP.Tools.Ling.Word.LabelFactory">
            <summary>
            Return a factory for this kind of label (i.e., {@code Word}).
            The factory returned is always the same one (a singleton).
            </summary>
            <returns>The label factory</returns>
        </member>
        <member name="M:OpenNLP.Tools.Ling.Word.Factory">
            <summary>
            Return a factory for this kind of label.
            </summary>
            <returns>The label factory</returns>
        </member>
        <member name="T:OpenNLP.Tools.Ling.WordFactory">
            <summary>
            A <code>WordFactory</code> acts as a factory for creating objects of class <code>Word</code>.
            
            @author Christopher Manning
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Ling.WordFactory.NewLabel(System.String)">
            <summary>
            Create a new word, where the label is formed from the <code>string</code> passed in.
            </summary>
            <param name="word">The word that will go into the <code>Word</code></param>
            <returns>The new label</returns>
        </member>
        <member name="M:OpenNLP.Tools.Ling.WordFactory.NewLabel(System.String,System.Int32)">
            <summary>
            Create a new word, where the label is formed from the <code>string</code> passed in.
            </summary>
            <param name="word">The word that will go into the <code>Word</code></param>
            <param name="options">is ignored by a WordFactory</param>
            <returns>The new label</returns>
        </member>
        <member name="M:OpenNLP.Tools.Ling.WordFactory.NewLabelFromString(System.String)">
            <summary>
            Create a new word, where the label is formed from the <code>string</code> passed in.
            </summary>
            <param name="word">The word that will go into the <code>Word</code></param>
            <returns>The new label</returns>
        </member>
        <member name="M:OpenNLP.Tools.Ling.WordFactory.NewLabel(OpenNLP.Tools.Ling.ILabel)">
            <summary>
            Create a new <code>Word Label</code>, where the label is formed from
            the <code>Label</code> object passed in.
            Depending on what fields each label has, other things will be <code>null</code>.
            </summary>
            <param name="oldLabel">The Label that the new label is being created from</param>
            <returns>a new label of a particular type</returns>
        </member>
        <member name="T:OpenNLP.Tools.NameFind.DefaultNameContextGenerator">
            <summary>
            Class for determining contextual features for a tag/chunk style named-entity recognizer.
            </summary>
            
        </member>
        <member name="M:OpenNLP.Tools.NameFind.DefaultNameContextGenerator.#ctor">
            <summary>
            Creates a name context generator.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.NameFind.DefaultNameContextGenerator.#ctor(System.Int32)">
            <summary>
            Creates a name context generator with the specified cache size.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.NameFind.DefaultNameContextGenerator.GetContext(System.Int32,System.String[],System.String[],System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Return the context for finding names at the specified index.
            </summary>
            <param name="index">
            The index of the token in the specified tokens array for which the context should be constructed. 
            </param>
            <param name="tokens">
            tokens of the sentence.
            </param>
            <param name="predicates">
            The previous decisions made in the tagging of this sequence.  Only indices less than {index} will be examined.
            </param>
            <param name="previousTags">
            A mapping between tokens and the previous outcome for these tokens. 
            </param>
            <returns>
            the context for finding names at the specified index.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.NameFind.DefaultNameContextGenerator.GetStaticFeatures(System.String[],System.Int32,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Returns a list of the features for <code>tokens[index]</code> that can
            be safely cached.  In other words, return a list of all
            features that do not depend on previous outcome or decision
            features.  This method is called by <code>search</code>.
            </summary>
            <param name="tokens">
            The list of tokens being processed.
            </param>
            <param name="index">
            The index of the token whose features should be
            returned.
            </param>
            <param name="previousTags">
            The list of previous tags.
            </param>
            <returns> a list of the features for <code>tokens[index]</code> that can
            be safely cached.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.NameFind.DefaultNameContextGenerator.WordFeature(System.String)">
            <summary>
            Return the most relevant feature for a given word.  This method
            is used to get the features for words
            within a window of the word being analyzed.  Typical features
            are "2d" (2 digits); "4d" (4 digits); and "ac" (all caps).
            Note that only a single feature is returned.  The default
            feature is "other".
            </summary>
            <param name="word">
            The word whose features should be returned.
            </param>
            <returns>
            A feature code.
            </returns>
        </member>
        <member name="T:OpenNLP.Tools.NameFind.EnglishNameFinder">
            <summary> Class is used to create a name finder for English.</summary>
        </member>
        <member name="M:OpenNLP.Tools.NameFind.EnglishNameFinder.ProcessText(System.String[],System.String)">
            <summary>Adds sgml style name tags to the specified input string and outputs this information</summary>
            <param name="models">The model names for the name finders to be used</param>
            <param name="line">The input</param>
        </member>
        <member name="T:OpenNLP.Tools.NameFind.INameContextGenerator">
            <summary>
            Context generator for the name find tool.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.NameFind.INameContextGenerator.GetContext(System.Int32,System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.String},System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Returns the contexts for chunking of the specified index.
            </summary>
            <param name="tokenIndex">
            The index of the token in the specified tokens array for which the context should be constructed. 
            </param>
            <param name="tokens">
            The tokens of the sentence.
            </param>
            <param name="previousDecisions">
            The previous decisions made in the tagging of this sequence.  Only indices less than tokenIndex will be examined.
            </param>
            <param name="previousTags">
            A mapping between tokens and the previous outcome for these tokens. 
            </param>
            <returns>
            An array of predictive contexts on which a model basis its decisions.
            </returns>
        </member>
        <member name="T:OpenNLP.Tools.NameFind.INameFinder">
            <summary>
            The interface for name finders which provide name tags for a sequence of tokens.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.NameFind.INameFinder.Find(System.String[],System.Collections.IDictionary)">
            <summary>
            Generates name tags for the given sequence returning the result in an array.
            </summary>
            <param name="tokens">
            an array of the tokens or words of the sequence.
            </param>
            <param name="previousTags">
            a mapping between tokens and outcomes from previous sentences. 
            </param>
            <returns>
            an array of chunk tags for each token in the sequence.
            </returns>
        </member>
        <member name="T:OpenNLP.Tools.NameFind.MaximumEntropyNameFinder">
            <summary>
            Class for creating a maximum-entropy-based name finder.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.NameFind.MaximumEntropyNameFinder.#ctor(SharpEntropy.IMaximumEntropyModel)">
            <summary>
            Creates a new name finder with the specified model.
            </summary>
            <param name="model">
            The model to be used to find names.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.NameFind.MaximumEntropyNameFinder.#ctor(SharpEntropy.IMaximumEntropyModel,OpenNLP.Tools.NameFind.INameContextGenerator)">
            <summary>
            Creates a new name finder with the specified model and context generator.
            </summary>
            <param name="model">
            The model to be used to find names.
            </param>
            <param name="contextGenerator">
            The context generator to be used with this name finder.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.NameFind.MaximumEntropyNameFinder.#ctor(SharpEntropy.IMaximumEntropyModel,OpenNLP.Tools.NameFind.INameContextGenerator,System.Int32)">
            <summary>
            Creates a new name finder with the specified model and context generator.
            </summary>
            <param name="model">
            The model to be used to find names.
            </param>
            <param name="contextGenerator">
            The context generator to be used with this name finder.
            </param>
            <param name="beamSize">
            The size of the beam to be used in decoding this model.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.NameFind.MaximumEntropyNameFinder.ValidOutcome(System.String,OpenNLP.Tools.Util.Sequence)">
            <summary>
            This method determines wheter the outcome is valid for the preceding sequence.  
            This can be used to implement constraints on what sequences are valid.  
            </summary>
            <param name="outcome">
            The outcome.
            </param>
            <param name="sequence">
            The preceding sequence of outcome assignments. 
            </param>
            <returns>
            true is the outcome is valid for the sequence, false otherwise.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.NameFind.MaximumEntropyNameFinder.GetProbabilities(System.Double[])">
            <summary>
            Populates the specified array with the probabilities of the last decoded sequence.  The
            sequence was determined based on the previous call to <code>chunk</code>.  The 
            specified array should be at least as large as the numbe of tokens in the previous call to <code>chunk</code>.
            </summary>
            <param name="probabilities">
            An array used to hold the probabilities of the last decoded sequence.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.NameFind.MaximumEntropyNameFinder.GetProbabilities">
            <summary>
            Returns an array with the probabilities of the last decoded sequence.  The
            sequence was determined based on the previous call to <code>chunk</code>.
            </summary>
            <returns>
            An array with the same number of probabilities as tokens were sent to <code>chunk</code>
            when it was last called.   
            </returns>
        </member>
        <member name="T:OpenNLP.Tools.NameFind.MaximumEntropyNameFinder.NameBeamSearch">
            <summary>
            Implementation of the abstract beam search to allow the name finder to use the common beam search code. 
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.NameFind.MaximumEntropyNameFinder.NameBeamSearch.#ctor(OpenNLP.Tools.NameFind.MaximumEntropyNameFinder,System.Int32,OpenNLP.Tools.NameFind.INameContextGenerator,SharpEntropy.IMaximumEntropyModel,System.Int32)">
            <summary>
            Creates a beam seach of the specified size using the specified model with the specified context generator.
            </summary>
            <param name="nameFinder">
            The associated MaximumEntropyNameFinder instance.
            </param>
            <param name="size">
            The size of the beam.
            </param>
            <param name="contextGenerator">
            The context generator used with the specified model.
            </param>
            <param name="model">
            The model used to determine names.
            </param>
            <param name="beamSize">
            The size of the beam to use in searching.
            </param>
        </member>
        <member name="T:OpenNLP.Tools.NameFind.NameFinderEventReader">
            <summary>
            Class for creating a training event reader out of data files for training a name finder.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.NameFind.NameFinderEventReader.mPreviousTags">
            <summary>
            A mapping between tokens and the name tag assigned to them previously. 
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.NameFind.NameFinderEventReader.mEventIndex">
            <summary>
            The index into the array of events.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.NameFind.NameFinderEventReader.mLine">
            <summary>
            The last line read in from the data file.
            </summary>	
        </member>
        <member name="M:OpenNLP.Tools.NameFind.NameFinderEventReader.#ctor(SharpEntropy.ITrainingDataReader{System.String})">
            <summary>
            Creates a new event reader based on the specified data reader.
            </summary>
            <param name="dataReader">
            The data stream for this event reader.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.NameFind.NameFinderEventReader.#ctor(SharpEntropy.ITrainingDataReader{System.String},OpenNLP.Tools.NameFind.INameContextGenerator)">
            <summary>
            Creates a new event reader based on the specified data reader using the specified context generator.
            </summary>
            <param name="dataReader">
            The data reader for this event reader.
            </param>
            <param name="contextGenerator">
            The context generator which should be used in the creation of events for this event stream.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.NameFind.NameFinderEventReader.AddEvents(System.String)">
            <summary>
            Adds name events for the specified sentence.
            </summary>
            <param name="sentence">
            The sentence for which name events should be added.
            </param>
        </member>
        <member name="T:OpenNLP.Tools.Parser.BuildContextGenerator">
            <summary>
            Class to generator predictive contexts for deciding how constituents should be combined together.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Parser.BuildContextGenerator.#ctor">
            <summary> 
            Creates a new context generator for making decisions about combining constituents together.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Parser.BuildContextGenerator.GetContext(System.Object)">
            <summary>
            Returns the predictive context used to determine how the constituent at the specified index 
            should be combined with other constituents. 
            </summary>
            <param name="input">
            Object array containing an array of Parse objects (the uncombined constituents), and the index of the
            relevant constituent.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Parser.BuildContextGenerator.GetContext(OpenNLP.Tools.Parser.Parse[],System.Int32)">
            <summary>
            Returns the predictive context used to determine how the constituent at the specified index 
            should be combined with other constituents. 
            </summary>
            <param name="constituents">
            The constituents which have yet to be combined into new constituents.
            </param>
            <param name="index">
            The index of the constituent whcihi is being considered.
            </param>
            <returns>
            the context for building constituents at the specified index.
            </returns>
        </member>
        <member name="T:OpenNLP.Tools.Parser.CheckContextGenerator">
            <summary>
            Class for generating predictive context for deciding when a constituent is complete.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Parser.CheckContextGenerator.#ctor">
            <summary>
            Creates a new context generator for generating predictive context for deciding when a constituent is complete.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Parser.CheckContextGenerator.GetContext(OpenNLP.Tools.Parser.Parse[],System.String,System.Int32,System.Int32)">
            <summary>
            Returns predictive context for deciding whether the specified constituents between the specified start and end index 
            can be combined to form a new constituent of the specified type.  
            </summary>
            <param name="constituents">
            The constituents which have yet to be combined into new constituents.
            </param>
            <param name="type">
            The type of the new constituent proposed.
            </param>
            <param name="firstConstituent">
            The first constituent of the proposed constituent.
            </param>
            <param name="lastConstituent">
            The last constituent of the proposed constituent.
            </param>
            <returns>
            The predictive context for deciding whether a new constituent should be created.
            </returns>
        </member>
        <member name="T:OpenNLP.Tools.Parser.ChunkContextGenerator">
            <summary>
            Creates predictive context for the pre-chunking phases of parsing.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Parser.ChunkContextGenerator.GetContext(System.Int32,System.String[],System.String[],System.String[])">
            <summary>
            Returns the contexts for chunking of the specified index.
            </summary>
            <param name="index">
            The index of the token in the specified tokens array for which the context should be constructed. 
            </param>
            <param name="words">
            The tokens of the sentence.  The <code>ToString()</code> methods of these objects should return the token text.
            </param>
            <param name="predicates">
            The previous decisions made in the tagging of this sequence.  Only indices less than i will be examined.
            </param>
            <param name="tags">
            The POS tags for the the specified tokens.
            </param>
            <returns>
            An array of predictive contexts on which a model basis its decisions.
            </returns>
        </member>
        <member name="T:OpenNLP.Tools.Parser.EnglishHeadRules">
            <summary> 
            Class for storing the English head rules associated with parsing. 
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Parser.EnglishTreebankParser">
            <summary>
            Class that wraps the MaximumEntropyParser to make it easy to perform full parses using the English Treebank
            based maximum entropy models.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Parser.EnglishTreebankParser.DoParse(System.String)">
            <summary>
            Builds the syntax tree (or parse tree) of a sentence.
            </summary>
            <param name="sentence">The sentence</param>
            <returns>The syntax tree</returns>
        </member>
        <member name="M:OpenNLP.Tools.Parser.EnglishTreebankParser.DoParse(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Builds the syntax Tree (or parse tree) of a tokenized sentence.
            </summary>
            <param name="tokens">The collection of tokens for a sentence</param>
            <returns>The sytax tree</returns>
        </member>
        <member name="T:OpenNLP.Tools.Parser.IHeadRules">
            <summary>
            Interface for encoding the head rules associated with parsing.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Parser.IHeadRules.GetHead(OpenNLP.Tools.Parser.Parse[],System.String)">
            <summary>
            Returns the head constituent for the specified constituents of the specified type.
            </summary>
            <param name="constituents">
            The constituents which make up a constituent of the specified type.
            </param>
            <param name="type">
            The type of a constituent which is made up of the specifed constituents.
            </param>
            <returns>
            The constituent which is the head.
            </returns>
        </member>
        <member name="T:OpenNLP.Tools.Parser.IParserChunker">
            <summary>
            Interface that a chunker used with the parser should implement.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Parser.IParserChunker.TopKSequences(System.String[],System.String[],System.Double)">
            <summary>
            Returns the top k chunk sequences for the specified sentence with the specified pos-tags
            </summary>
            <param name="sentence">
            The tokens of the sentence.
            </param>
            <param name="tags">
            The pos-tags for the specified sentence.
            </param>
            <param name="minSequenceScore">
            </param>
            <returns>
            the top k chunk sequences for the specified sentence.
            </returns>
        </member>
        <member name="T:OpenNLP.Tools.Parser.IParserTagger">
            <summary>
            Interface that a pos-tagger used by the parser must implement.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Parser.MaximumEntropyParser">
            <summary>
            Class for a shift reduce style parser based on Adwait Ratnaparki's 1998 thesis.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Parser.MaximumEntropyParser.m">
            <summary>
            The maximum number of parses advanced from all preceding parses at each derivation step.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Parser.MaximumEntropyParser.k">
            <summary>
            The maximum number of parses to advance from a single preceding parse.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Parser.MaximumEntropyParser.q">
            <summary>
            The minimum total probability mass of advanced outcomes.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Parser.MaximumEntropyParser.DefaultBeamSize">
            <summary>
            The default beam size used if no beam size is given.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Parser.MaximumEntropyParser.DefaultAdvancePercentage">
            <summary>
            The default amount of probability mass required of advanced outcomes.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Parser.MaximumEntropyParser.StartPrefix">
            <summary>
            Prefix for outcomes starting a constituent.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Parser.MaximumEntropyParser.ContinuePrefix">
            <summary>
            Prefix for outcomes continuing a constituent.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Parser.MaximumEntropyParser.OtherOutcome">
            <summary>
            Outcome for token which is not contained in a basal constituent.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Parser.MaximumEntropyParser.CompleteOutcome">
            <summary>
            Outcome used when a constituent is complete.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Parser.MaximumEntropyParser.IncompleteOutcome">
            <summary>
            Outcome used when a constituent is incomplete.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Parser.MaximumEntropyParser.#ctor(SharpEntropy.IMaximumEntropyModel,SharpEntropy.IMaximumEntropyModel,OpenNLP.Tools.Parser.IParserTagger,OpenNLP.Tools.Parser.IParserChunker,OpenNLP.Tools.Parser.IHeadRules)">
            <summary>
            Creates a new parser using the specified models and head rules.
            </summary>
            <param name="buildModel">
            The model to assign constituent labels.
            </param>
            <param name="checkModel">
            The model to determine a constituent is complete.
            </param>
            <param name="tagger">
            The model to assign pos-tags.
            </param>
            <param name="chunker">
            The model to assign flat constituent labels.
            </param>
            <param name="headRules">
            The head rules for head word perculation.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Parser.MaximumEntropyParser.#ctor(SharpEntropy.IMaximumEntropyModel,SharpEntropy.IMaximumEntropyModel,OpenNLP.Tools.Parser.IParserTagger,OpenNLP.Tools.Parser.IParserChunker,OpenNLP.Tools.Parser.IHeadRules,System.Int32,System.Double)">
            <summary>
            Creates a new parser using the specified models and head rules using the specified beam size and advance percentage.
            </summary>
            <param name="buildModel">
            The model to assign constituent labels.
            </param>
            <param name="checkModel">
            The model to determine a constituent is complete.
            </param>
            <param name="tagger">
            The model to assign pos-tags.
            </param>
            <param name="chunker">
            The model to assign flat constituent labels.
            </param>
            <param name="headRules">
            The head rules for head word perculation.
            </param>
            <param name="beamSize">
            The number of different parses kept during parsing.
            </param>
            <param name="advancePercentage">
            The minimal amount of probability mass which advanced outcomes must represent.
            Only outcomes which contribute to the top "advancePercentage" will be explored.
            </param>    
        </member>
        <member name="M:OpenNLP.Tools.Parser.MaximumEntropyParser.FullParse(OpenNLP.Tools.Parser.Parse,System.Int32)">
            <summary>
            Returns a parse for the specified parse of tokens.
            </summary>
            <param name="flatParse">
            A flat parse containing only tokens and a root node, p. 
            </param>
            <param name="parseCount">
            the number of parses required
            </param>
            <returns>
            A full parse of the specified tokens or the flat chunks of the tokens if a full parse could not be found.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Parser.MaximumEntropyParser.AdvanceParses(OpenNLP.Tools.Parser.Parse,System.Double,System.Double[],System.Double[])">
            <summary>
            Advances the specified parse and returns the an array advanced parses whose probability accounts for
            more than the speicficed amount of probability mass, Q.
            </summary>
            <param name="inputParse">
            The parse to advance.
            </param>
            <param name="qParam">
            The amount of probability mass that should be accounted for by the advanced parses.
            </param> 
        </member>
        <member name="M:OpenNLP.Tools.Parser.MaximumEntropyParser.AdvanceChunks(OpenNLP.Tools.Parser.Parse,System.Double)">
            <summary>
            Returns the top chunk sequences for the specified parse.
            </summary>
            <param name="inputParse">
            A pos-tag assigned parse.
            </param>
             <param name="minChunkScore">
             the minimum probability for an allowed chunk sequence.
             </param>
            <returns>
            The top chunk assignments to the specified parse.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Parser.MaximumEntropyParser.AdvanceTags(OpenNLP.Tools.Parser.Parse)">
            <summary>
            Advances the parse by assigning it POS tags and returns multiple tag sequences.
            </summary>
            <param name="inputParse">
            The parse to be tagged.
            </param>
            <returns>
            Parses with different pos-tag sequence assignments.
            </returns>
        </member>
        <member name="T:OpenNLP.Tools.Parser.ParseException">
            <summary>
            Exception class for problems detected during parsing.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Parser.Parse">
            <summary>
            Class for holding constituents.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Parser.Parse._parts">
            <summary>
            The sub-constituents of this parse.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Parser.Parse._derivation">
            <summary>
            The string buffer used to track the derivation of this parse.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Parser.Parse.Text">
            <summary>
            The text string on which this parse is based.  This object is shared among all parses for the same sentence.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Parser.Parse.Span">
            /// <summary>
            The character offsets into the text for this constituent.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Parser.Parse.Type">
            <summary>
            The syntactic type of this parse.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Parser.Parse.GetChildren">
            <summary>
            The sub-constituents of this parse.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Parser.Parse.ChildCount">
            <summary>
            The number of children for this parse node.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Parser.Parse.Head">
            <summary>
            The head parse of this parse. A parse can be its own head.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Parser.Parse.Label">
            <summary>
            The outcome assigned to this parse during construction of its parent parse.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Parser.Parse.Parent">
            <summary>
            The parent parse of this parse. 
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Parser.Parse.Probability">
            <summary>
            Returns the log of the product of the probability associated with all the decisions which formed this constituent.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Parser.Parse.IsComplete">
            <summary>Returns whether this parse is complete.</summary>
            <returns>Returns true if the parse contains a single top-most node.</returns>
        </member>
        <member name="M:OpenNLP.Tools.Parser.Parse.SetChild(System.Int32,System.String)">
            <summary>
            Replaces the child at the specified index with a new child with the specified label. 
            </summary>
            <param name="index">
            The index of the child to be replaced.
            </param>
            <param name="label">
            The label to be assigned to the new child.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Parser.Parse.IndexOf(OpenNLP.Tools.Parser.Parse)">
            <summary>
            Returns the index of this specified child.
            </summary>
            <param name="child">
            A child of this parse.
            </param>
            <returns>
            the index of this specified child or -1 if the specified child is not a child of this parse.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Parser.Parse.AddProbability(System.Double)">
            <summary>
            Adds the specified probability log to this current log for this parse.
            </summary>
            <param name="logProbability">
            The probaility of an action performed on this parse.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Parser.Parse.GetTagSequenceProbability">
            <summary>
            Returns the probability associated with the pos-tag sequence assigned to this parse.
            </summary>
            <returns>
            The probability associated with the pos-tag sequence assigned to this parse.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Parser.Parse.Insert(OpenNLP.Tools.Parser.Parse)">
            <summary>
            Inserts the specified constituent into this parse based on its text span.  This
            method assumes that the specified constituent can be inserted into this parse.
            </summary>
            <param name="constituent">
            The constituent to be inserted.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Parser.Parse.Show">
            <summary>
            Displays this parse using Penn Treebank-style formatting.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Parser.Parse.UpdateHeads(OpenNLP.Tools.Parser.IHeadRules)">
            <summary>
            Computes the head parses for this parse and its sub-parses and stores this information
            in the parse data structure. 
            </summary>
            <param name="rules">
            The head rules which determine how the head of the parse is computed.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Parser.Parse.GetTagNodes">
            <summary>
            Returns the parse nodes which are children of this node and which are pos tags.
            </summary>
            <returns>
            the parse nodes which are children of this node and which are pos tags.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Parser.Parse.GetCommonParent(OpenNLP.Tools.Parser.Parse)">
            <summary>
            Returns the deepest shared parent of this node and the specified node. 
            If the nodes are identical then their parent is returned.  
            If one node is the parent of the other then the parent node is returned.
            </summary>
            <param name="node">
            The node from which parents are compared to this node's parents.
            </param>
            <returns>
            the deepest shared parent of this node and the specified node.
            </returns>
        </member>
        <member name="F:OpenNLP.Tools.Parser.Parse.TypePattern">
            <summary>
            The pattern used to find the base constituent label of a Penn Treebank labeled constituent.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Parser.Parse.TokenPattern">
            <summary>
            The pattern used to identify tokens in Penn Treebank labeled constituents.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Parser.Parse.FromParseString(System.String)">
            <summary>
            Generates a Parse structure from the specified tree-bank style parse string. 
            </summary>
            <param name="parse">
            A tree-bank style parse string.
            </param>
            <returns>
            a Parse structure for the specified tree-bank style parse string.
            </returns>
        </member>
        <member name="T:OpenNLP.Tools.Parser.EventType">
            <summary>
             Enumerated type of event types for the parser. 
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Parser.ParserEventReader">
            <summary>
            Wrapper class for one of four parser event readers.  The particular event stream is specified 
            at construction.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Parser.ParserEventReader.#ctor(SharpEntropy.ITrainingDataReader{System.String},OpenNLP.Tools.Parser.IHeadRules,OpenNLP.Tools.Parser.EventType)">
            <summary>
            Create an event reader based on the specified data reader of the specified type using the specified head rules.
            </summary>
            <param name="dataReader">
            A 1-parse-per-line Penn Treebank Style parse. 
            </param>
            <param name="rules">
            The head rules.
            </param>
            <param name="eventType">
            The type of events desired (tag, chunk, build, or check).
            </param>
        </member>
        <member name="T:OpenNLP.Tools.PartsOfSpeech">
            <summary>
            The comprehensive list of all the parts of speech.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.PartsOfSpeech.IsVerb(System.String)">
            <summary>
            Returns true if the pos corresponds to a verb
            (base form, present form non 3rd, present form 3rd, past form,
            present particle/gerundive or past participle).
            Return false otherwise.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.PartsOfSpeech.IsNoun(System.String)">
            <summary>
            Returns true if the pos corresponds to a noun (plural, singular or proper).
            Returns false otherwise.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.PartsOfSpeech.IsProperNoun(System.String)">
            <summary>
            Returns true if the pos corresponds to a proper noun (plural or singular).
            Returns false otherwise.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.PartsOfSpeech.IsAdjective(System.String)">
            <summary>
            Returns true if the pos corresponds to an adjective
            (regular, comparative or superlative).
            Returns false otherwise.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.PartsOfSpeech.IsPersOrPossPronoun(System.String)">
            <summary>
            Returns true if the pos corresponds to a personnal or possessive pronoun.
            Returns false otherwise.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.PartsOfSpeech.Write(System.String)">
            <summary>
            Writes the part of speech to be human understandable
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.PartsOfSpeech.IsSupportedPartOfSpeech(System.String)">
            <summary>
            Checks if a string corresponds to a supported part of speech
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.PosTagger.DefaultPosContextGenerator">
            <summary> 
            A context generator for the POS Tagger.
            </summary>	
        </member>
        <member name="M:OpenNLP.Tools.PosTagger.DefaultPosContextGenerator.GetContext(System.Int32,System.String[],System.String[])">
            <summary>
            Returns the context for making a pos tag decision at the specified token index given the specified tokens and previous tags.
            </summary>
            <param name="index">
            The index of the token for which the context is provided.
            </param>
            <param name="tokens">
            The tokens in the sentence.
            </param>
            <param name="tags">
            The tags assigned to the previous words in the sentence.
            </param>
            <returns>
            The context for making a pos tag decision at the specified token index given the specified tokens and previous tags.
            </returns>
        </member>
        <member name="T:OpenNLP.Tools.PosTagger.EnglishMaximumEntropyPosTagger">
            <summary>
            A part of speech tagger that uses a model trained on English data from the
            Wall Street Journal and the Brown corpus.  The latest model created
            achieved >96% accuracy on unseen data.
            </summary>	
        </member>
        <member name="T:OpenNLP.Tools.PosTagger.IPosContextGenerator">
            <summary> 
            The interface for a context generator for the POS Tagger.
            </summary>	
        </member>
        <member name="T:OpenNLP.Tools.PosTagger.IPosTagger">
            <summary> 
            The interface for part of speech taggers.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.PosTagger.IPosTagger.Tag(System.String[])">
            <summary>Assigns the sentence of tokens pos tags</summary>
            <param name="tokens">The sentence of tokens to be tagged</param>
            <returns>An array of pos tags for each token provided in sentence</returns>
        </member>
        <member name="M:OpenNLP.Tools.PosTagger.IPosTagger.TagSentence(System.String)">
            <summary> Assigns pos tags to the sentence of space-delimited tokens</summary>
            <param name="sentence">The sentence of space-delimited tokens to be tagged</param>
            <returns>A collection of tagged words (word + pos tag + index in sentence)</returns>
        </member>
        <member name="T:OpenNLP.Tools.PosTagger.MaximumEntropyPosTagger">
            <summary>
            A part-of-speech tagger that uses maximum entropy.  Trys to predict whether
            words are nouns, verbs, or any of 70 other POS tags depending on their
            surrounding context.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.PosTagger.MaximumEntropyPosTagger.NumTags">
            <summary>
            Returns the number of different tags predicted by this model.
            </summary>
            <returns>
            the number of different tags predicted by this model.
            </returns>
        </member>
        <member name="P:OpenNLP.Tools.PosTagger.MaximumEntropyPosTagger.PosModel">
            <summary>
            The maximum entropy model to use to evaluate contexts.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.PosTagger.MaximumEntropyPosTagger.ContextGenerator">
            <summary>
            The feature context generator.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.PosTagger.MaximumEntropyPosTagger.TagDictionary">
             <summary>
            Tag dictionary used for restricting words to a fixed set of tags.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.PosTagger.MaximumEntropyPosTagger.UseClosedClassTagsFilter">
            <summary>
            Says whether a filter should be used to check whether a tag assignment
            is to a word outside of a closed class.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.PosTagger.MaximumEntropyPosTagger.BeamSize">
            <summary>
            The size of the beam to be used in determining the best sequence of pos tags.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.PosTagger.MaximumEntropyPosTagger.Beam">
            <summary>
            The search object used for search multiple sequences of tags.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.PosTagger.MaximumEntropyPosTagger.AllTags">
            <summary>
            Returns a list of all the possible POS tags predicted by this model.
            </summary>
            <returns>string array of the possible POS tags</returns>
        </member>
        <member name="M:OpenNLP.Tools.PosTagger.MaximumEntropyPosTagger.Tag(System.String[])">
            <summary>
            Associates tags to a collection of tokens.
            This collection of tokens should represent a sentence.
            </summary>
            <param name="tokens">The collection of tokens as strings</param>
            <returns>The collection of tags as strings</returns>
        </member>
        <member name="M:OpenNLP.Tools.PosTagger.MaximumEntropyPosTagger.TagSentence(System.String)">
            <summary>
            Tags words in a given sentence
            </summary>
            <param name="sentence"></param>
            <returns></returns>
        </member>
        <member name="M:OpenNLP.Tools.PosTagger.MaximumEntropyPosTagger.Train(SharpEntropy.ITrainingEventReader,System.Int32,System.Int32)">
            <summary>
            Trains a POS tag maximum entropy model.
            </summary>
            <param name="eventStream">Stream of training events</param>
            <param name="iterations">number of training iterations to perform</param>
            <param name="cut">cutoff value to use for the data indexer</param>
            <returns>Trained GIS model</returns>
        </member>
        <member name="M:OpenNLP.Tools.PosTagger.MaximumEntropyPosTagger.TrainModel(System.String,System.Int32,System.Int32)">
            <summary>
            Trains a POS tag maximum entropy model
            </summary>
            <param name="trainingFile">filepath to the training data</param>
            <param name="iterations">number of training iterations to perform</param>
            <param name="cutoff">Cutoff value to use for the data indexer</param>
            <returns>Trained GIS model</returns>
        </member>
        <member name="T:OpenNLP.Tools.PosTagger.PosEventReader">
            <summary> 
            An event generator for the maxent POS Tagger.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.PosTagger.PosLookupList">
            <summary>
            Provides a means of determining which tags are valid for a particular word based on a tag dictionary read from a file.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.PosTagger.PosLookupList.#ctor(System.String,System.Boolean)">
            <summary>
            Create tag dictionary object with contents of specified file and using specified case to determine how to access entries in the tag dictionary.
            </summary>
            <param name="file">
            The file name for the tag dictionary.
            </param>
            <param name="caseSensitive">
            Specifies whether the tag dictionary is case sensitive or not.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.PosTagger.PosLookupList.#ctor(System.IO.StreamReader,System.Boolean)">
            <summary>
            Create tag dictionary object with contents of specified file and using specified case to determine how to access entries in the tag dictionary.
            </summary>
            <param name="reader">
            A reader for the tag dictionary.
            </param>
            <param name="caseSensitive">
            Specifies whether the tag dictionary is case sensitive or not.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.PosTagger.PosLookupList.GetTags(System.String)">
            <summary>
            Returns a list of valid tags for the specified word. </summary>
            <param name="word">
            The word.
            </param>
            <returns>
            A list of valid tags for the specified word or null if no information is available for that word.
            </returns>
        </member>
        <member name="T:OpenNLP.Tools.PosTagger.PosLookupListWriter">
            <summary>
            Class that helps generate part-of-speech lookup list files.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.PosTagger.PosLookupListWriter.#ctor(System.String)">
            <summary>
            Creates a new part-of-speech lookup list, specifying the location to write it to.
            </summary>
            <param name="file">
            File to write the new list to.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.PosTagger.PosLookupListWriter.AddEntry(System.String,System.String)">
            <summary>
            Adds an entry to the lookup list in memory, ready for writing to file.
            </summary>
            <param name="word">
            The word for which an entry should be added.
            </param>
            <param name="tag">
            The tag that should be marked as valid for this word.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.PosTagger.PosLookupListWriter.Write">
            <summary>
            Write the lookup list entries to file with a default cutoff of 5.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.PosTagger.PosLookupListWriter.Write(System.Int32)">
            <summary>
            Write the lookup list entries to file.
            </summary>
            <param name="cutoff">
            The number of times a word must have been added to the lookup list for it to be considered important
            enough to write to file.
            </param>
        </member>
        <member name="T:OpenNLP.Tools.SentenceDetect.CharactersSpecificEndOfSentenceScanner">
            <summary>
            End of sentence scanner based on a collection of characters,
            ie only a list of specific characters can indicate a potential end of sentence, nothing else.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.SentenceDetect.CharactersSpecificEndOfSentenceScanner.#ctor(System.Char[])">
            <summary>
            Constructor to specify the potential end of sentence characters 
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.SentenceDetect.DefaultEndOfSentenceScanner">
            <summary>
            The default end of sentence scanner implements all of the
            EndOfSentenceScanner methods in terms of the GetPositions(char[])
            method.
            It scans for '.', '?', '!', '"'
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.SentenceDetect.DefaultEndOfSentenceScanner.#ctor">
            <summary> 
            Creates a new <code>DefaultEndOfSentenceScanner</code> instance.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.SentenceDetect.EnglishMaximumEntropySentenceDetector">
            <summary>
            A sentence detector which uses a model trained on English data 
            (Wall Street Journal text).
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.SentenceDetect.EnglishMaximumEntropySentenceDetector.#ctor(System.String)">
            <summary>
            Constructor which loads the English sentence detection model
            transparently.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.SentenceDetect.EnglishMaximumEntropySentenceDetector.#ctor(System.IO.Stream)">
            <summary>
            Constructor which loads the English sentence detection model transparently using a filestream
            </summary>
            <param name="dataInputStream"></param>
        </member>
        <member name="T:OpenNLP.Tools.SentenceDetect.IEndOfSentenceScanner">
            <summary>
            Scans strings, StringBuilders, and char[] arrays for the offsets of
            sentence ending characters.
            
            <p>Implementations of this interface can use regular expressions,
            hand-coded DFAs, and other scanning techniques to locate end of
            sentence offsets.</p>
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.SentenceDetect.IEndOfSentenceScanner.GetPositions(System.String)">
            <summary>
            The receiver scans 'input' for sentence ending characters and
            returns their offsets.
            </summary>
            <param name="input">
            a <code>string</code> value
            </param>
            <returns>
            a <code>List</code> of integers.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.SentenceDetect.IEndOfSentenceScanner.GetPositions(System.Text.StringBuilder)">
            <summary>
            The receiver scans 'buffer' for sentence ending characters and
            returns their offsets.
            </summary>
            <param name="buffer">
            a <code>StringBuilder</code> value
            </param>
            <returns>
            a <code>List</code> of integers.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.SentenceDetect.IEndOfSentenceScanner.GetPositions(System.Char[])">
            <summary>
            The receiver scans 'characterBuffer' for sentence ending characters and
            returns their offsets.
            </summary>
            <param name="characterBuffer">
            a <code>char[]</code> value
            </param>
            <returns>
            a <code>List</code> of integers.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.SentenceDetect.IEndOfSentenceScanner.GetPotentialEndOfSentenceCharacters">
            <summary>
            Gets the characters for which we are testing a potential 
            end of sentence for this scanner.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.SentenceDetect.ISentenceDetector">
            <summary> 
            The interface for sentence detectors, 
            which find the sentence boundaries in a text.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.SentenceDetect.ISentenceDetector.SentenceDetect(System.String)">
            <summary> 
            Sentence detect a string
            </summary>
            <param name="input">
            The string to be sentence detected.
            </param>
            <returns>
            The string[] with the individual sentences as the array
            elements.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.SentenceDetect.ISentenceDetector.SentencePositionDetect(System.String)">
            <summary> 
            Sentence detect a string.
            </summary>
            <param name="input">
            The string to be sentence detected.
            </param>
            <returns>
            An int[] with the starting offset positions of each
            detected sentence. 
            </returns>
        </member>
        <member name="T:OpenNLP.Tools.SentenceDetect.MaximumEntropySentenceDetector">
            <summary>
            A sentence detector for splitting up raw text into sentences.  A maximum
            entropy model is used to evaluate the characters ".", "!", and "?" in a
            string to determine if they signify the end of a sentence.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.SentenceDetect.MaximumEntropySentenceDetector._model">
            <summary>
            The maximum entropy model to use to evaluate contexts.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.SentenceDetect.MaximumEntropySentenceDetector._contextGenerator">
            <summary>
            The feature context generator.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.SentenceDetect.MaximumEntropySentenceDetector._scanner">
            <summary>
            The EndOfSentenceScanner to use when scanning for end of
            sentence offsets.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.SentenceDetect.MaximumEntropySentenceDetector.#ctor(SharpEntropy.IMaximumEntropyModel)">
            <summary>
            Constructor which takes a IMaximumEntropyModel and calls the three-arg
            constructor with that model, a SentenceDetectionContextGenerator, and the
            default end of sentence scanner.
            </summary>
            <param name="model">
            The MaxentModel which this SentenceDetectorME will use to
            evaluate end-of-sentence decisions.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.SentenceDetect.MaximumEntropySentenceDetector.#ctor(SharpEntropy.IMaximumEntropyModel,SharpEntropy.IContextGenerator{System.Tuple{System.Text.StringBuilder,System.Int32}})">
            <summary>
            Constructor which takes a IMaximumEntropyModel and a IContextGenerator.
            calls the three-arg constructor with a default ed of sentence scanner.
            </summary>
            <param name="model">
            The MaxentModel which this SentenceDetectorME will use to
            evaluate end-of-sentence decisions.
            </param>
            <param name="contextGenerator">
            The IContextGenerator object which this MaximumEntropySentenceDetector
            will use to turn strings into contexts for the model to
            evaluate.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.SentenceDetect.MaximumEntropySentenceDetector.#ctor(SharpEntropy.IMaximumEntropyModel,SharpEntropy.IContextGenerator{System.Tuple{System.Text.StringBuilder,System.Int32}},OpenNLP.Tools.SentenceDetect.IEndOfSentenceScanner)">
            <summary> 
            Creates a new <code>MaximumEntropySentenceDetector</code> instance.
            </summary>
            <param name="model">
            The IMaximumEntropyModel which this MaximumEntropySentenceDetector will use to
            evaluate end-of-sentence decisions.
            </param>
            <param name="contextGenerator">The IContextGenerator object which this MaximumEntropySentenceDetector
            will use to turn strings into contexts for the model to
            evaluate.
            </param>
            <param name="scanner">the EndOfSentenceScanner which this MaximumEntropySentenceDetector
            will use to locate end of sentence indexes.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.SentenceDetect.MaximumEntropySentenceDetector.SentenceDetect(System.String)">
            <summary> 
            Detect sentences in a string.
            </summary>
            <param name="input">
            The string to be processed.
            </param>
            <returns>   
            A string array containing individual sentences as elements.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.SentenceDetect.MaximumEntropySentenceDetector.SentencePositionDetect(System.String)">
            <summary> 
            Detect the position of the first words of sentences in a string.
            </summary>
            <param name="input">
            The string to be processed.
            </param>
            <returns>
            A integer array containing the positions of the end index of
            every sentence
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.SentenceDetect.MaximumEntropySentenceDetector.IsAcceptableBreak(System.String,System.Int32,System.Int32)">
            <summary>
            Allows subclasses to check an overzealous (read: poorly
            trained) model from flagging obvious non-breaks as breaks based
            on some boolean determination of a break's acceptability.
            
            <p>The implementation here always returns true, which means
            that the IMaximumEntropyModel's outcome is taken as is.</p>
            </summary>
            <param name="input">
            the string in which the break occured. 
            </param>
            <param name="fromIndex">
            the start of the segment currently being evaluated 
            </param>
            <param name="candidateIndex">
            the index of the candidate sentence ending 
            </param>
            <returns> true if the break is acceptable 
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.SentenceDetect.MaximumEntropySentenceDetector.TrainModel(System.String,System.Int32,System.Int32,OpenNLP.Tools.SentenceDetect.IEndOfSentenceScanner)">
            <summary>
            Use this training method if you wish to supply an end of
            sentence scanner which provides a different set of ending chars
            other than the default ones. They are "\\.|!|\\?|\\\"|\\)".
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.SentenceDetect.MultipleFilesPlainTextByLineDataReader.#ctor(System.Collections.Generic.List{System.IO.StreamReader})">
            <summary>
            Creates a training data reader for reading text lines from a file or other text stream
            </summary>
            <param name="dataReaders">StreamReaders containing the source of the training data</param>
        </member>
        <member name="M:OpenNLP.Tools.SentenceDetect.MultipleFilesPlainTextByLineDataReader.NextToken">
            <summary>Gets the next text line from the training data</summary>
            <returns>Next text line from the training data</returns>
        </member>
        <member name="M:OpenNLP.Tools.SentenceDetect.MultipleFilesPlainTextByLineDataReader.HasNext">
            <summary>Checks if there is any more training data</summary>
            <returns>true if there is more training data to be read</returns>
        </member>
        <member name="T:OpenNLP.Tools.SentenceDetect.SentenceDetectionContextGenerator">
            <summary> 
            Generate event contexts for maxent decisions for sentence detection.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.SentenceDetect.SentenceDetectionContextGenerator.#ctor(System.Char[])">
            <summary>
            Creates a new <code>SentenceDetectionContextGenerator</code> instance with
            no induced abbreviations.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.SentenceDetect.SentenceDetectionContextGenerator.#ctor(OpenNLP.Tools.Util.Set{System.String},System.Char[])">
            <summary> 
            Creates a new <code>SentenceDetectionContextGenerator</code> instance which uses
            the set of induced abbreviations.
            </summary>
            <param name="inducedAbbreviations">
            a <code>Set</code> of strings
            representing induced abbreviations in the training data.
            Example: Mr.
            </param>
            <param name="endOfSentenceCharacters">
            Character array of end of sentence characters.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.SentenceDetect.SentenceDetectionContextGenerator.GetContext(System.Tuple{System.Text.StringBuilder,System.Int32})">
            <summary>
            Builds up the list of features, anchored around a position within the
            StringBuilder. 
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.SentenceDetect.SentenceDetectionContextGenerator.PreviousSpaceIndex(System.Text.StringBuilder,System.Int32)">
            <summary> 
            Finds the index of the nearest space before a specified index.
            </summary>
            <param name="buffer">
            The string buffer which contains the text being examined.
            </param>
            <param name="seek">
            The index to begin searching from.
            </param>
            <returns>
            The index which contains the nearest space.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.SentenceDetect.SentenceDetectionContextGenerator.NextSpaceIndex(System.Text.StringBuilder,System.Int32,System.Int32)">
            <summary>
             Finds the index of the nearest space after a specified index.
            </summary>
            <param name="buffer">
            The string buffer which contains the text being examined.
            </param>
            <param name="seek">
            The index to begin searching from.
            </param>
            <param name="lastIndex">
            The highest index of the StringBuffer sb.
            </param>
            <returns>
            The index which contains the nearest space.
            </returns>
        </member>
        <member name="T:OpenNLP.Tools.SentenceDetect.SentenceDetectionEvent">
            <summary>
            An Event which can hold a pointer to another Event for use in a
            linked list.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.SentenceDetect.SentenceDetectionEvent.#ctor(System.String,System.String[])">
            <summary> 
            package access only
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.SentenceDetect.SentenceDetectionEventReader">
            <summary>
            An implementation of ITrainingEventReader which assumes that it is receiving
            its data as one (valid) sentence per token. 
            The default DataReader to use with this class is PlainTextByLineDataReader, 
            but you can provide other types of ITrainingDataReaders if you wish 
            to receive data from sources other than plain text files; 
            however, be sure that each token your ITrainingDataReader returns is a valid sentence.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.SentenceDetect.SentenceDetectionEventReader.#ctor(SharpEntropy.ITrainingDataReader{System.String})">
            <summary>
            Creates a new <code>SentenceDetectionEventReader</code> instance.
            A DefaultEndOfSentenceScanner is used to locate sentence endings.
            </summary>
            <param name="dataReader">a <code>ITrainingDataReader</code> value
            </param>
        </member>
        <member name="M:OpenNLP.Tools.SentenceDetect.SentenceDetectionEventReader.#ctor(SharpEntropy.ITrainingDataReader{System.String},OpenNLP.Tools.SentenceDetect.IEndOfSentenceScanner)">
            <summary>
            Class constructor which uses the EndOfSentenceScanner to locate
            sentence endings.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.TaggedWord">
            <summary>
            A word tagged by a part of speech tagger
            ex: will/MD | to/TO | etc.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.TaggedWord.#ctor(System.String,System.Int32)">
            <summary>
            Constructor for string of format "will/MD"
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Tokenize.AbstractTokenizer.Tokenize(System.String)">
            <summary>Tokenize a string</summary>
            <param name="input">The string to be tokenized</param>
            <returns>A string array containing individual tokens as elements</returns>
        </member>
        <member name="M:OpenNLP.Tools.Tokenize.AbstractTokenizer.SplitOnWhitespaces(System.String)">
            <summary>
            Constructs a list of Span objects, one for each whitespace delimited token.
            Token strings can be constructed form these spans as follows: input.Substring(span.Start, span.Length());
            </summary>
            <param name="input">string to tokenize</param>
            <returns>Array of spans</returns>
        </member>
        <member name="T:OpenNLP.Tools.Tokenize.Detokenizer">
            <summary>
            An abstract for Detokenizers implementing the Detokenize method
            gluing back together tokens given a collection of DetokenizationOperations.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Tokenize.Detokenizer.GetDetokenizationOperations(System.String[])">
            <summary>
            Computes a collection of detokenization operations given a collection of tokens.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Tokenize.Detokenizer.Detokenize(System.String[],System.String)">
            <summary>
            Plugs back a list of tokens, split from the same sentence with a tokenizer
            </summary>
            <param name="tokens">The collection of tokens</param>
            <param name="splitMarker">A specific marker to insert between tokens</param>
        </member>
        <member name="T:OpenNLP.Tools.Tokenize.EnglishMaximumEntropyTokenizer">
            <summary> 
            A tokenizer which uses default English data for the maximum entropy model.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Tokenize.EnglishRuleBasedTokenizer">
            <summary>
            A tokenizer based on rules intended for English language only
            (rule-based tokenizers are language specific)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Tokenize.EnglishRuleBasedTokenizer.#ctor(System.Boolean)">
            <summary>
            Base constructor for the rule based tokenizer for English language.
            </summary>
            <param name="splitOnHyphen">Wether words with hyphens should be tokenized.</param>
        </member>
        <member name="T:OpenNLP.Tools.Tokenize.IDetokenizer">
            <summary>
            Licensed to the Apache Software Foundation (ASF) under one or more
            contributor license agreements.  See the NOTICE file distributed with
            this work for additional information regarding copyright ownership.
            The ASF licenses this file to You under the Apache License, Version 2.0
            (the "License"); you may not use this file except in compliance with
            the License. You may obtain a copy of the License at
            http://www.apache.org/licenses/LICENSE-2.0
            Unless required by applicable law or agreed to in writing, software
            distributed under the License is distributed on an "AS IS" BASIS,
            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
            See the License for the specific language governing permissions and
            limitations under the License.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Tokenize.IDetokenizer.GetDetokenizationOperations(System.String[])">
            <summary>
            Find the detokenization operations corresponding to the input tokens
            </summary>
            <param name="tokens">the tokens to detokenize</param>
            <returns>the merge operations to detokenize the input tokens</returns>
        </member>
        <member name="M:OpenNLP.Tools.Tokenize.IDetokenizer.Detokenize(System.String[],System.String)">
            <summary>
            Detokenize the input tokens into a string. Tokens which
            are connected without a space inbetween can be separated by
            a split marker.
            </summary>
            <param name="tokens"></param>
            <param name="splitMarker">the split marker or null</param>
            <returns></returns>
        </member>
        <member name="T:OpenNLP.Tools.Tokenize.DetokenizationOperation">
            <summary>
            This enum contains an operation for every token to merge the
            tokens together to their detokenized form.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Tokenize.DetokenizationOperation.MERGE_TO_RIGHT">
            <summary>
            The current token should be attached to the begin token on the right side.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Tokenize.DetokenizationOperation.MERGE_TO_LEFT">
            <summary>
            The current token should be attached to the string on the left side.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Tokenize.DetokenizationOperation.MERGE_BOTH">
            <summary>
            The current token should be attached to the string on the left side, as
            well as to the begin token on the right side.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Tokenize.DetokenizationOperation.MERGE_BOTH_IF_SURROUNDED_BY_WORDS">
            <summary>
            The current token should be attached to the string on the left and the right sides
            only if both are words (with letters)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Tokenize.DetokenizationOperation.RIGHT_LEFT_MATCHING">
            <summary>
            Attaches the token token to the right token on first occurrence, and
            to the token on the left side on the second occurrence.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Tokenize.DetokenizationOperation.NO_OPERATION">
            <summary>
            Do not perform a merge operation for this token, but is possible that another
            token can be attached to the left or right side of this one.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Tokenize.ITokenizer">
            <summary> 
            The interface for tokenizers, which turn messy text into nicely segmented
            text tokens.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Tokenize.ITokenizer.Tokenize(System.String)">
            <summary> 
            Tokenize a string.
            </summary>
            <param name="input">
            The string to be tokenized.
            </param>
            <returns>
            The string[] with the individual tokens as the array
            elements.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Tokenize.ITokenizer.TokenizePositions(System.String)">
            <summary>Tokenize a string</summary>
            <param name="input">The string to be tokenized</param>
            <returns>
            The Span[] with the spans (offsets into input) for each
            token as the individuals array elements.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Tokenize.ITokenizer.RunAgainstTestData(System.Collections.Generic.List{OpenNLP.Tools.Tokenize.TokenizerTestData})">
            <summary>
            Tests the current Tokenizer on a given set of test data.
            The test data is composed of sentences associated to the collection
            of spans delimitating the different tokens.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Tokenize.MaximumEntropyTokenizer">
            <summary>
            A Tokenizer for converting raw text into separated tokens.  It uses
            Maximum Entropy to make its decisions.  The features are loosely
            based on Jeff Reynar's UPenn thesis "Topic Segmentation:
            Algorithms and Applications.", which is available from his
            homepage: http://www.cis.upenn.edu/~jcreynar.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Tokenize.MaximumEntropyTokenizer._model">
            <summary>
            the maximum entropy model to use to evaluate contexts.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Tokenize.MaximumEntropyTokenizer._contextGenerator">
            <summary>
            The context generator.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Tokenize.MaximumEntropyTokenizer.AlphaNumericOptimization">
            <summary>
            Optimization flag to skip alpha numeric tokens for further tokenization.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Tokenize.MaximumEntropyTokenizer.#ctor(SharpEntropy.IMaximumEntropyModel)">
            <summary>
            Class constructor which takes the string locations of the
            information which the maxent model needs.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Tokenize.MaximumEntropyTokenizer.TokenizePositions(System.String)">
            <summary>Tokenizes the string</summary>
            <param name="input">The string to be tokenized</param>
            <returns>A span array containing individual tokens as elements</returns>
        </member>
        <member name="M:OpenNLP.Tools.Tokenize.MaximumEntropyTokenizer.Train(System.String,System.Int32,System.Int32,System.Char,System.Boolean)">
            <summary>
            Trains a tokenizer model from the "events" in the input file
            and write the resulting gis model in the ouput file (as binary)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Tokenize.MaximumEntropyTokenizer.Train(System.Collections.Generic.IEnumerable{System.String},System.Int32,System.Int32,System.Char,System.Boolean)">
            <summary>
            Trains a tokenizer model from input files well formatted for
            a token event reader.
            </summary>
            <param name="inputFilePaths">The collection of training input files</param>
            <param name="iterations">The number of iterations to run when training the model</param>
            <param name="cut">The minimum nb of occurences for statistical relevancy in the trained model</param>
            <param name="splitMarker">The character indicating a split in the files</param>
            <returns>The freshly trained GisModel</returns>
        </member>
        <member name="T:OpenNLP.Tools.Tokenize.MultipleFileTokenEventReader">
            <summary>
            Generate event contexts for maxent decisions for tokenization detection.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Tokenize.TokenContextGenerator">
            <summary>
             Generate events for maxent decisions for tokenization.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Tokenize.TokenContextGenerator.SplitIndicator">
            <summary>
            Split the string
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Tokenize.TokenContextGenerator.NoSplitIndicator">
            <summary>
            Don't split the string
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Tokenize.TokenContextGenerator.GetContext(System.Tuple{System.String,System.Int32})">
            <summary>
            Builds up the list of features based on the information in the object,
            which is a pair containing a string and and integer which
            indicates the index of the position we are investigating.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Tokenize.TokenContextGenerator.AddCharPredicates(System.String,System.Char,System.Collections.Generic.List{System.String})">
            <summary>
            Helper function for GetContext.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Tokenize.TokenEventReader">
            <summary>
            Generate event contexts for maxent decisions for tokenization detection.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Tokenize.TokenizationTestResults">
            <summary>
            Results of a tokenization test.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Tokenize.TokenizationTestResults.NbOfCorrectTokenizations">
            <summary>
            Nb of words correctly tokenized (excluding whitespace tokenization)
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Tokenize.TokenizationTestResults.NbOfIncorrectTokenizations">
            <summary>
            Nb of incorrect tokens (word not tokenized or wrongly tokenized)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Tokenize.TokenizationTestResults.GetAccuracy">
            <summary>
            Computes the ratio of correct tokenization (excluding whitespaces)
            over all tokenizations.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Tokenize.TokenizerTestData">
            <summary>
            Class containing a data set for testing a Tokenizer, 
            ie. a sentence and the collection of spans (representing the tokens) associated.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Tokenize.TokenSpanEventReader">
            <summary>
            An implementation of ITrainingEventReader which allows events to be added by 
            offset and returns events for these offset-based tokens.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.AbstractCollinsHeadFinder">
            <summary>
            A base class for a HeadFinder similar to the one described in
            Michael Collins' 1999 thesis.  For a given constituent we perform operations
            like (this is for "left" or "right":
            <pre>
            for categoryList in categoryLists
              for index = 1 to n [or n to 1 if R->L]
                for category in categoryList
                  if category equals daughter[index] choose it.
            </pre>
            
            with a readonly default that goes with the direction (L->R or R->L)
            For most constituents, there will be only one category in the list,
            the exception being, in Collins' original version, NP.
            
            It is up to the overriding base class to initialize the map
            from constituent type to categoryLists, "nonTerminalInfo",
            in its constructor.
            Entries are presumed to be of type string[][].  Each string[] is a list of
            categories, except for the first entry, which specifies direction of
            traversal and must be one of the following:
            
            <ul>
            <li> "left" means search left-to-right by category and then by position</li>
            <li> "leftdis" means search left-to-right by position and then by category</li>
            <li> "right" means search right-to-left by category and then by position</li>
            <li> "rightdis" means search right-to-left by position and then by category</li>
            <li> "leftexcept" means to take the first thing from the left that isn't in the list</li>
            <li> "rightexcept" means to take the first thing from the right that isn't on the list</li>
            </ul>
            
            Changes:
            <ul>
            <li> 2002/10/28 -- Category label identity checking now uses the
            equals() method instead of ==, so not interning category labels
            shouldn't break things anymore.  (Roger Levy)</li>
            <li> 2003/02/10 -- Changed to use TreebankLanguagePack and to cut on
            characters that set off annotations, so this should work even if
            functional tags are still on nodes.</li>
            <li> 2004/03/30 -- Made abstract base class and subclasses for CollinsHeadFinder,
            ModCollinsHeadFinder, SemanticHeadFinder, ChineseHeadFinder
            (and trees.icegb.ICEGBHeadFinder, trees.international.negra.NegraHeadFinder,
            and movetrees.EnglishPennMaxProjectionHeadFinder)</li>
            <li> 2011/01/13 -- Add support for categoriesToAvoid (which can be set to ensure that
            punctuation is not the head if there are other options)</li>
            </ul>
            
            @author Christopher Manning
            @author Galen Andrew
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.AbstractCollinsHeadFinder.DefaultRule">
            <summary>
            Default direction if no rule is found for category (the head/parent).
            Subclasses can turn it on if they like.
            If they don't it is an error if no rule is defined for a category (null is returned).
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.AbstractCollinsHeadFinder.DefaultLeftRule">
            <summary>
            These are built automatically from categoriesToAvoid and used in a fairly
            different fashion from defaultRule (above).  These are used for categories
            that do have defined rules but where none of them have matched.  Rather
            than picking the rightmost or leftmost child, we will use these to pick
            the the rightmost or leftmost child which isn't in categoriesToAvoid.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.AbstractCollinsHeadFinder.#ctor(OpenNLP.Tools.Trees.AbstractTreebankLanguagePack,System.String[])">
            <summary>
            Construct a HeadFinder.
            The TreebankLanguagePack is used to get basic categories. The remaining arguments
            set categories which, if it comes to last resort processing (i.e., none of
            the rules matched), will be avoided as heads. In last resort processing,
            it will attempt to match the leftmost or rightmost constituent not in this
            set but will fall back to the left or rightmost constituent if necessary.
            </summary>
            <param name="tlp">TreebankLanguagePack used to determine basic category</param>
            <param name="categoriesToAvoid">Constituent types to avoid as head</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.AbstractCollinsHeadFinder.MakesCopulaHead">
            <summary>
            Generally will be false, except for SemanticHeadFinder
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.AbstractCollinsHeadFinder.FindMarkedHead(OpenNLP.Tools.Trees.Tree)">
            <summary>
            A way for subclasses for corpora with explicit head markings
            to return the explicitly marked head
            </summary>
            <param name="t">a tree to find the head of</param>
            <returns>the marked head-- null if no marked head</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.AbstractCollinsHeadFinder.DetermineHead(OpenNLP.Tools.Trees.Tree)">
            <summary>
            Determine which daughter of the current parse tree is the head.
            </summary>
            <param name="t">
            The parse tree to examine the daughters of.
            If this is a leaf, <code>null</code> is returned
            </param>
            <returns>
            The daughter parse tree that is the head of <code>t</code>
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.AbstractCollinsHeadFinder.DetermineHead(OpenNLP.Tools.Trees.Tree,OpenNLP.Tools.Trees.Tree)">
            <summary>
            Determine which daughter of the current parse tree is the head.
            </summary>
            <param name="t">
            The parse tree to examine the daughters of. 
            If this is a leaf, <code>null</code> is returned
            </param>
            <param name="parent">The parent of t</param>
            <returns>
            The daughter parse tree that is the head of <code>t</code>.
            Returns null for leaf nodes.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.AbstractCollinsHeadFinder.DetermineNonTrivialHead(OpenNLP.Tools.Trees.Tree,OpenNLP.Tools.Trees.Tree)">
            <summary>
            Called by determineHead and may be overridden in subclasses
            if special treatment is necessary for particular categories.
            </summary>
            <param name="t">The tre to determine the head daughter of</param>
            <param name="parent">The parent of t (or may be null)</param>
            <returns>The head daughter of t</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.AbstractCollinsHeadFinder.TraverseLocate(OpenNLP.Tools.Trees.Tree[],System.String[],System.Boolean)">
            <summary>
            Attempt to locate head daughter tree from among daughters.
            Go through daughterTrees looking for things from or not in a set given by
            the contents of the array how, and if
            you do not find one, take leftmost or rightmost perhaps matching thing iff
            lastResort is true, otherwise return <code>null</code>.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.AbstractCollinsHeadFinder.PostOperationFix(System.Int32,OpenNLP.Tools.Trees.Tree[])">
            <summary>
            A way for subclasses to fix any heads under special conditions.
            The default does nothing.
            </summary>
            <param name="headIdx">The index of the proposed head</param>
            <param name="daughterTrees">The array of daughter trees</param>
            <returns>The new headIndex</returns>
        </member>
        <member name="T:OpenNLP.Tools.Trees.AbstractTreebankLanguagePack">
            <summary>
            This provides an implementation of parts of the TreebankLanguagePack
            API to reduce the load on fresh implementations.  Only the abstract
            methods below need to be implemented to give a reasonable solution for a new language.
            
            @author Christopher Manning
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.AbstractTreebankLanguagePack.GfCharacter">
            Default character for indicating that something is a grammatical fn; probably should be overridden by
            lang specific ones
        </member>
        <member name="F:OpenNLP.Tools.Trees.AbstractTreebankLanguagePack.DefaultEncoding">
            <summary>
            Use this as the default encoding for Readers and Writers of Treebank data.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.AbstractTreebankLanguagePack.#ctor">
            <summary>
            Gives a handle to the TreebankLanguagePack.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.AbstractTreebankLanguagePack.#ctor(System.Char)">
            <summary>
            Gives a handle to the TreebankLanguagePack
            </summary>
            <param name="gfChar">The character that sets of grammatical functions in node labels</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.AbstractTreebankLanguagePack.PunctuationTags">
            <summary>
            Returns a string array of punctuation tags for this treebank/language.
            </summary>
            <returns>The punctuation tags</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.AbstractTreebankLanguagePack.PunctuationWords">
            <summary>
            Returns a string array of punctuation words for this treebank/language.
            </summary>
            <returns>The punctuation words</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.AbstractTreebankLanguagePack.SentenceFinalPunctuationTags">
            <summary>
            Returns a string array of sentence readonly punctuation tags for this treebank/language.
            </summary>
            <returns>The sentence readonly punctuation tags</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.AbstractTreebankLanguagePack.EvalBIgnoredPunctuationTags">
            <summary>
            Returns a string array of punctuation tags that EVALB-style evaluation
            should ignore for this treebank/language.
            Traditionally, EVALB has ignored a subset of the total set of
            punctuation tags in the English Penn Treebank (quotes and
            period, comma, colon, etc., but not brackets)
            </summary>
            <returns>Whether this is a EVALB-ignored punctuation tag</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.AbstractTreebankLanguagePack.IsPunctuationTag(System.String)">
            <summary>
            Accepts a string that is a punctuation
            tag name, and rejects everything else.
            </summary>
            <returns>Whether this is a punctuation tag</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.AbstractTreebankLanguagePack.IsPunctuationWord(System.String)">
            <summary>
            Accepts a string that is a punctuation
            word, and rejects everything else.
            If one can't tell for sure (as for ' in the Penn Treebank), it
            maks the best guess that it can.
            </summary>
            <returns>Whether this is a punctuation word</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.AbstractTreebankLanguagePack.IsSentenceFinalPunctuationTag(System.String)">
            <summary>
            Accepts a string that is a sentence end
            punctuation tag, and rejects everything else.
            </summary>
            <returns>Whether this is a sentence readonly punctuation tag</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.AbstractTreebankLanguagePack.IsEvalBIgnoredPunctuationTag(System.String)">
            <summary>
            Accepts a string that is a punctuation
            tag that should be ignored by EVALB-style evaluation,
            and rejects everything else.
            Traditionally, EVALB has ignored a subset of the total set of
            punctuation tags in the English Penn Treebank (quotes and
            period, comma, colon, etc., but not brackets)
            </summary>
            <returns>Whether this is a EVALB-ignored punctuation tag</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.AbstractTreebankLanguagePack.PunctuationTagAcceptFilter">
            <summary>
            Return a filter that accepts a string that is a punctuation
            tag name, and rejects everything else.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.AbstractTreebankLanguagePack.PunctuationTagRejectFilter">
            <summary>
            Return a filter that rejects a string that is a punctuation
            tag name, and rejects everything else.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.AbstractTreebankLanguagePack.PunctuationWordAcceptFilter">
            <summary>
            Returns a filter that accepts a string that is a punctuation
            word, and rejects everything else.
            If one can't tell for sure (as for ' in the Penn Treebank), it
            makes the best guess that it can.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.AbstractTreebankLanguagePack.PunctuationWordRejectFilter">
            <summary>
            Returns a filter that accepts a string that is not a punctuation
            word, and rejects punctuation.
            If one can't tell for sure (as for ' in the Penn Treebank), it
            makes the best guess that it can.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.AbstractTreebankLanguagePack.SentenceFinalPunctuationTagAcceptFilter">
            <summary>
            Returns a filter that accepts a string that is a sentence end
            punctuation tag, and rejects everything else.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.AbstractTreebankLanguagePack.EvalBIgnoredPunctuationTagAcceptFilter">
            <summary>
            Returns a filter that accepts a string that is a punctuation
            tag that should be ignored by EVALB-style evaluation,
            and rejects everything else.
            Traditionally, EVALB has ignored a subset of the total set of
            punctuation tags in the English Penn Treebank (quotes and
            period, comma, colon, etc., but not brackets)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.AbstractTreebankLanguagePack.EvalBIgnoredPunctuationTagRejectFilter">
            <summary>
            Returns a filter that accepts everything except a string that is a
            punctuation tag that should be ignored by EVALB-style evaluation.
            Traditionally, EVALB has ignored a subset of the total set of
            punctuation tags in the English Penn Treebank (quotes and
            period, comma, colon, etc., but not brackets)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.AbstractTreebankLanguagePack.GetEncoding">
            <summary>
            Return the input Charset encoding for the Treebank.
            See documentation for the <code>Charset</code> class.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.AbstractTreebankLanguagePack.LabelAnnotationIntroducingCharacters">
            <summary>
            Return an array of characters at which a string should be
            truncated to give the basic syntactic category of a label.
            The idea here is that Penn treebank style labels follow a syntactic
            category with various functional and crossreferencing information
            introduced by special characters (such as "NP-SBJ=1").  This would
            be truncated to "NP" by the array containing '-' and "=".
            </summary>
            <returns>An array of characters that set off label name suffixes</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.AbstractTreebankLanguagePack.PostBasicCategoryIndex(System.String)">
            <summary>
            Returns the index of the first character that is after the basic
            label.  That is, if category is "NP-LGS", it returns 2.
            This routine assumes category != null.
            This routine returns 0 iff the string is of length 0.
            This routine always returns a number &lt;= category.length(), and
            so it is safe to pass it as an argument to category.substring().
            
            NOTE: the routine should never allow the first character of a label
            to be taken as the annotation introducing character, because in the
            Penn Treebank, "-" is a valid tag, but also the character used to
            set off functional and co-indexing annotations. If the first letter is
            such a character then a matched character is also not used, for
            -LRB- etc., iff there is an intervening character (so --PU becomes -).
            </summary>
            <param name="category">Phrasal category</param>
            <returns>The index of the first character that is after the basic label</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.AbstractTreebankLanguagePack.BasicCategory(System.String)">
            <summary>
            Returns the basic syntactic category of a string.
            This implementation basically truncates
            stuff after an occurrence of one of the
            <code>labelAnnotationIntroducingCharacters()</code>.
            However, there is also special case stuff to deal with
            labelAnnotationIntroducingCharacters in category labels:
            (i) if the first char is in this set, it's never truncated
            (e.g., '-' or '=' as a token), and (ii) if it starts with
            one of this set, a second instance of the same item from this set is
            also excluded (to deal with '-LLB-', '-RCB-', etc.).
            </summary>
            <param name="category">The whole string name of the label</param>
            <returns>The basic category of the String</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.AbstractTreebankLanguagePack.GetBasicCategoryFunction">
            <summary>
            Returns a {@link Function Function} object that maps strings to strings according
            to this TreebankLanguagePack's basicCategory() method.
            </summary>
            <returns>The String->String Function object</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.AbstractTreebankLanguagePack.CategoryAndFunction(System.String)">
            <summary>
            Returns the syntactic category and 'function' of a string.
            This normally involves truncating numerical coindexation
            showing coreference, etc.  By 'function', this means
            keeping, say, Penn Treebank functional tags or ICE phrasal functions,
            perhaps returning them as <code>category-function</code>.
            
            This implementation strips numeric tags after label introducing
            characters (assuming that non-numeric things are functional tags).
            </summary>
            <param name="category">The whole string name of the label</param>
            <returns>A string giving the category and function</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.AbstractTreebankLanguagePack.LastIndexOfNumericTag(System.String)">
            <summary>
            Returns the index within this string of the last occurrence of a
            isLabelAnnotationIntroducingCharacter which is followed by only
            digits, corresponding to a numeric tag at the end of the string.
            Example: <code>lastIndexOfNumericTag("NP-TMP-1") returns 6</code>.
            </summary>
            <param name="category">A string category</param>
            <returns>
            The index within this string of the last occurrence of a
            isLabelAnnotationIntroducingCharacter which is followed by only digits
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.AbstractTreebankLanguagePack.GetCategoryAndFunctionFunction">
            <summary>
            Returns a {@link Function Function} object that maps strings to strings according
            to this TreebankLanguagePack's categoryAndFunction() method.
            </summary>
            <returns>The String->String Function object</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.AbstractTreebankLanguagePack.IsLabelAnnotationIntroducingCharacter(System.Char)">
            <summary>
            Say whether this character is an annotation introducing character.
            </summary>
            <param name="ch">The character to check</param>
            <returns>Whether it is an annotation introducing character</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.AbstractTreebankLanguagePack.IsStartSymbol(System.String)">
            <summary>
            Accepts a string that is a start symbol of the treebank.
            </summary>
            <returns>Whether this is a start symbol</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.AbstractTreebankLanguagePack.StartSymbols">
            <summary>
            Returns a string array of treebank start symbols.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.AbstractTreebankLanguagePack.StartSymbol">
            <summary>
            Returns a string which is the first (perhaps unique) start symbol
            of the treebank, or null if none is defined.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.AbstractTreebankLanguagePack.GrammaticalStructureFactory">
            <summary>
            Return a GrammaticalStructureFactory suitable for this language/treebank.
            (To be overridden in subclasses.)
            </summary>
            <returns>A GrammaticalStructureFactory suitable for this language/treebank</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.AbstractTreebankLanguagePack.GrammaticalStructureFactory(System.Predicate{System.String})">
            <summary>
            Return a GrammaticalStructureFactory suitable for this language/treebank.
            (To be overridden in subclasses.)
            </summary>
            <returns>A GrammaticalStructureFactory suitable for this language/treebank</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.AbstractTreebankLanguagePack.GrammaticalStructureFactory(System.Predicate{System.String},OpenNLP.Tools.Trees.IHeadFinder)">
            <summary>
            Return a GrammaticalStructureFactory suitable for this language/treebank.
            (To be overridden in subclasses.)
            </summary>
            <returns>A GrammaticalStructureFactory suitable for this language/treebank</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.AbstractTreebankLanguagePack.MorphFeatureSpec">
            <summary>
            Returns a morphological feature specification for words in this language.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.BobChrisTreeNormalizer">
            <summary>
            Normalizes trees in the way used in Manning and Carpenter 1997.
            NB: This implementation is still incomplete!
            The normalizations performed are: (i) terminals are interned, (ii)
            nonterminals are stripped of alternants, functional tags and
            cross-reference codes, and then interned, (iii) empty
            elements (ones with nonterminal label "-NONE-") are deleted from the
            tree, (iv) the null label at the root node is replaced with the label "ROOT".
            
            17 Apr 2001: This was fixed to work with different kinds of labels,
            by making proper use of the Label interface, after it was moved into
            the trees module.
            
            The normalizations of the original (Prolog) BobChrisNormalize were:
            1. Remap the root node to be called 'ROOT'
            2. Truncate all nonterminal labels before characters introducing
            annotations according to TreebankLanguagePack (traditionally, -, =, | or # (last for BLLIP))
            3. Remap the representation of certain leaf symbols (brackets etc.)
            4. Map to lowercase all leaf nodes
            5. Delete empty/trace nodes (ones marked '-NONE-')
            6. Recursively delete any nodes that do not dominate any words
            7. Delete A over A nodes where the top A dominates nothing else
            8. Remove backslahes from lexical items
            (the Treebank inserts them to escape slashes (/) and stars (*)).
            4 is deliberately omitted, and a few things are purely aesthetic.
            
            14 June 2002: It now deletes unary A over A if both nodes' labels are equal
            (7), and (6) was always part of the Tree.prune() functionality...
            30 June 2005: Also splice out an EDITED node, just in case you're parsing the Brown corpus.
            
            @author Christopher Manning
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.BobChrisTreeNormalizer.NormalizeTerminal(System.String)">
            <summary>
            Normalizes a leaf contents.
            This implementation interns the leaf.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.BobChrisTreeNormalizer.NormalizeNonterminal(System.String)">
            <summary>
            Normalizes a nonterminal contents.
            This implementation strips functional tags, etc. and interns the nonterminal.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.BobChrisTreeNormalizer.CleanUpLabel(System.String)">
            <summary>
            Remove things like hyphened functional tags and equals from the
            end of a node label.  This version always just returns the phrase
            structure category, or "ROOT" if the label was <code>null</code>.
            </summary>
            <param name="label">The label from the treebank</param>
            <returns>The cleaned up label (phrase structure category)</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.BobChrisTreeNormalizer.NormalizeWholeTree(OpenNLP.Tools.Trees.Tree,OpenNLP.Tools.Trees.ITreeFactory)">
            <summary>
            Normalize a whole tree -- one can assume that this is the
            root.  This implementation deletes empty elements (ones with
            nonterminal tag label '-NONE-') from the tree, and splices out
            unary A over A nodes.  It does work for a null tree.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.BobChrisTreeNormalizer.EmptyFilter.Test(OpenNLP.Tools.Trees.Tree)">
            <summary>
            Doesn't accept nodes that only cover an empty.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.BobChrisTreeNormalizer.AOverAFilter.Test(OpenNLP.Tools.Trees.Tree)">
            <summary>
            Doesn't accept nodes that are A over A nodes (perhaps due to
            empty removal or are EDITED nodes).
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.CollinsHeadFinder">
            <summary>
            Implements the HeadFinder found in Michael Collins' 1999 thesis.
            Except: we've added a head rule for NX, which returns the leftmost item.
            No rule for the head of NX is found in any of the versions of
            Collins' head table that we have (did he perhaps use the NP rules
            for NX? -- no Bikel, CL, 2005 says it defaults to leftmost).
            These rules are suitable for the Penn Treebank.
            
            May 2004: Added support for AUX and AUXG to the VP rules; these cause
            no interference in Penn Treebank parsing, but means that these rules
            also work for the BLLIP corpus (or Charniak parser output in general).
            Feb 2005: Fixes to coordination reheading so that punctuation cannot
            become head.
            
            @author Christopher Manning
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.CollinsHeadFinder.#ctor(OpenNLP.Tools.Trees.AbstractTreebankLanguagePack)">
            <summary>
            This constructor provides the traditional behavior, where there is
            no special avoidance of punctuation categories.
            </summary>
            <param name="tlp">TreebankLanguagePack used for basic category function</param>
        </member>
        <member name="T:OpenNLP.Tools.Trees.Constituent">
            <summary>
            A <code>Constituent</code> object defines a generic edge in a graph.
            The <code>Constituent</code> class is designed to be extended.  It
            implements the <code>Comparable</code> interface in order to allow
            graphs to be topologically sorted by the ordinary <code>Collection</code>
            library in <code>java.util</code>, keying primarily on right-hand
            node ID number.  The <code>Constituent</code> class implements most
            of the functionality of the the <code>Label</code>
            interface by passing all requests down to the <code>Label</code> which
            might be contained in the <code>Constituent</code>.  This allows one
            to put a <code>Constituent</code> anywhere that a <code>Label</code> is
            required.  A <code>Constituent</code> is always <code>Scored</code>.
            
            @author Christopher Manning
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Constituent.Start">
            <summary>
            access start node
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Constituent.SetStart(System.Int32)">
            <summary>
            set start node
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Constituent.End">
            <summary>
            access end node
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Constituent.SetEnd(System.Int32)">
            <summary>
             set end node
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Constituent.Label">
            <summary>
            access label
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Constituent.SetLabel(OpenNLP.Tools.Ling.ILabel)">
            <summary>
            Sets the label associated with the current Constituent, if there is one.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Constituent.Labels">
            <summary>
            Access labels -- actually always a singleton here.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Constituent.Score">
            <summary>
            access score
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Constituent.SetScore(System.Double)">
            <summary>
            Sets the score associated with the current node, if there is one
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Constituent.Size">
            <summary>
            Return the length of a <code>Constituent</code>
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Constituent.Equals(System.Object)">
            <summary>
            Compare with another Object for equality.
            Two Constituent objects are equal if they have the same start and end,
            and, if at least one of them has a non-null label, then their labels are equal.
            The score of a Constituent is not considered in the equality test.
            This seems to make sense for most of the applications we have in mind
            where one wants to assess equality independent of score, and then if
            necessary to relax a constituent if one with a better score is found.
            (Note, however, that if you do want to compare Constituent scores for
            equality, then you have to be careful,
            because two <code>double</code> NaN values are considered unequal in Java.)
            
            The general contract of equals() implies that one can't have a
            subclass of a concrete [non-abstract] class redefine equals() to use
            extra aspects, so subclasses shouldn't override this in ways that
            make use of extra fields.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Constituent.GetHashCode">
            <summary>
            A hashCode for Constituents done by shifting and or'ing for speed.
            Now includes the label if the constituent has one (otherwise things
            would work very badly if you were hashing constituents over the
            same span....).
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Constituent.Crosses(OpenNLP.Tools.Trees.Constituent)">
            <summary>
            Detects whether this constituent overlaps a constituent without
            nesting, that is, whether they "cross".
            </summary>
            <param name="c">The constituent to check against</param>
            <returns>True if the two constituents cross</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Constituent.Crosses(System.Collections.Generic.ICollection{OpenNLP.Tools.Trees.Constituent})">
            <summary>
            Detects whether this constituent overlaps any of a Collection of
            Constituents without nesting, that is, whether it "crosses" any of them.
            </summary>
            <param name="constColl">The set of constituent to check against</param>
            <returns>True if some constituent in the collection is crossed</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Constituent.Contains(OpenNLP.Tools.Trees.Constituent)">
            <summary>
            Detects whether this constituent contains a constituent, that is
            whether they are nested.  That is, the other constituent's yield is
            a sublist of this constituent's yield.
            </summary>
            <param name="c">The constituent to check against</param>
            <returns>True if the other Constituent is contained in this one</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Constituent.Value">
            <summary>
            Return the value of the label (or null if none).
            </summary>
            <returns>string the value for the label</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Constituent.SetValue(System.String)">
            <summary>
            Set the value for the label (if one is stored).
            </summary>
            <param name="value">The value for the label</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Constituent.SetFromString(System.String)">
            <summary>
            Make a new label with this <code>string</code> as the "name", perhaps
            by doing some appropriate decoding of the string.
            </summary>
            <param name="labelStr">the string that translates into the content of the label</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Constituent.ToSentenceString(System.Collections.Generic.List{System.String})">
            <summary>
            Print out as a string the subpart of a sentence covered
            by this <code>Constituent</code>.
            </summary>
            <returns>The subpart of the sentence</returns>
        </member>
        <member name="T:OpenNLP.Tools.Trees.CoordinationTransformer">
            <summary>
            Coordination transformer transforms a PennTreebank tree containing
            a coordination in a flat structure in order to get the dependencies right.
            
            The transformer goes through several steps:
            <ul>
            <li> Removes empty nodes and simplifies many tags (<code>DependencyTreeTransformer</code>)</li>
            <li> Relabels UCP phrases to either ADVP or NP depending on their content</li>
            <li> Turn flat CC structures into structures with an intervening node</li>
            <li> Add extra structure to QP phrases - combine "well over", unflattened structures with CC (<code>QPTreeTransformer</code>)</li>
            <li> Flatten SQ structures to get the verb as the head</li>
            <li> Rearrange structures that appear to be dates</li>
            <li> Flatten X over only X structures</li>
            <li> Turn some fixed conjunction phrases into CONJP, such as "and yet", etc</li>
            <li> Attach RB such as "not" to the next phrase to get the RB headed by the phrase it modifies</li>
            <li> Turn SBAR to PP if parsed as SBAR in phrases such as "The day after the airline was planning ..."</li>
            <li> Rearrange "now that" into an SBAR phrase if it was misparsed as ADVP</li>
            </ul>
            
            @author Marie-Catherine de Marneffe
            @author John Bauer
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.CoordinationTransformer.tn">
            <summary>to get rid of unwanted nodes and tag</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.CoordinationTransformer.qp">
            <summary>to restructure the QP constituents</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.CoordinationTransformer.dates">
            <summary>to flatten date patterns</summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.CoordinationTransformer.#ctor(OpenNLP.Tools.Trees.IHeadFinder)">
            <summary>
            default constructor
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.CoordinationTransformer.TransformTree(OpenNLP.Tools.Trees.Tree)">
            <summary>
            Transforms t if it contains a coordination in a flat structure (CCtransform)
            and transforms UCP (UCPtransform).
            </summary>
            <param name="t">a tree to be transformed</param>
            <returns>t transformed</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.CoordinationTransformer.ChangeSbarToPp(OpenNLP.Tools.Trees.Tree)">
            <summary>
            For certain phrases, we change the SBAR to a PP to get prep/pcomp
            dependencies.  For example, in "The day after the airline was
            planning...", we want prep(day, after) and pcomp(after,
            planning).  If "after the airline was planning" was parsed as an
            SBAR, either by the parser or in the treebank, we fix that here.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.CoordinationTransformer.SqFlatten(OpenNLP.Tools.Trees.Tree)">
            <summary>
            Removes the SQ structure under a WHNP question, such as "Who am I
            to judge?".  We do this so that it is easier to pick out the head
            and then easier to connect that head to all of the other words in
            the question in this situation.  In the specific case of making
            the copula head, we don't do this so that the existing headfinder
            code can easily find the "am" or other copula verb.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.CoordinationTransformer.UcpRenameTregex">
            <summary>
            UCP (JJ ...) -> ADJP
            UCP (DT JJ ...) -> ADJP
            UCP (... (ADJP (JJR older|younger))) -> ADJP
            UCP (N ...) -> NP
            UCP ADVP -> ADVP
            Might want to look for ways to include RB for flatter structures,
            but then we have to watch out for (RB not) for example
            Note that the order of OR expressions means the older|younger
            pattern takes precedence
            By searching for everything at once, then using one tsurgeon
            which fixes everything at once, we can save quite a bit of time
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.CoordinationTransformer.UcpTransform(OpenNLP.Tools.Trees.Tree)">
            <summary>
            Transforms t if it contains an UCP, it will change the UCP tag
            into the phrasal tag of the first word of the UCP
            (UCP (JJ electronic) (, ,) (NN computer) (CC and) (NN building))
            will become
            (ADJP (JJ electronic) (, ,) (NN computer) (CC and) (NN building))
            </summary>
            <param name="t">a tree to be transformed</param>
            <returns>t transformed</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.CoordinationTransformer.CcTransform(OpenNLP.Tools.Trees.Tree)">
            <summary>
            Transforms t if it contains a coordination in a flat structure
            </summary>
            <param name="t">a tree to be transformed</param>
            <returns>transformed (give t not null, return will not be null)</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.CoordinationTransformer.TransformCc(OpenNLP.Tools.Trees.Tree,System.Int32)">
            <summary>
            If things match, this method destructively changes the children list
            of the tree t.  When this method is called, t is an NP and there must
            be at least two children to the right of ccIndex.
            </summary>
            <param name="t">The tree to transform a conjunction in</param>
            <param name="ccIndex">The index of the CC child</param>
            <returns>t</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.CoordinationTransformer.FindCcParent(OpenNLP.Tools.Trees.Tree,OpenNLP.Tools.Trees.Tree)">
            <summary>
            Given a tree t, if this tree contains a CC inside a NP followed by 2 nodes
            (i.e. we have a flat structure that will not work for the dependencies),
            it will call transform CC on the NP containing the CC and the index of the
            CC, and then return the root of the whole transformed tree.
            If it finds no such tree, this method returns null.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.ICopulaHeadFinder">
            <summary>
            A mix-in interface for HeadFinders which support the
            makesCopulaHead method, which says how the HeadFinder in question handles "to be" verbs.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.DateTreeTransformer">
            <summary>
            Flattens the following two structures:
            (NP (NP (NNP Month) (CD Day) )(, ,)(NP (CD Year) ))
            becomes
            (NP (NNP Month) (CD Day) (, ,) (CD Year) )
            (NP (NP (NNP Month) )(NP (CD Year) ))
            becomes
            (NP (NNP Month) (CD Year))
            
            @author John Bauer
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.IDependency`3">
            <summary>
            An individual dependency between a governor and a dependent.
            The governor and dependent are represented as a Label.
            For example, these can be a Word or a WordTag.
            If one wishes the dependencies to preserve positions in a sentence, 
            then each can be a LabeledConstituent or CoreLabel.
            Dependencies support an Object naming the dependency type. This may be null. 
            Dependencies have factories.
            
            @author Christopher Manning
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.IDependency`3.Governor">
            <summary>
            Describes the governor (regent/head) of the dependency relation
            </summary>
            <returns>The governor of this dependency</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.IDependency`3.Dependent">
            <summary>
            Describes the dependent (argument/modifier) of the dependency relation
            </summary>
            <returns>the dependent of this dependency</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.IDependency`3.Name">
            <summary>
            Names the type of dependency (subject, instrument, ...).
            This might be a string in the simplest case, but can provide for arbitrary object types.
            </summary>
            <returns>the name for this dependency type</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.IDependency`3.EqualsIgnoreName(System.Object)">
            <summary>
            Are two dependencies equal if you ignore the dependency name.
            </summary>
            <param name="o">The thing to compare against ignoring name</param>
            <returns>true iff the head and dependent are the same</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.IDependency`3.ToString(System.String)">
            <summary>
            Provide different printing options via a string keyword.
            The main recognized option currently is "xml".  Otherwise the
            default ToString() is used.
            </summary>
            <param name="format">A format string, either "xml" or you get the default</param>
            <returns>A string representation of the dependency</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.IDependency`3.DependencyFactory">
            <summary>
            Provide a factory for this kind of dependency
            </summary>
            <returns>A DependencyFactory</returns>
        </member>
        <member name="T:OpenNLP.Tools.Trees.IDependencyFactory">
            <summary>
            A factory for dependencies of a certain type.
            
            @author Christopher Manning
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.DependencyTreeTransformer">
            <summary>
            Transforms an English structure parse tree in order to get the dependencies right:
            -- put a ROOT node
            -- remove NONE nodes
            -- retain only NP-TMP, NP-ADV, UCP-TMP tags
            The UCP- tags will later be turned into NP- anyway
            
            (Note [cdm]: A lot of this overlaps other existing functionality in trees. Could aim to unify it.)
            
            @author mcdm
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.EnglishGrammaticalRelations">
             <summary>
             <code>EnglishGrammaticalRelations</code> is a
             set of {@link GrammaticalRelation} objects for the English language.
             These relations are commonly called Stanford Dependencies (SD).
             
             Grammatical relations can either be shown in their basic form, where each
             input token receives a relation, or "collapsed" which does certain normalizations
             which group words or turns them into relations. See
             {@link EnglishGrammaticalStructure}.  What is presented here mainly
             shows the basic form, though there is some mixture. The "collapsed" grammatical
             relations primarily differ as follows:
             <ul>
             <li>Some multiword conjunctions and prepositions are treated as single
             words, and then processed as below.</li>
             <li>Prepositions do not appear as words but are turned into new "prep" or "prepc"
             grammatical relations, one for each preposition.</li>
             <li>Conjunctions do not appear as words but are turned into new "conj"
             grammatical relations, one for each conjunction.</li>
             <li>The possessive "'s" is deleted, leaving just the relation between the
             possessor and possessum.</li>
             <li>Agents of passive sentences are recognized and marked as agent and not as prep_by.</li>
             </ul>
             
             This set of English grammatical relations is not intended to be
             exhaustive or immutable.  It's just where we're at now.
             
             See {@link GrammaticalRelation} for details of fields and matching.
             
             If using LexicalizedParser, it should be run with the
             <code>-retainTmpSubcategories</code> option and one of the
             <code>-splitTMP</code> options (e.g., <code>-splitTMP 1</code>) in order to
             get the temporal NP dependencies maximally right!
             
             <i>Implementation notes: </i> Don't change the set of GRs without discussing it
             with people first.  If a change is needed, to add a new grammatical relation:
             <ul>
             <li> Governor nodes of the grammatical relations should be the lowest ones.</li>
             <li> Check the semantic head rules in SemanticHeadFinder and ModCollinsHeadFinder, 
             both in the trees package. That's what will be used to match here.</li>
             <li> Create and define the GrammaticalRelation similarly to the others.</li>
             <li> Add it to the <code>values</code> array at the end of the file.</li>
             </ul>
             The patterns in this code assume that an NP may be followed by either a
             -ADV or -TMP functional tag but there are no other functional tags represented.
             This corresponds to what we currently get from NPTmpRetainingTreeNormalizer or
             DependencyTreeTransformer.
            
             @author Bill MacCartney
             @author Marie-Catherine de Marneffe
             @author Christopher Manning
             @author Galen Andrew (refactoring English-specific stuff)
             
             @see GrammaticalStructure
             @see GrammaticalRelation
             @see EnglishGrammaticalStructure
             
             Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
             </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.TregexCompiler">
            <summary>
            By setting the HeadFinder to null, we find out right away at runtime 
            if we have incorrectly set the HeadFinder for the dependency tregexes
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.Predicate">
            <summary>
            The "predicate" grammatical relation.  The predicate of a
            clause is the main VP of that clause; the predicate of a
            subject is the predicate of the clause to which the subject belongs.
            
            Example:
            "Reagan died" -> <code>pred</code>(Reagan, died)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.AuxModifier">
            <summary>
            The "auxiliary" grammatical relation.  An auxiliary of a clause is a
            non-main verb of the clause.
            
            Example:
            "Reagan has died" -> <code>aux</code>(died, has)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.AuxPassiveModifier">
            <summary>
            The "passive auxiliary" grammatical relation. A passive auxiliary of a
            clause is a non-main verb of the clause which contains the passive information.
            
            Example:
            "Kennedy has been killed" -> <code>auxpass</code>(killed, been)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.Copula">
            <summary>
            The "copula" grammatical relation.  A copula is the relation between
            the complement of a copular verb and the copular verb.
            
            Examples:
            "Bill is big" -> <code>cop</code>(big, is)
            "Bill is an honest man" -> <code>cop</code>(man, is)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.Conjunct">
            <summary>
            The "conjunct" grammatical relation.  A conjunct is the relation between
            two elements connected by a conjunction word.  We treat conjunctions
            asymmetrically: The head of the relation is the first conjunct and other
            conjunctions depend on it via the <i>conj</i> relation.
            
            Example:
            "Bill is big and honest" -> <code>conj</code>(big, honest)
            
            Note: Modified in 2010 to exclude the case of a CC/CONJP first in its phrase: it has to conjoin things.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.Coordination">
            <summary>
            The "coordination" grammatical relation.  A coordination is the relation
            between an element and a conjunction.
            
            Example:
            "Bill is big and honest." -> <code>cc</code>(big, and)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.Punctuation">
            <summary>
            The "punctuation" grammatical relation.  This is used for any piece of
            punctuation in a clause, if punctuation is being retained in the typed dependencies.
            
            Example:
            "Go home!" -> <code>punct</code>(Go, !)
            
            The condition for NFP to appear hear is that it does not match the emoticon patterns under discourse.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.Argument">
            <summary>
            The "argument" grammatical relation.  An argument of a VP is a
            subject or complement of that VP; an argument of a clause is
            an argument of the VP which is the predicate of that clause.
            
            Example:
            "Clinton defeated Dole" -> <code>arg</code>(defeated, Clinton), <code>arg</code>(defeated, Dole)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.Subject">
            <summary>
            The "subject" grammatical relation.  The subject of a VP is
            the noun or clause that performs or experiences the VP; the
            subject of a clause is the subject of the VP which is the
            predicate of that clause.
            
            Examples:
            "Clinton defeated Dole" -> <code>subj</code>(defeated, Clinton)
            "What she said is untrue" -> <code>subj</code>(is, What she said)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.NominalSubject">
            <summary>
            The "nominal subject" grammatical relation.  A nominal subject is
            a subject which is an noun phrase.
            
            Example:
            "Clinton defeated Dole" -> <code>nsubj</code>(defeated, Clinton)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.NominalPassiveSubject">
            <summary>
            The "nominal passive subject" grammatical relation.  A nominal passive
            subject is a subject of a passive which is an noun phrase.
            
            Example:
            "Dole was defeated by Clinton" -> <code>nsubjpass</code>(defeated, Dole)
            
            This pattern recognizes basic (non-coordinated) examples.  The coordinated
            examples are currently handled by correctDependencies() in
            EnglishGrammaticalStructure.  This seemed more accurate than any tregex
            expression we could come up with.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.ClausalSubject">
            <summary>
            The "clausal subject" grammatical relation.  A clausal subject is
            a subject which is a clause.
            
            Examples: (subject is "what she said" in both examples)
            "What she said makes sense" -> <code>csubj</code>(makes, said)
            "What she said is untrue" -> <code>csubj</code>(untrue, said)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.ClausalPassiveSubject">
            <summary>
            The "clausal passive subject" grammatical relation.  A clausal passive subject 
            is a subject of a passive verb which is a clause.
            
            Example: (subject is "that she lied")
            "That she lied was suspected by everyone" -> <code>csubjpass</code>(suspected, lied)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.Complement">
            <summary>
            The "complement" grammatical relation.  A complement of a VP
            is any object (direct or indirect) of that VP, or a clause or
            adjectival phrase which functions like an object; a complement
            of a clause is an complement of the VP which is the predicate
            of that clause.
            
            Examples:
            "She gave me a raise" -> <code>comp</code>(gave, me), <code>comp</code>(gave, a raise)
            "I like to swim" -> <code>comp</code>(like, to swim)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.Object">
            <summary>
            The "object" grammatical relation.  An object of a VP
            is any direct object or indirect object of that VP; an object
            of a clause is an object of the VP which is the predicate
            of that clause.
            
            Examples:
            "She gave me a raise" -> <code>obj</code>(gave, me), <code>obj</code>(gave, raise)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.DirectObject">
            <summary>
            The "direct object" grammatical relation.  The direct object
            of a verb is the noun phrase which is the (accusative) object of
            the verb; the direct object of a clause or VP is the direct object of
            the head predicate of that clause.
            
            Example:
            "She gave me a raise" -> <code>dobj</code>(gave, raise)
            Note that dobj can also be assigned by the conversion of rel in the postprocessing.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.IndirectObject">
            <summary>
            The "indirect object" grammatical relation.  The indirect
            object of a VP is the noun phrase which is the (dative) object
            of the verb; the indirect object of a clause is the indirect
            object of the VP which is the predicate of that clause.
            
            Example:
            "She gave me a raise" -> <code>iobj</code>(gave, me)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.PrepositionalObject">
            <summary>
            The "prepositional object" grammatical relation.  The object of a
            preposition is the head of a noun phrase following the preposition, or
            the adverbs "here" and "there".
            (The preposition in turn may be modifying a noun, verb, etc.)
            We here define cases of VBG quasi-prepositions like "including",
            "concerning", etc. as instances of pobj (unlike the Penn Treebank).
            
            Example:
            "I sat on the chair" -> <code>pobj</code>(on, chair)
            
            (The preposition can be called a FW for pace, versus, etc.  It can also
            be called a CC - but we don't currently handle that and would need to
            distinguish from conjoined PPs. Jan 2010 update: We now insist that the
            NP must follow the preposition. This prevents a preceding NP measure
            phrase being matched as a pobj.  We do allow a preposition tagged RB
            followed by an NP pobj, as happens in the Penn Treebank for adverbial uses
            of PP like "up 19%")
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.PrepositionalComplement">
            <summary>
            The "prepositional complement" grammatical relation.
            This is used when the complement of a preposition is a clause or
            an adverbial or prepositional phrase.
            The prepositional complement of
            a preposition is the head of the sentence following the preposition,
            or the preposition head of the PP.
            
            Examples:
            "We have no useful information on whether users are at risk" -> <code>pcomp</code>(on, are)
            "They heard about you missing classes." -> <code>pcomp</code>(about, missing)
            It is warmer in Greece than in Italy -> <code>pcomp</code>(than, in)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.ClausalComplement">
            <summary>
            The "clausal complement" grammatical relation.  A clausal complement of
            a verb or adjective is a dependent clause with an internal subject which
            functions like an object of the verb, or adjective.  Clausal complements
            for nouns are limited to complement clauses with a subset of nouns
            like "fact" or "report".  We analyze them the same (parallel to the
            analysis of this class as "content clauses" in Huddleston and Pullum 2002).
            Clausal complements are usually finite (though there
            are occasional exceptions including remnant English subjunctives, and we
            also classify the complement of causative "have" (She had him arrested)
            in this category.
            
            Example:
            "He says that you like to swim" -> <code>ccomp</code>(says, like)
            "I am certain that he did it" -> <code>ccomp</code>(certain, did)
            "I admire the fact that you are honest" -> <code>ccomp</code>(fact, honest)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.XclausalComplement">
            <summary>
            An open clausal complement (<i>xcomp</i>) of a VP or an ADJP is a clausal
            complement without its own subject, whose reference is determined by an
            external subject.  These complements are always non-finite.
            The name <i>xcomp</i> is borrowed from Lexical-Functional Grammar.
            (Mainly "TO-clause" are recognized, but also some VBG like "stop eating")
            
            Examples:
            "I like to swim" -> <code>xcomp</code>(like, swim)
            "I am ready to leave" -> <code>xcomp</code>(ready, leave)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.Relative">
            <summary>
            The RELATIVE grammatical relation is only here as a temporary
            relation.  This tregex triggering indicates either a dobj or a
            pobj should be here.  We figure this out in a post-processing
            step by looking at the surrounding dependencies.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.Referent">
            <summary>
            The "referent" grammatical relation.
            A referent of the Wh-word of a NP is  the relative word introducing the relative clause modifying the NP.
            
            Example:
            "I saw the book which you bought" -> <code>ref</code>(book, which)
            "I saw the book the cover of which you designed" -> <code>ref</code>(book, which)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.Expletive">
            <summary>
            The "expletive" grammatical relation.
            This relation captures an existential there.
            
            Example:
            "There is a statue in the corner" -> <code>expl</code>(is, there)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.AdjectivalComplement">
            <summary>
            The "adjectival complement" grammatical relation.  An
            adjectival complement of a VP is an adjectival phrase which
            functions as the complement (like an object of the verb); an adjectival
            complement of a clause is the adjectival complement of the VP which is
            the predicate of that clause.
            
            Example:
            "She looks very beautiful" -> <code>acomp</code>(looks, beautiful)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.Modifier">
            <summary>
            The "modifier" grammatical relation.  A modifier of a VP is
            any constituent that serves to modify the meaning of the VP
            (but is not an <code>ARGUMENT</code> of that
            VP); a modifier of a clause is an modifier of the VP which is
            the predicate of that clause.
            
            Examples:
            "Last night, I swam in the pool" -> <code>mod</code>(swam, in the pool), <code>mod</code>(swam, last night)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.AdvClauseModifier">
            <summary>
            The "adverbial clause modifier" grammatical relation.  An adverbial clause
            modifier of some predicates, such as a VP or (inverted) sentence is a clause modifying the verb
            (temporal clauses, consequences, conditional clauses, etc.).
            
            Examples:
            "The accident happened as the night was falling" -> <code>advcl</code>(happened, falling)
            "If you know who did it, you should tell the teacher" -> <code>advcl</code>(tell, know)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.RelativeClauseModifier">
            <summary>
            The "relative clause modifier" grammatical relation.  A relative clause
            modifier of an NP is a relative clause modifying the NP.  The link
            points from the head noun of the NP to the head of the relative clause,
            normally a verb.
            
            Examples:
            "I saw the man you love" -> <code>rcmod</code>(man, love)
            "I saw the book which you bought" -> <code>rcmod</code>(book, bought)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.Marker">
            <summary>
            The "marker" grammatical relation.  A marker is the word introducing a finite clause subordinate to another clause.
            For a complement clause, this will typically be "that" or "whether".
            For an adverbial clause, the marker is typically a preposition like "while" or "although".
            
            Example:
            "U.S. forces have been engaged in intense fighting after insurgents launched simultaneous attacks" ->
            <code>mark</code>(launched, after)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.AdjectivalModifier">
            <summary>
            The "adjectival modifier" grammatical relation.  An adjectival
            modifier of an NP is any adjectival phrase that serves to modify
            the meaning of the NP.
            
            Example:
            "Sam eats red meat" -> <code>amod</code>(meat, red)
            The relation amod is also used for multiword country adjectives, despite their
            questionable treebank representation.
            
            Example:
            "the West German economy" -> <code>amod</code>(German, West),
            <code>amod</code>(economy, German)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.NumericModifier">
            <summary>
            The "numeric modifier" grammatical relation.  A numeric
            modifier of an NP is any number phrase that serves to modify
            the meaning of the NP.
            
            Example:
            "Sam eats 3 sheep" -> <code>num</code>(sheep, 3)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.NumberModifier">
            <summary>
            The "compound number modifier" grammatical relation.  A compound number
            modifier is a part of a number phrase or currency amount.
            
            Example:
            "I lost $ 3.2 billion" -> <code>number</code>($, billion)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.QuantifierModifier">
            <summary>
            The "quantifier phrase modifier" grammatical relation.  A quantifier
            modifier is an element modifying the head of a QP constituent.
            
            Example:
            "About 200 people came to the party" -> <code>quantmod</code>(200, About)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.NounCompoundModifier">
            <summary>
            The "noun compound modifier" grammatical relation.  A noun compound
            modifier of an NP is any noun that serves to modify the head noun.
            Note that this has all nouns modify the rightmost a la Penn headship
            rules.  There is no intelligent noun compound analysis.
            
            We eliminate nouns that are detected as part of a POS, since that
            will turn into the dependencies denoting possession instead.
            Note we have to include (VBZ &lt; /^\'s$/) as part of the POS
            elimination, since quite a lot of text such as
            "yesterday's widely published sequester" was misannotated as a
            VBZ instead of a POS.  
            TODO: remove that if a revised PTB is ever released.
            
            Example:
            "Oil price futures" -> <code>nn</code>(futures, oil), <code>nn</code>(futures, price)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.AppositionalModifier">
            <summary>
            The "appositional modifier" grammatical relation.  An appositional
            modifier of an NP is an NP that serves to modify
            the meaning of the NP.  It includes parenthesized examples, as well as defining abbreviations.
            
            Examples:
            "Sam, my brother, eats red meat" -> <code>appos</code>(Sam, brother)
            "Bill (John's cousin)" -> <code>appos</code>(Bill, cousin).
            "The Australian Broadcasting Corporation (ABC)" -> <code>appos</code>(Corporation, ABC)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.DiscourseElement">
            <summary>
            The "discourse element" grammatical relation. This is used for interjections and
            other discourse particles and elements (which are not clearly linked to the structure
            of the sentence, except in an expressive way). We generally follow the
            guidelines of what the Penn Treebanks count as an INTJ.  They
            define this to include: interjections (oh, uh-huh, Welcome), fillers (um, ah),
            and discourse markers (well, like, actually, but not: you know).
            We also use it for emoticons.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.VerbalModifier">
            <summary>
            The "verb modifier" grammatical relation.  A verb
            modifier of an NP, VP, or S is a S/VP[part] that serves to modify
            the meaning of the NP or VP.
            
            Examples:
            "truffles picked during the spring are tasty" -> <code>vmod</code>(truffles, picked)
            "Bill picked Fred for the team demonstrating his incompetence" -> <code>vmod</code>(picked, demonstrating)
            "points to establish are ..." -> <code>vmod</code>(points, establish)
            "who am i to judge" -> <code>vmod</code>(who, judge)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.AdverbialModifier">
            <summary>
            The "adverbial modifier" grammatical relation.  An adverbial
            modifier of a word is a (non-clausal) RB or ADVP that serves to modify
            the meaning of the word.
            
            Examples:
            "genetically modified food" -> <code>advmod</code>(modified, genetically)
            "less often" -> <code>advmod</code>(often, less)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.NegationModifier">
            <summary>
            The "negation modifier" grammatical relation.  The negation modifier
            is the relation between a negation word and the word it modifies.
            
            Examples:
            "Bill is not a scientist" -> <code>neg</code>(scientist, not)
            "Bill doesn't drive" -> <code>neg</code>(drive, n't)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.NpAdverbialModifier">
            <summary>
            The "noun phrase as adverbial modifier" grammatical relation.
            This relation captures various places where something syntactically a noun
            phrase is used as an adverbial modifier in a sentence.  These usages include:
            <ul>
            <li> A measure phrase, which is the relation between
            the head of an ADJP/ADVP and the head of a measure-phrase modifying the ADJP/ADVP.
            
            Example:
            "The director is 65 years old" -> <code>npadvmod</code>(old, years)
            </li>
            <li> Noun phrases giving extent inside a VP which are not objects
            
            Example:
            "Shares eased a fraction" -> <code>npadvmod</code>(eased, fraction)
            </li>
            <li> Financial constructions involving an adverbial or PP-like NP, notably
            the following construction where the NP means "per share"
            
            Example:
            "IBM earned $ 5 a share" -> <code>npadvmod</code>($, share)
            </li>
            <li>Reflexives
            
            Example:
            "The silence is itself significant" -> <code>npadvmod</code>(significant, itself)
            </li>
            <li>Certain other absolutive NP constructions.
            
            Example:
            "90% of Australians like him, the most of any country" ->
            <code>npadvmod</code>(like, most)
            </li>
            </ul>
            A temporal modifier (tmod) is a subclass of npadvmod which is distinguished
            as a separate relation.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.TemporalModifier">
            <summary>
            The "temporal modifier" grammatical relation.  A temporal
            modifier of a VP or an ADJP is any constituent that serves to modify the
            meaning of the VP or the ADJP by specifying a time; a temporal modifier of a
            clause is an temporal modifier of the VP which is the
            predicate of that clause.
            
            Example:
            "Last night, I swam in the pool" -> {@code tmod}(swam, night)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.MultiWordExpression">
            <summary>
            The "multi-word expression" grammatical relation.
            This covers various multi-word constructions for which it would
            seem pointless or arbitrary to claim grammatical relations between words:
            as well as, rather than, instead of, but also;
            such as, because of, all but, in addition to ....
            
            Examples:
            "dogs as well as cats" -> <code>mwe</code>(well, as) <code>mwe</code>(well, as)
            "fewer than 700 bottles" -> <code>mwe</code>(than, fewer)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.Determiner">
            <summary>
            The "determiner" grammatical relation.
            Examples:
            "The man is here" -> <code>det</code>(man,the)
            "Which man do you prefer?" -> <code>det</code>(man,which)
            (The ADVP match is because sometimes "a little" or "every time" is tagged
            as an AVDVP with POS tags straight under it.)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.Predeterminer">
            <summary>
            The "predeterminer" grammatical relation.
            Example: "All the boys are here" -> <code>predet</code>(boys,all)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.Preconjunct">
            <summary>
            The "preconjunct" grammatical relation.
            
            Example: "Both the boys and the girls are here" -> <code>preconj</code>(boys,both)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.PossessionModifier">
            <summary>
            The "possession" grammatical relation between the possessum and the possessor.
            
            Examples:
            "their offices" -> {@code poss}(offices, their)
            "Bill 's clothes" -> {@code poss}(clothes, Bill)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.PossessiveModifier">
            <summary>
            The "possessive" grammatical relation.  This is the relation given to
            's (or ' with plurals).
            
            Example: "John's book" -> <code>possessive</code>(John, 's)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.PrepositionalModifier">
            <summary>
            The "prepositional modifier" grammatical relation.  A prepositional
            modifier of a verb, adjective, or noun is any prepositional phrase that serves to modify
            the meaning of the verb, adjective, or noun.
            We also generate prep modifiers of PPs to account for treebank (PP PP PP) constructions
            (from 1984 through 2002).
            
            Examples:
            "I saw a cat in a hat" -> <code>prep</code>(cat, in)
            "I saw a cat with a telescope" -> <code>prep</code>(saw, with)
            "He is responsible for meals" -> <code>prep</code>(responsible, for)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.PhrasalVerbParticle">
            <summary>
            The "phrasal verb particle" grammatical relation.  The "phrasal verb particle"
            relation identifies phrasal verb.
            
            Example:
            "They shut down the station." -> <code>prt</code>(shut, down)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.Parataxis">
            <summary>
            The "parataxis" grammatical relation. Relation between the main verb of a sentence
            and other sentential elements, such as a sentential parenthetical, a sentence after a ":" or a ";", when two
            sentences are juxtaposed next to each other without any coordinator or subordinator, etc.
            
            Examples:
            "The guy, John said, left early in the morning." -> <code>parataxis</code>(left,said)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.GoesWith">
            <summary>
            The "goes with" grammatical relation.  This corresponds to use of the GW (goes with) part-of-speech tag
            in the recent Penn Treebanks. It marks partial words that should be combined with some other word.
            
            Example:
            "They come here with out legal permission." ->
            <code>goeswith</code>(out, with)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.SemanticDependent">
            <summary>
            The "semantic dependent" grammatical relation has been
            introduced as a supertype for the controlling subject relation.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.Agent">
            <summary>
            The "agent" grammatical relation. The agent of a passive VP
            is the complement introduced by "by" and doing the action.
            
            Example:
            "The man has been killed by the police" ->
            <code>agent</code>(killed, police)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.values">
            <summary>
            A list of GrammaticalRelation values.  New GrammaticalRelations must be
            added to this list (until we make this an enum!).
            The GR recognizers are tried in the order listed.  A taxonomic
            relationship trumps an ordering relationship, but otherwise, the first
            listed relation will appear in dependency output.  Known ordering
            constraints where both match include:
            <ul>
            <li>NUMERIC_MODIFIER &lt; ADJECTIVAL_MODIFIER</li>
            </ul>
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.ShortNameToGRel">
            <summary>
            Map from English GrammaticalRelation short names to their corresponding GrammaticalRelation objects
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.Conjs">
            This method is meant to be called when you want to add a relation
            to the values list in a thread-safe manner.  Currently, this method
            is always used in preference to values.add() because we expect to
            add new EnglishGrammaticalRelations very rarely, so the eased
            concurrency seems to outweigh the fairly slight cost of thread-safe
            access.
            @param relation the relation to be added to the values list
        </member>
        <member name="M:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.GetConj(System.String)">
            <summary>
            The "conj" grammatical relation. Used to collapse conjunct relations.
            They will be turned into conj_word, where "word" is a conjunction.
            </summary>
            <param name="conjunctionString">The conjunction to make a GrammaticalRelation out of</param>
            <returns>A grammatical relation for this conjunction</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.GetPrep(System.String)">
            <summary>
            The "prep" grammatical relation. Used to collapse prepositions.
            They will be turned into prep_word, where "word" is a preposition
            </summary>
            <param name="prepositionString">The preposition to make a GrammaticalRelation out of</param>
            <returns>A grammatical relation for this preposition</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.GetPrepC(System.String)">
            <summary>
            The "prepc" grammatical relation. Used to collapse preposition complements.
            They will be turned into prep_word, where "word" is a preposition
            </summary>
            <param name="prepositionString">The preposition to make a GrammaticalRelation out of</param>
            <returns>A grammatical relation for this preposition</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.ValueOf(System.String)">
            <summary>
            Returns the EnglishGrammaticalRelation having the given string
            representation (e.g. "nsubj"), or null if no such is found.
            </summary>
            <param name="s">The short name of the GrammaticalRelation</param>
            <returns>The EnglishGrammaticalRelation with that name</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.EnglishGrammaticalRelations.ValueOf(System.Object)">
            <summary>
            Returns an EnglishGrammaticalRelation based on the argument.
            It works if passed a GrammaticalRelation or the String
            representation of one (e.g. "nsubj").  It returns <code>null</code>
            for other classes or if no string match is found.
            </summary>
            <param name="o">A GrammaticalRelation or String</param>
            <returns>The EnglishGrammaticalRelation with that name</returns>
        </member>
        <member name="T:OpenNLP.Tools.Trees.EnglishGrammaticalStructure">
            <summary>
            A GrammaticalStructure for English.
            
            The Stanford parser should be run with the "-retainNPTmpSubcategories"
            option! <b>Caveat emptor!</b> This is a work in progress. Suggestions welcome.
            
            @author Bill MacCartney
            @author Marie-Catherine de Marneffe
            @author Christopher Manning
            @author Daniel Cer (CoNLLX format and alternative user selected dependency printer/reader interface)
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.EnglishGrammaticalStructure.#ctor(OpenNLP.Tools.Trees.Tree)">
            <summary>
            Construct a new <code>GrammaticalStructure</code> from an existing parse tree.
            The new <code>GrammaticalStructure</code> has the same tree structure
            and label values as the given tree (but no shared storage). As part of
            construction, the parse tree is analyzed using definitions from
            {@link GrammaticalRelation <code>GrammaticalRelation</code>} to populate
            the new <code>GrammaticalStructure</code> with as many labeled grammatical relations as it can.
            </summary>
            <param name="t">Parse tree to make grammatical structure from</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.EnglishGrammaticalStructure.#ctor(OpenNLP.Tools.Trees.Tree,System.Predicate{System.String})">
            <summary>
            This gets used by GrammaticalStructureFactory (by reflection). DON'T DELETE.
            </summary>
            <param name="t">Parse tree to make grammatical structure from</param>
            <param name="puncFilter">Filter to remove punctuation dependencies</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.EnglishGrammaticalStructure.#ctor(OpenNLP.Tools.Trees.Tree,System.Predicate{System.String},OpenNLP.Tools.Trees.IHeadFinder)">
            <summary>
            This gets used by GrammaticalStructureFactory (by reflection). DON'T DELETE.
            </summary>
            <param name="t">Parse tree to make grammatical structure from</param>
            <param name="puncFilter">Filter to remove punctuation dependencies</param>
            <param name="hf">HeadFinder to use when building it</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.EnglishGrammaticalStructure.#ctor(OpenNLP.Tools.Trees.Tree,System.Predicate{System.String},OpenNLP.Tools.Trees.IHeadFinder,System.Boolean)">
            <summary>
            Construct a new <code>GrammaticalStructure</code> from an existing parse tree.
            The new <code>GrammaticalStructure</code> has the same tree structure
            and label values as the given tree (but no shared storage). As part of
            construction, the parse tree is analyzed using definitions from
            {@link GrammaticalRelation <code>GrammaticalRelation</code>} to populate
            the new <code>GrammaticalStructure</code> with as many labeled grammatical
            relations as it can.
            </summary>
            <param name="t">Parse tree to make grammatical structure from</param>
            <param name="puncFilter">Filter for punctuation words</param>
            <param name="hf">HeadFinder to use when building it</param>
            <param name="threadSafe">Whether or not to support simultaneous instances among multiple threads</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.EnglishGrammaticalStructure.CollapseDependencies(System.Collections.Generic.List{OpenNLP.Tools.Trees.TypedDependency},System.Boolean,System.Boolean)">
            <summary>
            Destructively modifies this <code>Collection{TypedDependency}</code>
            by collapsing several types of transitive pairs of dependencies.
            If called with a tree of dependencies and both CCprocess and
            includeExtras set to false, then the tree structure is preserved.
            <dl>
            <dt>prepositional object dependencies: pobj</dt>
            <dd><code>prep(cat, in)</code> and <code>pobj(in, hat)</code> are collapsed to
            <code>prep_in(cat, hat)</code></dd>
            <dt>prepositional complement dependencies: pcomp</dt>
            <dd>
            <code>prep(heard, of)</code> and <code>pcomp(of, attacking)</code> are
            collapsed to <code>prepc_of(heard, attacking)</code></dd>
            <dt>conjunct dependencies</dt>
            <dd>
            <code>cc(investors, and)</code> and
            <code>conj(investors, regulators)</code> are collapsed to
            <code>conj_and(investors,regulators)</code></dd>
            <dt>possessive dependencies: possessive</dt>
            <dd>
            <code>possessive(Montezuma, 's)</code> will be erased. This is like a collapsing, but
            due to the flatness of NPs, two dependencies are not actually composed.</dd>
            <dt>For relative clauses, it will collapse referent</dt>
            <dd>
            <code>ref(man, that)</code> and <code>dobj(love, that)</code> are collapsed
            to <code>dobj(love, man)</code></dd>
            </dl>
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.EnglishGrammaticalStructure.CollapseFlatMwp(System.Collections.Generic.List{OpenNLP.Tools.Trees.TypedDependency})">
            <summary>
            Collapse multi-words preposition of the following format, which comes from
            flat annotation. This handles e.g., "because of" (PP (IN because) (IN of)
            ...), "such as" (PP (JJ such) (IN as) ...)
            prep(gov, mwp[1]) dep(mpw[1], mwp[0]) pobj(mwp[1], compl) ->
            prep_mwp[0]_mwp[1](gov, compl)
            </summary>
            <param name="list">List of typedDependencies to work on</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.EnglishGrammaticalStructure.Collapse2WpBis(System.Collections.Generic.List{OpenNLP.Tools.Trees.TypedDependency})">
            <summary>
            Collapse multi-words preposition of the following format: advmod|prt(gov,
            mwp[0]) prep(gov,mwp[1]) pobj|pcomp(mwp[1], compl) ->
            prep_mwp[0]_mwp[1](gov, compl)
            </summary>
            <param name="list">List of typedDependencies to work on</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.EnglishGrammaticalStructure.Collapse3Wp(System.Collections.Generic.List{OpenNLP.Tools.Trees.TypedDependency})">
            <summary>
            Collapse 3-word preposition of the following format:
            This will be the case when the preposition is analyzed as a NP
            prep(gov, mwp0) 
            X(mwp0,mwp1)
            X(mwp1,mwp2)
            pobj|pcomp(mwp2, compl)
            -> prep_mwp[0]_mwp[1]_mwp[2](gov, compl)
            
            It also takes flat annotation into account:
            prep(gov,mwp0)
            X(mwp0,mwp1)
            X(mwp0,mwp2)
            pobj|pcomp(mwp0, compl)
            -> prep_mwp[0]_mwp[1]_mwp[2](gov, compl)
            </summary>
            <param name="list">List of typedDependencies to work on</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.EnglishGrammaticalStructure.IsConjWithNoPrep(OpenNLP.Tools.Ling.IndexedWord,System.Collections.Generic.List{OpenNLP.Tools.Trees.TypedDependency})">
            <summary>
            Given a list of typedDependencies, returns true if the node "node" is the
            governor of a conj relation with a dependent which is not a preposition
            </summary>
            <param name="node">A node in this GrammaticalStructure</param>
            <param name="list">A list of typedDependencies</param>
            <returns>
            true If node is the governor of a conj relation in the list with the dep not being a preposition
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.EnglishGrammaticalStructure.DeterminePrepRelation(System.Collections.Generic.Dictionary{OpenNLP.Tools.Ling.IndexedWord,OpenNLP.Tools.Util.SortedSet{OpenNLP.Tools.Trees.TypedDependency}},System.Collections.Generic.List{OpenNLP.Tools.Ling.IndexedWord},OpenNLP.Tools.Trees.TypedDependency,OpenNLP.Tools.Trees.TypedDependency,System.Boolean)">
            <summary>
            Work out prep relation name. pc is the dependency whose dep() is the
            preposition to do a name for. topPrep may be the same or different.
            Among the daughters of its gov is where to look for an auxpass.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.EnglishGrammaticalStructure.CollapseConj(System.Collections.Generic.List{OpenNLP.Tools.Trees.TypedDependency})">
            <summary>
            This rewrites the "conj" relation to "conj_word" and deletes cases of the
            "cc" relation providing this rewrite has occurred (but not if there is only
            something like a clause-initial and). For instance, cc(elected-5, and-9)
            conj(elected-5, re-elected-11) becomes conj_and(elected-5, re-elected-11)
            </summary>
            <param name="list">List of dependencies.</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.EnglishGrammaticalStructure.ConjValue(System.String)">
            <summary>
            Does some hard coding to deal with relation in CONJP. For now we deal with:
            but not, if not, instead of, rather than, but rather GO TO negcc
            as well as, not to mention, but also, &amp; GO TO and.
            </summary>
            <param name="conj">The head dependency of the conjunction marker</param>
            <returns>A GrammaticalRelation made from a normalized form of that conjunction.</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.EnglishGrammaticalStructure.AddRef(System.Collections.Generic.List{OpenNLP.Tools.Trees.TypedDependency})">
            <summary>
            Look for ref rules for a given word.  We look through the
            children and grandchildren of the rcmod dependency, and if any
            children or grandchildren depend on a that/what/which/etc word,
            we take the leftmost that/what/which/etc word as the dependent
            for the ref TypedDependency.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.EnglishGrammaticalStructure.CollapseReferent(System.Collections.Generic.List{OpenNLP.Tools.Trees.TypedDependency})">
            <summary>
            This method will collapse a referent relation such as follows. e.g.:
            "The man that I love ... " ref(man, that) dobj(love, that) -> dobj(love, man)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.EnglishGrammaticalStructure.AddExtraNSubj(System.Collections.Generic.List{OpenNLP.Tools.Trees.TypedDependency})">
            <summary>
            Add extra nsubj dependencies when collapsing basic dependencies.
            
            In the general case, we look for an aux modifier under an xcomp
            modifier, and assuming there aren't already associated nsubj
            dependencies as daughters of the original xcomp dependency, we
            add nsubj dependencies for each nsubj daughter of the aux.
            
            There is also a special case for "to" words, in which case we add
            a dependency if and only if there is no nsubj associated with the
            xcomp and there is no other aux dependency.  This accounts for
            sentences such as "he decided not to" with no following verb.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.EnglishGrammaticalStructure.CorrectSubjPass(System.Collections.Generic.List{OpenNLP.Tools.Trees.TypedDependency})">
            <summary>
            This method corrects subjects of verbs for which we identified an auxpass,
            but didn't identify the subject as passive.
            </summary>
            <param name="list">List of typedDependencies to work on</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.EnglishGrammaticalStructure.RemoveDep(System.Collections.Generic.List{OpenNLP.Tools.Trees.TypedDependency})">
            <summary>
            Remove duplicate relations: it can happen when collapsing stranded
            prepositions. E.g., "What does CPR stand for?" we get dep(stand, what), and
            after collapsing we also get prep_for(stand, what).
            </summary>
            <param name="list">A list of typed dependencies to check through</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.EnglishGrammaticalStructure.EraseMultiConj(System.Collections.Generic.List{OpenNLP.Tools.Trees.TypedDependency})">
            <summary>
            This method gets rid of multiwords in conjunctions to avoid having them
            creating disconnected constituents e.g.,
            "bread-1 as-2 well-3 as-4 cheese-5" will be turned into conj_and(bread,
            cheese) and then dep(well-3, as-2) and dep(well-3, as-4) cannot be attached
            to the graph, these dependencies are erased
            </summary>
            <param name="list">List of words to get rid of multiword conjunctions from</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.EnglishGrammaticalStructure.FilterKill(System.Collections.Generic.List{OpenNLP.Tools.Trees.TypedDependency})">
            <summary>
            Alters a list in place by removing all the KILL relations
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalStructure.MultiwordPreps">
            <summary>
            used by collapse2WP(), collapseFlatMWP(), collapse2WPbis()
            KEPT IN ALPHABETICAL ORDER
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishGrammaticalStructure.ThreewordPreps">
            <summary>
            Used by collapse3WP() KEPT IN ALPHABETICAL ORDER
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.EnglishGrammaticalStructure.Collapse2Wp(System.Collections.Generic.List{OpenNLP.Tools.Trees.TypedDependency})">
            <summary>
            * Collapse multiword preposition of the following format:
            prep|advmod|dep|amod(gov, mwp[0])
            dep(mpw[0],mwp[1])
            pobj|pcomp(mwp[1], compl) or pobj|pcomp(mwp[0], compl)
            -> prep_mwp[0]_mwp[1](gov, compl)
            prep|advmod|dep|amod(gov, mwp[1])
            dep(mpw[1],mwp[0])
            pobj|pcomp(mwp[1], compl) or pobj|pcomp(mwp[0], compl)
            -> prep_mwp[0]_mwp[1](gov, compl)
            
            The collapsing has to be done at once in order to know exactly which node
            is the gov and the dep of the multiword preposition. Otherwise this can
            lead to problems: removing a non-multiword "to" preposition for example!!!
            This method replaces the old "collapsedMultiWordPreps"
            </summary>
            <param name="list">list of typedDependencies to work on</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.EnglishGrammaticalStructure.CollapseMultiWordPrep(System.Collections.Generic.List{OpenNLP.Tools.Trees.TypedDependency},System.Collections.Generic.List{OpenNLP.Tools.Trees.TypedDependency},System.String,System.String,System.String,System.String)">
            <summary>
            Collapse multiword preposition of the following format:
            prep|advmod|dep|amod(gov, mwp0) dep(mpw0,mwp1) pobj|pcomp(mwp1, compl) or
            pobj|pcomp(mwp0, compl) -> prep_mwp0_mwp1(gov, compl)
            </summary>
            <param name="list">List of typedDependencies to work on</param>
            <param name="newTypedDeps">List of typedDependencies that we construct</param>
            <param name="strMwp0">First part of the multiword preposition to construct the collapsed preposition</param>
            <param name="strMwp1">Second part of the multiword preposition to construct the collapsed preposition</param>
            <param name="wMwp0">First part of the multiword preposition that we look for</param>
            <param name="wMwp1">Second part of the multiword preposition that we look for</param>
        </member>
        <member name="T:OpenNLP.Tools.Trees.EnglishPatterns">
            <summary>
            This class contains some English String or Tregex regular expression
            patterns. They originated in other classes like
            EnglishGrammaticalRelations, but were collected here so that they
            could be used without having to load large classes (which we might want
            to have parallel versions of.
            Some are just stored here as String objects, since they are often used as
            sub-patterns inside larger patterns.
            
            @author Christopher Manning
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishPatterns.CCompVerbRegex">
            <summary>
            A list of verbs where the answer to a question involving that
            verb would be a ccomp.
            For example, "I know when the train is arriving."  What does the person know?
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.EnglishPatterns.CCompObjVerbRegex">
            <summary>
            A subset of ccompVerbRegex where you could expect an object and
            still have a ccomp.  For example, "They told me when ..." can
            still have a ccomp.  "They know my order when ..." would not
            expect a ccomp between "know" and the head of "when ..."
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.GrammaticalRelation">
             <summary>
             {@code GrammaticalRelation} is used to define a
             standardized, hierarchical set of grammatical relations,
             together with patterns for identifying them in
             parse trees.
            
             Each <code>GrammaticalRelation</code> has:
             <ul>
             <li>A <code>String</code> short name, which should be a lowercase
             abbreviation of some kind (in the fure mainly Universal Dependency names).</li>
             <li>A <code>String</code> long name, which should be descriptive.</li>
             <li>A parent in the <code>GrammaticalRelation</code> hierarchy.</li>
             <li>A {@link Pattern <code>Pattern</code>} called
             <code>sourcePattern</code> which matches (parent) nodes from which
             this <code>GrammaticalRelation</code> could hold.  (Note: this is done
             with the Java regex Pattern <code>matches()</code> predicate. The pattern
             must match the
             whole node name, and <code>^</code> or <code>$</code> aren't needed.
             Tregex constructions like __ do not work. Use ".*" to be applicable
             at all nodes. This prefiltering is used for efficiency.)</li>
             <li>A list of zero or more {@link TregexPattern
             <code>TregexPattern</code>s} called <code>targetPatterns</code>,
             which describe the local tree structure which must hold between
             the source node and a target node for the
             <code>GrammaticalRelation</code> to apply. (Note: {@code tregex}
             regular expressions match with the {@code find()} method, while
             literal string label descriptions that are not regular expressions must
             be {@code equals()}.)</li>
             </ul>
            
             The <code>targetPatterns</code> associated
             with a <code>GrammaticalRelation</code> are designed as follows.
             In order to recognize a grammatical relation X holding between
             nodes A and B in a parse tree, we want to associate with
             <code>GrammaticalRelation</code> X a {@link TregexPattern
             <code>TregexPattern</code>} such that:
             <ul>
             <li>the root of the pattern matches A, and</li>
             <li>the pattern includes a node labeled "target", which matches B.</li>
             </ul>
             For example, for the grammatical relation <code>PREDICATE</code>
             which holds between a clause and its primary verb phrase, we might
             want to use the pattern {@code "S &lt; VP=target"}, in which the
             root will match a clause and the node labeled <code>"target"</code>
             will match the verb phrase.
            
             For a given grammatical relation, the method {@link
             GrammaticalRelation#getRelatedNodes <code>getRelatedNodes()</code>}
             takes a <code>Tree</code> node as an argument and attempts to
             return other nodes which have this grammatical relation to the
             argument node.  By default, this method operates as follows: it
             steps through the patterns in the pattern list, trying to match
             each pattern against the argument node, until it finds some
             matches.  If a pattern matches, all matching nodes (that is, each
             node which corresponds to node label "target" in some match) are
             returned as a list; otherwise the next pattern is tried.
            
             For some grammatical relations, we need more sophisticated logic to
             identify related nodes.  In such cases, {@link
             GrammaticalRelation#getRelatedNodes <code>getRelatedNodes()</code>}
             can be overridden on a per-relation basis using anonymous subclassing.
            
             @see GrammaticalStructure
             @see EnglishGrammaticalStructure
             @see EnglishGrammaticalRelations
             @see edu.stanford.nlp.trees.international.pennchinese.ChineseGrammaticalRelations
            
             @author Bill MacCartney
             @author Galen Andrew (refactoring English-specific stuff)
             @author Ilya Sherman (refactoring annotation-relation pairing, which is now gone)
             
             Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
             </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.GrammaticalRelation.Governor">
            <summary>
            The "governor" grammatical relation, which is the inverse of "dependent".
            Example: "the red car" -> <code>gov</code>(red, car)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.GrammaticalRelation.Dependent">
            <summary>
            The "dependent" grammatical relation, which is the inverse of "governor".
            Example: "the red car" -> <code>dep</code>(car, red)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.GrammaticalRelation.Root">
            <summary>
            The "root" grammatical relation between a faked "ROOT" node, and the root of the sentence.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.GrammaticalRelation.Kill">
            <summary>
            Dummy relation, used while collapsing relations, e.g., in English &amp; Chinese GrammaticalStructure
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.GrammaticalRelation.ValueOf(System.String,System.Collections.Generic.ICollection{OpenNLP.Tools.Trees.GrammaticalRelation})">
            <summary>
            Returns the GrammaticalRelation having the given string
            representation (e.g. "nsubj"), or null if no such is found.
            </summary>
            <param name="s">The short name of the GrammaticalRelation</param>
            <param name="values">The set of GrammaticalRelations to look for it among.</param>
            <returns>The GrammaticalRelation with that name</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.GrammaticalRelation.ValueOf(OpenNLP.Tools.Trees.GrammaticalRelation.Language,System.String)">
            <summary>
            Convert from a string representation of a GrammaticalRelation to a
            GrammaticalRelation.  Where possible, you should avoid using this
            method and simply work with true GrammaticalRelations rather than
            string representations.  Correct behavior of this method depends
            on the underlying data structure resources used being kept in sync
            with the ToString() and Equals() methods.  However, there is really
            no choice but to use this method when storing GrammaticalRelations
            to text files and then reading them back in, so this method is not deprecated.
            </summary>
            <param name="s">The string representation of a GrammaticalRelation</param>
            <returns>The grammatical relation represented by this String</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.GrammaticalRelation.IsFromString">
            <summary>
            This function is used to determine whether the GrammaticalRelation in
            question is one that was created to be a thin wrapper around a String
            representation by valueOf(string), or whether it is a full-fledged
            GrammaticalRelation created by direct invocation of the constructor.
            </summary>
            <returns>Whether this relation is just a wrapper created by valueOf(string)</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.GrammaticalRelation.#ctor(OpenNLP.Tools.Trees.GrammaticalRelation.Language,System.String,System.String,OpenNLP.Tools.Trees.GrammaticalRelation,System.String,OpenNLP.Tools.Trees.TRegex.TregexPatternCompiler,System.String[])">
            <summary>
            This is the main constructor used
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.GrammaticalRelation.#ctor(OpenNLP.Tools.Trees.GrammaticalRelation.Language,System.String,System.String,OpenNLP.Tools.Trees.GrammaticalRelation)">
            <summary>
            Used for non-leaf relations with no patterns
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.GrammaticalRelation.#ctor(OpenNLP.Tools.Trees.GrammaticalRelation.Language,System.String,System.String,OpenNLP.Tools.Trees.GrammaticalRelation,System.String)">
            <summary>
            used to create collapsed relations with specificString
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.GrammaticalRelation.GetRelatedNodes(OpenNLP.Tools.Trees.TreeGraphNode,OpenNLP.Tools.Trees.TreeGraphNode,OpenNLP.Tools.Trees.IHeadFinder)">
            <summary>
            Given a {@code Tree} node {@code t}, attempts to
            return a list of nodes to which node {@code t} has this
            grammatical relation, with {@code t} as the governor.
            </summary>
            <param name="t">Target for finding dependents of t related by this GR</param>
            <param name="root">The root of the Tree</param>
            <returns>A Collection of dependent nodes to which t bears this GR</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.GrammaticalRelation.IsApplicable(OpenNLP.Tools.Trees.Tree)">
            <summary>
            Returns <code>true</code> iff the value of <code>Tree</code>
            node <code>t</code> matches the <code>sourcePattern</code> for
            this <code>GrammaticalRelation</code>, indicating that this
            <code>GrammaticalRelation</code> is one that could hold between
            <code>Tree</code> node <code>t</code> and some other node.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.GrammaticalRelation.IsAncestor(OpenNLP.Tools.Trees.GrammaticalRelation)">
            <summary>
            Returns whether this is equal to or an ancestor of gr in the grammatical relations hierarchy.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.GrammaticalRelation.ToString">
            <summary>
            Returns short name (abbreviation) for this <code>GrammaticalRelation</code>.
            ToString() for collapsed relations will include the word that was collapsed.
            <i>Implementation note:</i> Note that this method must be synced with
            the Equals() and valueOf(string) methods
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.GrammaticalRelation.ToPrettyString">
            <summary>
            Returns a <code>string</code> representation of this
            <code>GrammaticalRelation</code> and the hierarchy below
            it, with one node per line, indented according to level.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.GrammaticalRelation.ToPrettyString(System.Int32,System.Text.StringBuilder)">
            <summary>
            Returns a <code>string</code> representation of this
            <code>GrammaticalRelation</code> and the hierarchy below
            it, with one node per line, indented according to <code>indentLevel</code>.
            </summary>
            <param name="indentLevel">how many levels to indent (0 for root node)</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.GrammaticalRelation.Equals(System.Object)">
            <summary>
            Grammatical relations are equal with other grammatical relations if they
            have the same shortName and specific (if present).
            <i>Implementation note:</i> Note that this method must be synced with
            the ToString() and valueOf(string) methods
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.GrammaticalRelation.GetParent">
            <summary>
            Returns the parent of this <code>GrammaticalRelation</code>.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.GrammaticalStructure">
            <summary>
            A {@code GrammaticalStructure} stores dependency relations between
            nodes in a tree.  A new <code>GrammaticalStructure</code> is constructed
            from an existing parse tree with the help of {@link
            GrammaticalRelation <code>GrammaticalRelation</code>}, which
            defines a hierarchy of grammatical relations, along with
            patterns for identifying them in parse trees.  The constructor for
            <code>GrammaticalStructure</code> uses these definitions to
            populate the new <code>GrammaticalStructure</code> with as many
            labeled grammatical relations as it can.  Once constructed, the new
            <code>GrammaticalStructure</code> can be printed in various
            formats, or interrogated using the interface methods in this
            class. Internally, this uses a representation via a {@code TreeGraphNode},
            that is, a tree with additional labeled
            arcs between nodes, for representing the grammatical relations in a parse tree.
            
            <b>Caveat emptor!</b> This is a work in progress.
            Nothing in here should be relied upon to function perfectly.
            Feedback welcome.
            
            @author Bill MacCartney
            @author Galen Andrew (refactoring English-specific stuff)
            @author Ilya Sherman (dependencies)
            @author Daniel Cer
            @see EnglishGrammaticalRelations
            @see GrammaticalRelation
            @see EnglishGrammaticalStructure
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.GrammaticalStructure.root">
            <summary>
            The root Tree node for this GrammaticalStructure.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.GrammaticalStructure.indexMap">
            <summary>
            A map from arbitrary integer indices to nodes.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.GrammaticalStructure.#ctor(OpenNLP.Tools.Trees.Tree,System.Collections.Generic.ICollection{OpenNLP.Tools.Trees.GrammaticalRelation},System.Object,OpenNLP.Tools.Trees.IHeadFinder,System.Predicate{System.String})">
            <summary>
            Create a new GrammaticalStructure, analyzing the parse tree and
            populate the GrammaticalStructure with as many labeled
            grammatical relation arcs as possible.
            </summary>
            <param name="t">A Tree to analyze</param>
            <param name="relations">A set of GrammaticalRelations to consider</param>
            <param name="relationsLock">Something needed to make this thread-safe</param>
            <param name="hf">A HeadFinder for analysis</param>
            <param name="puncFilter">
            A Filter to reject punctuation. To delete punctuation
            dependencies, this filter should return false on punctuation word strings, 
            and true otherwise. If punctuation dependencies should be kept, you
            should pass in a Filters.&lt;String&gt;acceptFilter().
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.GrammaticalStructure.IndexNodes(OpenNLP.Tools.Trees.TreeGraphNode)">
            <summary>
            Assign sequential integer indices (starting with 1) to all
            nodes of the subtree rooted at this
            <code>Tree</code>.  The leaves are indexed first,
            from left to right.  Then the internal nodes are indexed,
            using a pre-order tree traversal.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.GrammaticalStructure.IndexLeaves(OpenNLP.Tools.Trees.TreeGraphNode,System.Int32)">
            <summary>
            Assign sequential integer indices to the leaves of the subtree
            rooted at this <code>TreeGraphNode</code>, beginning with
            <code>startIndex</code>, and traversing the leaves from left
            to right. If node is already indexed, then it uses the existing index.
            </summary>
            <param name="startIndex">index for this node</param>
            <returns>The next index still unassigned</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.GrammaticalStructure.IndexNodes(OpenNLP.Tools.Trees.TreeGraphNode,System.Int32)">
            <summary>
            Assign sequential integer indices to all nodes of the subtree
            rooted at this <code>TreeGraphNode</code>, beginning with
            <code>startIndex</code>, and doing a pre-order tree traversal.
            Any node which already has an index will not be re-indexed
            em-dash this is so that we can index the leaves first, and
            then index the rest.
            </summary> 
            <param name="startIndex">index for this node</param>
            <returns>The next index still unassigned</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.GrammaticalStructure.AddNodeToIndexMap(System.Int32,OpenNLP.Tools.Trees.TreeGraphNode)">
            <summary>
            Store a mapping from an arbitrary integer index to a node in
            this treegraph.  Normally a client shouldn't need to use this,
            as the nodes are automatically indexed by the <code>TreeGraph</code> constructor.
            </summary>
            <param name="index">the arbitrary integer index</param>
            <param name="node">the <code>TreeGraphNode</code> to be indexed</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.GrammaticalStructure.GetNodeByIndex(System.Int32)">
            <summary>
            Return the node in the this treegraph corresponding to the
            specified integer index.
            </summary>
            <param name="index">the integer index of the node you want</param>
            <returns>
            the <code>TreeGraphNode</code> having the specified
            index (or <code>null</code> if such does not exist)
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.GrammaticalStructure.Root">
            <summary>
            Return the root Tree of this GrammaticalStructure.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.GrammaticalStructure.FromStringReps(System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.String})">
            <summary>
            Create a grammatical structure from its string representation.
            Like buildCoNLLXGrammaticalStructure, this method fakes up the parts 
            of the tree structure that are not used by the grammatical relation transformation operations.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.GrammaticalStructure.GetDeps(System.Predicate{OpenNLP.Tools.Trees.TypedDependency},OpenNLP.Tools.Graphs.DirectedMultiGraph{OpenNLP.Tools.Trees.TreeGraphNode,OpenNLP.Tools.Trees.GrammaticalRelation})">
            <summary>
            Helps the constructor build a list of typed dependencies using
            information from a {@code GrammaticalStructure}.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.GrammaticalStructure.ExtraTreeDepFilter">
            <summary>
            Returns a Filter which checks dependencies for usefulness as
            extra tree-based dependencies.  By default, everything is
            accepted.  One example of how this can be useful is in the
            English dependencies, where the REL dependency is used as an
            intermediate and we do not want this to be added when we make a
            second pass over the trees for missing dependencies.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.GrammaticalStructure.PostProcessDependencies(System.Collections.Generic.List{OpenNLP.Tools.Trees.TypedDependency})">
            <summary>
            Post process the dependencies in whatever way this language
            requires.  For example, English might replace "rel" dependencies
            with either dobj or pobj depending on the surrounding dependencies.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.GrammaticalStructure.GetExtras(System.Collections.Generic.List{OpenNLP.Tools.Trees.TypedDependency})">
            <summary>
            Get extra dependencies that do not depend on the tree structure,
            but rather only depend on the existing dependency structure.
            For example, the English xsubj dependency can be extracted that way.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.GrammaticalStructure.GetTreeDeps(System.Collections.Generic.List{OpenNLP.Tools.Trees.TypedDependency},OpenNLP.Tools.Graphs.DirectedMultiGraph{OpenNLP.Tools.Trees.TreeGraphNode,OpenNLP.Tools.Trees.GrammaticalRelation},System.Predicate{OpenNLP.Tools.Trees.TypedDependency},System.Predicate{OpenNLP.Tools.Trees.TypedDependency})">
            <summary>
            Look through the tree t and adds to the List basicDep additional dependencies 
            which aren't in the List but which satisfy the filter puncTypedDepFilter.
            </summary>
            <param name="deps">The list of dependencies which may be augmented</param>
            <param name="completeGraph">a graph of all the tree dependencies found earlier</param>
            <param name="puncTypedDepFilter">The filter that may skip punctuation dependencies</param>
            <param name="extraTreeDepFilter">Additional dependencies are added only if they pass this filter</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.GrammaticalStructure.GetGrammaticalRelation(System.Int32,System.Int32)">
            <summary>
            Get GrammaticalRelation between gov and dep, and null if gov  is not the governor of dep
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.GrammaticalStructure.GetGrammaticalRelation(OpenNLP.Tools.Ling.IndexedWord,OpenNLP.Tools.Ling.IndexedWord)">
            <summary>
            Get GrammaticalRelation between gov and dep, and null if gov is not the governor of dep
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.GrammaticalStructure.GetGrammaticalRelationCommonAncestor(OpenNLP.Tools.Ling.IAbstractCoreLabel,OpenNLP.Tools.Ling.IAbstractCoreLabel,System.Collections.Generic.List{OpenNLP.Tools.Trees.GrammaticalRelation})">
            <summary>
            Returns the GrammaticalRelation which is the highest common
            ancestor of the list of relations passed in.  The IndexedWords
            are passed in only for debugging reasons.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.GrammaticalStructure.TypedDependencies">
            <summary>
            Returns the typed dependencies of this grammatical structure.
            These are the basic word-level typed dependencies, where each word is dependent
            on one other thing, either a word or the starting ROOT, and the
            dependencies have a tree structure.  This corresponds to the command-line option "basicDependencies".
            </summary>
            <returns>The typed dependencies of this grammatical structure</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.GrammaticalStructure.AllTypedDependencies">
            <summary>
            Returns all the typed dependencies of this grammatical structure.
            These are like the basic (uncollapsed) dependencies, but may include
            extra arcs for control relationships, etc. This corresponds to the "nonCollapsed" option.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.GrammaticalStructure.TypedDependencies(System.Boolean)">
            <summary>
            Returns the typed dependencies of this grammatical structure.
            These are non-collapsed dependencies (basic or nonCollapsed).
            </summary>
            <param name="includeExtras">
            If true, the list of typed dependencies returned may include "extras", 
            and does not follow a tree structure.
            </param>
            <returns>The typed dependencies of this grammatical structure</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.GrammaticalStructure.TypedDependenciesCollapsed">
            <summary>
            Get the typed dependencies after collapsing them.
            Collapsing dependencies refers to turning certain function words
            such as prepositions and conjunctions into arcs, so they disappear from the set of nodes.
            There is no guarantee that the dependencies are a tree. While the
            dependencies are normally tree-like, the collapsing may introduce
            not only re-entrancies but even small cycles.
            </summary>
            <returns>A set of collapsed dependencies</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.GrammaticalStructure.TypedDependenciesCollapsedTree">
            <summary>
            Get the typed dependencies after mostly collapsing them, but keep a tree
            structure.  In order to do this, the code does:
            <ol>
            <li> no relative clause processing</li>
            <li> no xsubj relations</li>
            <li> no propagation of conjuncts</li>
            </ol>
            This corresponds to the "tree" option.
            </summary>
            <returns>collapsed dependencies keeping a tree structure</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.GrammaticalStructure.TypedDependenciesCollapsed(System.Boolean)">
            <summary>
            Get the typed dependencies after collapsing them.
            The "collapsed" option corresponds to calling this method with argument {@code true}.
            </summary>
            <param name="includeExtras">
            If true, the list of typed dependencies returned may include "extras", 
            like controlling subjects
            </param>
            <returns>Collapsed dependencies</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.GrammaticalStructure.TypedDependenciesCcProcessed(System.Boolean)">
            <summary>
            Get the typed dependencies after collapsing them and processing eventual CC complements.
            The effect of this part is to distributed conjoined arguments across relations 
            or conjoined predicates across their arguments.
            This is generally useful, and we generally recommend using the output of
            this method with the second argument being {@code true}.
            The "CCPropagated" option corresponds to calling this method with an
            argument of {@code true}.
            </summary>
            <param name="includeExtras">
            If true, the list of typed dependencies
            returned may include "extras", such as controlled subject links.
            </param>
            <returns>collapsed dependencies with CC processed</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.GrammaticalStructure.TypedDependenciesCcProcessed">
            <summary>
            Get a list of the typed dependencies, including extras like control
            dependencies, collapsing them and distributing relations across coordination.
            This method is generally recommended for best representing the semantic 
            and syntactic relations of a sentence. 
            In general it returns a directed graph (i.e., the output may not be a tree
            and it may contain (small) cycles).
            The "CCPropagated" option corresponds to calling this method.
            </summary>
            <returns>collapsed dependencies with CC processed</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.GrammaticalStructure.CollapseDependencies(System.Collections.Generic.List{OpenNLP.Tools.Trees.TypedDependency},System.Boolean,System.Boolean)">
            <summary>
            Destructively modify the Collection &lt; TypedDependency &lt; to collapse
            language-dependent transitive dependencies.
            
            Default is no-op; to be over-ridden in subclasses.
            </summary>
            <param name="list">A list of dependencies to process for possible collapsing</param>
            <param name="cCprocess">apply CC process?</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.GrammaticalStructure.CollapseDependenciesTree(System.Collections.Generic.List{OpenNLP.Tools.Trees.TypedDependency})">
            <summary>
            Destructively modify the <code>Collection&lt;TypedDependency&gt;</code> to collapse
            language-dependent transitive dependencies but keeping a tree structure.
            
            Default is no-op; to be over-ridden in subclasses.
            </summary>
            <param name="list">A list of dependencies to process for possible collapsing</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.GrammaticalStructure.CorrectDependencies(System.Collections.Generic.ICollection{OpenNLP.Tools.Trees.TypedDependency})">
            <summary>
            Destructively modify the <code>TypedDependencyGraph</code> to correct
            language-dependent dependencies. (e.g., nsubjpass in a relative clause)
            
            Default is no-op; to be over-ridden in subclasses.
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.GrammaticalStructure.IsConnected(System.Collections.Generic.ICollection{OpenNLP.Tools.Trees.TypedDependency})">
            <summary>
            Checks if all the typeDependencies are connected
            </summary>
            <param name="list">a list of typedDependencies</param>
            <returns>if the list represents a connected graph, false otherwise</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.GrammaticalStructure.GetRoots(System.Collections.Generic.ICollection{OpenNLP.Tools.Trees.TypedDependency})">
            <summary>
            Return a list of TypedDependencies which are not dependent on any node from the list.
            </summary>
            <param name="list">The list of TypedDependencies to check</param>
            <returns>A list of TypedDependencies which are not dependent on any node from the list</returns>
        </member>
        <member name="T:OpenNLP.Tools.Trees.IGrammaticalStructureFactory">
            <summary>
            A general factory for {@link GrammaticalStructure} objects.
            
            @author Galen Andrew
            @author John Bauer
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.IGrammaticalStructureFactory.NewGrammaticalStructure(OpenNLP.Tools.Trees.Tree)">
            <summary>
            Vend a new {@link GrammaticalStructure} based on the given {@link Tree}.
            </summary>
            <param name="t">the tree to analyze</param>
            <returns>a GrammaticalStructure based on the tree</returns>
        </member>
        <member name="T:OpenNLP.Tools.Trees.IHasParent">
            <summary>
            Only to be implemented by Tree subclasses that actualy keep their
            parent pointers.  For example, the base Tree class should
            <b>not</b> implement this, but TreeGraphNode should.
            
            @author John Bauer
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.IHeadFinder">
            <summary>
            An interface for finding the "head" daughter of a phrase structure tree.
            This could potentially be any sense of "head", but has mainly been used
            to find the lexical head for lexicalized PCFG parsing.
            
            @author Christopher Manning
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.IHeadFinder.DetermineHead(OpenNLP.Tools.Trees.Tree)">
            <summary>
            Determine which daughter of the current parse tree is the head.
            </summary>
            <param name="t">The parse tree to examine the daughters of</param>
            <returns>
            The daughter tree that is the head. This will always be non-null.
            An Exception will be thrown if no head can be determined.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.IHeadFinder.DetermineHead(OpenNLP.Tools.Trees.Tree,OpenNLP.Tools.Trees.Tree)">
            <summary>
            Determine which daughter of the current parse tree is the head
            given the parent of the tree.
            </summary>
            <param name="t">The parse tree to examine the daughters of</param>
            <param name="parent">The parent of tree t</param>
            <returns>
            The daughter tree that is the head. This will always be non-null. 
            An Exception will be thrown if no head can be determined.
            </returns>
        </member>
        <member name="T:OpenNLP.Tools.Trees.IConstituentFactory">
            <summary>
            A <code>ConstituentFactory</code> is a factory for creating objects
            of class <code>Constituent</code>, or some descendent class.
            
            @author Christopher Manning
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.IConstituentFactory.NewConstituent(System.Int32,System.Int32)">
            <summary>
            Build a constituent with this start and end.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.IConstituentFactory.NewConstituent(System.Int32,System.Int32,OpenNLP.Tools.Ling.ILabel,System.Double)">
            <summary>
            Build a constituent with this start and end.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.ITreebankLanguagePack">
            <summary>
            This interface specifies language/treebank specific information for a
            Treebank, which a parser or other treebank user might need to know.
            
            Some of this is fixed for a (treebank,language) pair, but some of it
            reflects feature extraction decisions, so it can be sensible to have
            multiple implementations of this interface for the same (treebank,language) pair.
            
            So far this covers punctuation, character encodings, and characters
            reserved for label annotations.  It should probably be expanded to
            cover other stuff (unknown words?).
            
            Various methods in this class return arrays.  You should treat them
            as read-only, even though one cannot enforce that in Java.
            
            Implementations in this class do not call basicCategory() on arguments
            before testing them, so if needed, you should explicitly call
            basicCategory() yourself before passing arguments to these routines for testing.
            
            This class should be able to be an immutable singleton.  It contains
            data on various things, but no state.  At some point we should make it
            a real immutable singleton.
            
            @author Christopher Manning
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreebankLanguagePack.IsPunctuationTag(System.String)">
            <summary>
            Accepts a string that is a punctuation tag name, and rejects everything else
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreebankLanguagePack.IsPunctuationWord(System.String)">
            <summary>
            Accepts a string that is a punctuation word, and rejects everything else.
            If one can't tell for sure (as for ' in the Penn Treebank), it
            maks the best guess that it can.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreebankLanguagePack.IsSentenceFinalPunctuationTag(System.String)">
            <summary>
            Accepts a string that is a sentence end
            punctuation tag, and rejects everything else.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreebankLanguagePack.IsEvalBIgnoredPunctuationTag(System.String)">
            <summary>
            Accepts a string that is a punctuation
            tag that should be ignored by EVALB-style evaluation,
            and rejects everything else.
            Traditionally, EVALB has ignored a subset of the total set of
            punctuation tags in the English Penn Treebank (quotes and
            period, comma, colon, etc., but not brackets)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreebankLanguagePack.PunctuationTagAcceptFilter">
            <summary>
            Return a filter that accepts a string that is a punctuation
            tag name, and rejects everything else.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreebankLanguagePack.PunctuationTagRejectFilter">
            <summary>
            Return a filter that rejects a string that is a punctuation
            tag name, and accepts everything else
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreebankLanguagePack.PunctuationWordAcceptFilter">
            <summary>
            Returns a filter that accepts a string that is a punctuation
            word, and rejects everything else.
            If one can't tell for sure (as for ' in the Penn Treebank), it
            maks the best guess that it can.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreebankLanguagePack.PunctuationWordRejectFilter">
            <summary>
            Returns a filter that accepts a string that is not a punctuation
            word, and rejects punctuation.
            If one can't tell for sure (as for ' in the Penn Treebank), it
            makes the best guess that it can.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreebankLanguagePack.SentenceFinalPunctuationTagAcceptFilter">
            <summary>
            Returns a filter that accepts a string that is a sentence end
            punctuation tag, and rejects everything else
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreebankLanguagePack.EvalBIgnoredPunctuationTagAcceptFilter">
            <summary>
            Returns a filter that accepts a string that is a punctuation
            tag that should be ignored by EVALB-style evaluation,
            and rejects everything else.
            Traditionally, EVALB has ignored a subset of the total set of
            punctuation tags in the English Penn Treebank (quotes and
            period, comma, colon, etc., but not brackets)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreebankLanguagePack.EvalBIgnoredPunctuationTagRejectFilter">
            <summary>
            Returns a filter that accepts everything except a string that is a
            punctuation tag that should be ignored by EVALB-style evaluation.
            Traditionally, EVALB has ignored a subset of the total set of
            punctuation tags in the English Penn Treebank (quotes and
            period, comma, colon, etc., but not brackets)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreebankLanguagePack.PunctuationTags">
            <summary>
            Returns a string array of punctuation tags for this treebank/language
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreebankLanguagePack.PunctuationWords">
            <summary>
            Returns a string array of punctuation words for this treebank/language.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreebankLanguagePack.SentenceFinalPunctuationTags">
            <summary>
            Returns a string array of sentence readonly punctuation tags for this
            treebank/language.  The first in the list is assumed to be the most basic one
            </summary>
            <returns>The sentence readonly punctuation tags</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreebankLanguagePack.SentenceFinalPunctuationWords">
            <summary>
            Returns a string array of sentence readonly punctuation words for this treebank/language
            </summary>
            <returns>The punctuation words</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreebankLanguagePack.EvalBIgnoredPunctuationTags">
            <summary>
            Returns a string array of punctuation tags that EVALB-style evaluation
            should ignore for this treebank/language.
            Traditionally, EVALB has ignored a subset of the total set of
            punctuation tags in the English Penn Treebank (quotes and
            period, comma, colon, etc., but not brackets)
            </summary>
            <returns>Whether this is a EVALB-ignored punctuation tag</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreebankLanguagePack.GrammaticalStructureFactory">
            <summary>
            Return a GrammaticalStructureFactory suitable for this language/treebank
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreebankLanguagePack.GrammaticalStructureFactory(System.Predicate{System.String})">
            <summary>
            Return a GrammaticalStructureFactory suitable for this language/treebank
            </summary>
            <param name="puncFilter">A filter which should reject punctuation words (as Strings)</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreebankLanguagePack.GrammaticalStructureFactory(System.Predicate{System.String},OpenNLP.Tools.Trees.IHeadFinder)">
            <summary>
            Return a GrammaticalStructureFactory suitable for this language/treebank
            </summary>
            <param name="puncFilter">A filter which should reject punctuation words (as Strings)</param>
            <param name="typedDependencyHf">A HeadFinder which finds heads for typed dependencies</param>
            <returns>A GrammaticalStructureFactory suitable for this language/treebank</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreebankLanguagePack.SupportsGrammaticalStructures">
            <summary>
             Whether or not we have typed dependencies for this language.
            If this method returns false, a call to grammaticalStructureFactory
            will cause an exception
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreebankLanguagePack.GetEncoding">
            <summary>
            Return the charset encoding of the Treebank.
            See documentation for the <code>Charset</code> class
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreebankLanguagePack.GetTokenizerFactory">
            <summary>
            Return a tokenizer factory which might be suitable for tokenizing text
            that will be used with this Treebank/Language pair.  This is for
            real text of this language pair, not for reading stuff inside the treebank files
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreebankLanguagePack.LabelAnnotationIntroducingCharacters">
            <summary>
            Return an array of characters at which a string should be
            truncated to give the basic syntactic category of a label.
            The idea here is that Penn treebank style labels follow a syntactic
            category with various functional and crossreferencing information
            introduced by special characters (such as "NP-SBJ=1").  This would
            be truncated to "NP" by the array containing '-' and "=".
            
            Note that these are never deleted as the first character as a label
            (so they are okay as one character tags, etc.), but only when subsequent characters
            </summary>
            <returns>An array of characters that set off label name suffixes</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreebankLanguagePack.IsLabelAnnotationIntroducingCharacter(System.Char)">
            <summary>
            Say whether this character is an annotation introducing character
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreebankLanguagePack.BasicCategory(System.String)">
            <summary>
            Returns the basic syntactic category of a string by truncating
            stuff after a (non-word-initial) occurrence of one of the
            <code>labelAnnotationIntroducingCharacters()</code>.
            This function should work on phrasal category and POS tag labels,
            but needn't (and couldn't be expected to) work on arbitrary Word strings.
            </summary>
            <param name="category">The whole string name of the label</param>
            <returns>The basic category of the String</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreebankLanguagePack.StripGf(System.String)">
            <summary>
            Returns the category for a string with everything following
            the gf character (which may be language specific) stripped
            </summary>
            <param name="category">The string name of the label (may previously have had basic category called on it)</param>
            <returns>The string stripped of grammatical functions</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreebankLanguagePack.GetBasicCategoryFunction">
            <summary>
            Returns a {@link Function Function} object that maps strings to strings according
            to this TreebankLanguagePack's basicCategory method
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreebankLanguagePack.CategoryAndFunction(System.String)">
            <summary>
            Returns the syntactic category and 'function' of a string.
            This normally involves truncating numerical coindexation
            showing coreference, etc.  By 'function', this means
            keeping, say, Penn Treebank functional tags or ICE phrasal functions,
            perhaps returning them as <code>category-function</code>.
            </summary>
            <param name="category">The whole string name of the label</param>
            <returns>A string giving the category and function</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreebankLanguagePack.GetCategoryAndFunctionFunction">
            <summary>
            Returns a {@link Function Function} object that maps strings to strings according
            to this TreebankLanguagePack's categoryAndFunction method.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreebankLanguagePack.IsStartSymbol(System.String)">
            <summary>
            Accepts a string that is a start symbol of the treebank
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreebankLanguagePack.StartSymbolAcceptFilter">
            <summary>
            Return a filter that accepts a string that is a start symbol
            of the treebank, and rejects everything else.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreebankLanguagePack.StartSymbols">
            <summary>
            Returns a string array of treebank start symbols.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreebankLanguagePack.StartSymbol">
            <summary>
            Returns a string which is the first (perhaps unique) start symbol
            of the treebank, or null if none is defined.
            </summary>
            <returns>The start symbol</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreebankLanguagePack.TreebankFileExtension">
            <summary>
            Returns the extension of treebank files for this treebank.
            This should be passed as an argument to Treebank loading classes.
            It might be "mrg" or "fid" or whatever.  Don't include the period.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreebankLanguagePack.SetGfCharacter(System.Char)">
            <summary>
            Sets the grammatical function indicating character to gfCharacter
            </summary>
            <param name="gfCharacter">
            Sets the character in label names that sets of
            grammatical function marking (from the phrase label)
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreebankLanguagePack.TreeTokenizerFactory">
            <summary>
            Return a TokenizerFactory for Trees of this language/treebank
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreebankLanguagePack.HeadFinder">
            <summary>
            The HeadFinder to use for your treebank
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreebankLanguagePack.TypedDependencyHeadFinder">
            <summary>
            The HeadFinder to use when making typed dependencies
            </summary>s
        </member>
        <member name="T:OpenNLP.Tools.Trees.ITreeFactory">
            <summary>
            A <code>TreeFactory</code> acts as a factory for creating objects of
            class <code>Tree</code>, or some descendant class.
            Methods implementing this interface may assume that the <code>List</code>
            of children passed to them is a list that actually contains trees, but
            this can't be enforced in Java without polymorphic types.
            The methods with a String argument do not guarantee
            that the tree label() will be a String -- the TreeFactory may
            convert it into some other type.
            
            @author Christopher Manning
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreeFactory.NewLeaf(System.String)">
            <summary>
            Create a new tree leaf node, where the label is formed from
            the <code>string</code> passed in
            </summary>
            <param name="word">The word that will go into the tree label</param>
            <returns>The new leaf</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreeFactory.NewTreeNode(System.String,System.Collections.Generic.List{OpenNLP.Tools.Trees.Tree})">
            <summary>
            Create a new tree non-leaf node, where the label is formed from
            the <code>string</code> passed in
            </summary>
            <param name="parent">The string that will go into the parent tree label</param>
            <param name="children">
            The list of daughters of this tree.
            The children may be a (possibly empty) <code>List</code> of children or <code>null</code>
            </param>
            <returns>The new interior tree node</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreeFactory.NewLeaf(OpenNLP.Tools.Ling.ILabel)">
            <summary>
            Create a new tree leaf node, with the given label
            </summary>
            <param name="label">The label for the leaf node</param>
            <returns>The new leaf</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreeFactory.NewTreeNode(OpenNLP.Tools.Ling.ILabel,System.Collections.Generic.List{OpenNLP.Tools.Trees.Tree})">
            <summary>
            Create a new tree non-leaf node, with the given label
            </summary>
            <param name="label">The label for the parent tree node</param>
            <param name="children">
            The list of daughters of this tree.  
            The children may be a (possibly empty) <code>List</code> of children or <code>null</code>
            </param>
            <returns>The new interior tree node</returns>
        </member>
        <member name="T:OpenNLP.Tools.Trees.ITreeReader">
            <summary>
            A <code>TreeReader</code> adds functionality to another <code>Reader</code>
            by reading in Trees, or some descendant class.
            
            @author Christopher Manning
            @author Roger Levy (mod. 2003/01)
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreeReader.ReadTree">
            <summary>
            Reads a single tree
            </summary>
            <returns>A single tree, or <code>null</code> at end of file.</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreeReader.Close">
            <summary>
            Close the Reader behind this <code>TreeReader</code>
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.ITreeReaderFactory">
            <summary>
            A <code>TreeReaderFactory</code> is a factory for creating objects of
            class <code>TreeReader</code>, or some descendant class.
            
            @author Christopher Manning
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreeReaderFactory.NewTreeReader(System.IO.TextReader)">
            <summary>
            Create a new <code>TreeReader</code> using the provided <code>Reader</code>
            </summary>
            <param name="reader">The <code>Reader</code> to build on</param>
            <returns>The new TreeReader</returns>
        </member>
        <member name="T:OpenNLP.Tools.Trees.ITreeTransformer">
            <summary>
            This is a simple interface for a function that alters a
            local <code>Tree</code>.
            
            @author Christopher Manning.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.ITreeTransformer.TransformTree(OpenNLP.Tools.Trees.Tree)">
            <summary>
            Does whatever one needs to do to a particular tree.
            This routine is passed a whole <code>Tree</code>, and could itself
            work recursively, but the canonical usage is to invoke this method
            via the <code>Tree.transform()</code> method, which will apply the
            transformer in a bottom-up manner to each local <code>Tree</code>,
            and hence the implementation of <code>TreeTransformer</code> should
            merely examine and change a local (one-level) <code>Tree</code>.
            </summary>
            <param name="t">
            A tree.  Classes implementing this interface can assume
            that the tree passed in is not <code>null</code>
            </param>
            <returns>the transformed <code>Tree</code></returns>
        </member>
        <member name="T:OpenNLP.Tools.Trees.LabeledScoredTreeFactory">
            <summary>
            A <code>LabeledScoredTreeFactory</code> acts as a factory for creating
            trees with labels and scores.  Unless another <code>LabelFactory</code>
            is supplied, it will use a <code>CoreLabel</code> by default.
            
            @author Christopher Manning
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.LabeledScoredTreeFactory.#ctor">
            <summary>
            Make a TreeFactory that produces LabeledScoredTree trees.
            The labels are of class <code>CoreLabel</code>.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.LabeledScoredTreeFactory.#ctor(OpenNLP.Tools.Ling.ILabelFactory)">
            <summary>
            Make a TreeFactory that uses LabeledScoredTree trees, where the
            labels are as specified by the user.
            </summary>
            <param name="lf">the <code>LabelFactory</code> to be used to create labels</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.LabeledScoredTreeFactory.NewLeaf(OpenNLP.Tools.Ling.ILabel)">
            <summary>
            Create a new leaf node with the given label
            </summary>
            <param name="label">the label for the leaf node</param>
            <returns>A new tree leaf</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.LabeledScoredTreeFactory.NewTreeNode(OpenNLP.Tools.Ling.ILabel,System.Collections.Generic.List{OpenNLP.Tools.Trees.Tree})">
            <summary>
            Create a new non-leaf tree node with the given label
            </summary>
            <param name="parentLabel">The label for the node</param>
            <param name="children">
            A <code>List</code> of the children of this node,
            each of which should itself be a <code>LabeledScoredTree</code>
            </param>
            <returns>A new internal tree node</returns>
        </member>
        <member name="T:OpenNLP.Tools.Trees.LabeledScoredTreeNode">
            <summary>
            A {@code LabeledScoredTreeNode} represents a tree composed of a root
            label, a score, and an array of daughter parse trees.  A parse tree derived from a rule
            provides information about the category of the root as well as a composite of the daughter categories.
            
            @author Christopher Manning
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.LabeledScoredTreeNode._label">
            <summary>
            Label of the parse tree.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.LabeledScoredTreeNode._score">
            <summary>
            Score of <code>TreeNode</code>
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.LabeledScoredTreeNode._daughterTrees">
            <summary>
            Daughters of the parse tree.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.LabeledScoredTreeNode.#ctor">
            <summary>
            Create an empty parse tree.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.LabeledScoredTreeNode.#ctor(OpenNLP.Tools.Ling.ILabel)">
            <summary>
            Create a leaf parse tree with given word.
            </summary>
            <param name="label">
            the <code>Label</code> representing the <i>word</i> for this new tree leaf.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.LabeledScoredTreeNode.#ctor(OpenNLP.Tools.Ling.ILabel,System.Double)">
            <summary>
            Create a leaf parse tree with given word and score.
            </summary>
            <param name="label">The <code>Label</code> representing the <i>word</i> for</param>
            <param name="score">The score for the node this new tree leaf.</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.LabeledScoredTreeNode.#ctor(OpenNLP.Tools.Ling.ILabel,System.Collections.Generic.List{OpenNLP.Tools.Trees.Tree})">
            <summary>
            Create parse tree with given root and array of daughter trees.
            </summary>
            <param name="label">root label of tree to construct.</param>
            <param name="daughterTreesList">List of daughter trees to construct.</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.LabeledScoredTreeNode.Children">
            <summary>
            Returns an array of children for the current node, or null if it is a leaf.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.LabeledScoredTreeNode.SetChildren(OpenNLP.Tools.Trees.Tree[])">
            <summary>
            Sets the children of this <code>Tree</code>.
            If given <code>null</code>, this method sets the Tree's children to
            the canonical zero-length Tree[] array.
            </summary>
            <param name="children">An array of child trees</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.LabeledScoredTreeNode.Label">
            <summary>
            Returns the label associated with the current node, or null if there is no label
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.LabeledScoredTreeNode.SetLabel(OpenNLP.Tools.Ling.ILabel)">
            <summary>
            Sets the label associated with the current node, if there is one.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.LabeledScoredTreeNode.Score">
            <summary>
            Returns the score associated with the current node, or Nan if there is no score
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.LabeledScoredTreeNode.SetScore(System.Double)">
            <summary>
            Sets the score associated with the current node, if there is one
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.LabeledScoredTreeNode.TreeFactory">
            <summary>
            Return a <code>TreeFactory</code> that produces trees of the
            same type as the current <code>Tree</code>.  That is, this
            implementation, will produce trees of type
            <code>LabeledScoredTree(Node|Leaf)</code>.
            The <code>Label</code> of <code>this</code>
            is examined, and providing it is not <code>null</code>, a
            <code>LabelFactory</code> which will produce that kind of
            <code>Label</code> is supplied to the <code>TreeFactory</code>.
            If the <code>Label</code> is <code>null</code>, a
            <code>StringLabelFactory</code> will be used.
            The factories returned on different calls a different: a new one is
            allocated each time.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.LabeledScoredTreeNode.Factory">
            <summary>
            Return a <code>TreeFactory</code> that produces trees of the
            <code>LabeledScoredTree{Node|Leaf}</code> type.
            The factory returned is always the same one (a singleton).
            </summary>
            <returns>a factory to produce labeled, scored trees</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.LabeledScoredTreeNode.Factory(OpenNLP.Tools.Ling.ILabelFactory)">
            <summary>
            Return a <code>TreeFactory</code> that produces trees of the
            <code>LabeledScoredTree{Node|Leaf}</code> type, with
            the <code>Label</code> made with the supplied <code>LabelFactory</code>.
            The factory returned is a different one each time
            </summary>
            <param name="lf">The LabelFactory to use</param>
            <returns>a factory to produce labeled, scored trees</returns>
        </member>
        <member name="T:OpenNLP.Tools.Trees.LabeledScoredTreeReaderFactory">
            <summary>
            This class implements a <code>TreeReaderFactory</code> that produces
            labeled, scored array-based Trees, which have been cleaned up to
            delete empties, etc.   This seems to be a common case (for English).
            By default, the labels are of type CategoryWordTag,
            but a different Label type can be specified by the user.
            
            @author Christopher Manning
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.LabeledScoredTreeReaderFactory.#ctor">
            <summary>
            Create a new TreeReaderFactory with CoreLabel labels.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.LabeledScoredTreeReaderFactory.NewTreeReader(System.IO.TextReader)">
            <summary>
            An implementation of the <code>TreeReaderFactory</code> interface.
            It creates a <code>TreeReader</code> which normalizes trees using
            the <code>BobChrisTreeNormalizer</code>, and makes
            <code>LabeledScoredTree</code> objects with
            <code>CategoryWordTag</code> labels (unless otherwise specified on
            construction).
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.ModCollinsHeadFinder">
            <summary>
            Implements a variant on the HeadFinder found in Michael Collins' 1999
            thesis. This starts with Collins' head finder. As in {@code CollinsHeadFinder}, 
            we've added a head rule for NX.
            
            Changes:
            <ol>
            <li>The PRN rule used to just take the leftmost thing, we now have it
            choose the leftmost lexical category (not the common punctuation etc.)</li>
            <li>Delete IN as a possible head of S, and add FRAG (low priority)</li>
            <li>Place NN before QP in ADJP head rules (more to do for ADJP!)</li>
            <li>Place PDT before RB and after CD in QP rules.  Also prefer CD to
            DT or RB.  And DT to RB.</li>
            <li>Add DT, WDT as low priority choice for head of NP. Add PRP before PRN
            Add RBR as low priority choice of head for NP.</li>
            <li>Prefer NP or NX as head of NX, and otherwise default to rightmost not
            leftmost (NP-like headedness)</li>
            <li>VP: add JJ and NNP as low priority heads (many tagging errors)
            Place JJ above NP in priority, as it is to be preferred to NP object.</li>
            <li>PP: add PP as a possible head (rare conjunctions)</li>
            <li>Added rule for POSSP (can be introduced by parser)</li>
            <li>Added a sensible-ish rule for X.</li>
            <li>Added NML head rules, which are the same as for NP.</li>
            <li>NP head rule: NP and NML are treated almost identically (NP has precedence)</li>
            <li>NAC head rule: NML comes after NN/NNS but after NNP/NNPS</li>
            <li>PP head rule: JJ added</li>
            <li>Added JJP (appearing in David Vadas's annotation), which seems to play the same role as ADJP.</li>
            </ol>
            These rules are suitable for the Penn Treebank.
            
            A case that you apparently just can't handle well in this framework is
            (NP (NP ... NP)).  If this is a conjunction, apposition or similar, then
            the leftmost NP is the head, but if the first is a measure phrase like
            (NP $ 38) (NP a share) then the second should probably be the head.
            
            @author Christopher Manning
            @author Michel Galley
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.NamedDependency">
            <summary>
            An individual dependency between a head and a dependent.
            The head and dependent are represented as a Label.
            For example, these can be a Word or a WordTag.
            If one wishes the dependencies to preserve positions in a sentence, 
            then each can be a NamedConstituent. 
            
            @author Christopher Manning
            @author Spence Green
            
            Code ...
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.NamedDependency.ToString(System.String)">
            <summary>
            Provide different printing options via a string keyword.
            The recognized options are currently "xml", and "predicate".
            Otherwise the default ToString() is used.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.NamedDependency.NamedDependencyFactory">
            <summary>
            A <code>DependencyFactory</code> acts as a factory for creating objects
            of class <code>Dependency</code>
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.NamedDependency.NamedDependencyFactory.NewDependency(OpenNLP.Tools.Ling.ILabel,OpenNLP.Tools.Ling.ILabel)">
            <summary>
            Create a new <code>Dependency</code>.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.NamedDependency.NamedDependencyFactory.NewDependency(OpenNLP.Tools.Ling.ILabel,OpenNLP.Tools.Ling.ILabel,System.Object)">
            <summary>
            Create a new <code>Dependency</code>.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.PennTreebankLanguagePack">
            <summary>
            Specifies the treebank/language specific components needed for
            parsing the English Penn Treebank.
            
            @author Christopher Manning
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.PennTreebankLanguagePack.AnnotationIntroducingChars">
            <summary>
            The first 3 are used by the Penn Treebank; # is used by the
            BLLIP corpus, and ^ and ~ are used by Klein's lexparser.
            Teg added _ (let me know if it hurts).
            John Bauer added [ on account of category annotations added when
            printing out lexicalized dependencies.  Note that ] ought to be
            unnecessary, since it would end the annotation, not start it.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.PennTreebankLanguagePack.PennStartSymbols">
            <summary>
            This is valid for "BobChrisTreeNormalizer" conventions only.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.PennTreebankLanguagePack.PunctuationTags">
            <summary>
            Returns a string array of punctuation tags for this treebank/language.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.PennTreebankLanguagePack.PunctuationWords">
            <summary>
            Returns a string array of punctuation words for this treebank/language.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.PennTreebankLanguagePack.SentenceFinalPunctuationTags">
            <summary>
            Returns a string array of sentence readonly punctuation tags for this treebank/language.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.PennTreebankLanguagePack.SentenceFinalPunctuationWords">
            <summary>
            Returns a string array of sentence readonly punctuation words for this treebank/language.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.PennTreebankLanguagePack.EvalBIgnoredPunctuationTags">
            <summary>
            Returns a string array of punctuation tags that EVALB-style evaluation
            should ignore for this treebank/language.
            Traditionally, EVALB has ignored a subset of the total set of
            punctuation tags in the English Penn Treebank (quotes and
            period, comma, colon, etc., but not brackets)
            </summary>
            <returns>Whether this is a EVALB-ignored punctuation tag</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.PennTreebankLanguagePack.LabelAnnotationIntroducingCharacters">
            <summary>
            Return an array of characters at which a string should be
            truncated to give the basic syntactic category of a label.
            The idea here is that Penn treebank style labels follow a syntactic
            category with various functional and crossreferencing information
            introduced by special characters (such as "NP-SBJ=1").  This would
            be truncated to "NP" by the array containing '-' and "=".
            </summary>
            <returns>An array of characters that set off label name suffixes</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.PennTreebankLanguagePack.StartSymbols">
            <summary>
            Returns a string array of treebank start symbols.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.PennTreebankLanguagePack.GetTokenizerFactory">
             Returns a factory for {@link PTBTokenizer}.
            
             @return A tokenizer
        </member>
        <member name="M:OpenNLP.Tools.Trees.PennTreebankLanguagePack.TreebankFileExtension">
            <summary>
            Returns the extension of treebank files for this treebank.
            This is "mrg".
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.PennTreebankLanguagePack.GrammaticalStructureFactory">
            <summary>
            Return a GrammaticalStructure suitable for this language/treebank.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.PennTreebankLanguagePack.SupportsGrammaticalStructures">
             Return a GrammaticalStructure suitable for this language/treebank.
             <i>Note:</i> This is loaded by reflection so basic treebank use does not require all the Stanford Dependencies code.
            
             @return A GrammaticalStructure suitable for this language/treebank.
        </member>
        <member name="T:OpenNLP.Tools.Trees.PennTreebankTokenizer">
            <summary>
            Builds a tokenizer for English PennTreebank (release 2) trees.
            This is currently internally implemented via a java.io.StreamTokenizer.
            
            @author Christopher Manning
            @author Roger Levy
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.PennTreebankTokenizer.EnglishTreebankStreamTokenizer">
            <summary>
            A StreamTokenizer for PennTreebank trees.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.PennTreebankTokenizer.EnglishTreebankStreamTokenizer.#ctor(System.IO.TextReader)">
            <summary>
            Create a StreamTokenizer for PennTreebank trees.
            This sets up all the character meanings for treebank trees
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.PennTreeReader">
            <summary>
            This class implements the <code>TreeReader</code> interface to read Penn Treebank-style
            files. The reader is implemented as a push-down automaton (PDA) that parses the Lisp-style
            format in which the trees are stored. This reader is compatible with both PTB
            and PATB trees.
            
            One small detail to note is that the <code>PennTreeReader</code>
            silently replaces \* with * and \/ with /.  Two possible designs
            for this were to make the <code>PennTreeReader</code> always do
            this or to make the <code>TreeNormalizers</code> do this.  We
            decided to put it in the <code>PennTreeReader</code> class itself
            to avoid the problem of people making new
            <code>TreeNormalizers</code> and forgetting to include the unescaping.
            
            @author Christopher Manning
            @author Roger Levy
            @author Spence Green
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.PennTreeReader.#ctor(System.IO.TextReader)">
            <summary>
            Read parse trees from a <code>Reader</code>.
            For the defaulted arguments, you get a
            <code>SimpleTreeFactory</code>, no <code>TreeNormalizer</code>, and
            a <code>PennTreebankTokenizer</code>.
            </summary>
            <param name="input">The <code>Reader</code></param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.PennTreeReader.#ctor(System.IO.TextReader,OpenNLP.Tools.Trees.ITreeFactory)">
            <summary>
            Read parse trees from a <code>Reader</code>.
            </summary>
            <param name="input">the Reader</param>
            <param name="tf">TreeFactory -- factory to create some kind of Tree</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.PennTreeReader.#ctor(System.IO.TextReader,OpenNLP.Tools.Trees.ITreeFactory,OpenNLP.Tools.Trees.TreeNormalizer)">
            <summary>
            Read parse trees from a Reader.
            </summary>
            <param name="input">The Reader</param>
            <param name="tf">TreeFactory -- factory to create some kind of Tree</param>
            <param name="tn">the method of normalizing trees</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.PennTreeReader.#ctor(System.IO.TextReader,OpenNLP.Tools.Trees.ITreeFactory,OpenNLP.Tools.Trees.TreeNormalizer,OpenNLP.Tools.Util.Process.ITokenizer{System.String})">
            <summary>
            Read parse trees from a Reader.
            </summary>
            <param name="input">The Reader</param>
            <param name="tf">TreeFactory -- factory to create some kind of Tree</param>
            <param name="tn">the method of normalizing trees</param>
            <param name="st">Tokenizer that divides up Reader</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.PennTreeReader.ReadTree">
            <summary>
            Reads a single tree in standard Penn Treebank format from the
            input stream. The method supports additional parentheses around the
            tree (an unnamed ROOT node) so long as they are balanced. If the token stream
            ends before the current tree is complete, then the method will throw an
            <code>IOException</code>.
            
            Note that the method will skip malformed trees and attempt to
            read additional trees from the input stream. It is possible, however,
            that a malformed tree will corrupt the token stream. In this case,
            an <code>IOException</code> will eventually be thrown.
            </summary>
            <returns>A single tree, or <code>null</code> at end of token stream.</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.PennTreeReader.Close">
            <summary>
            Closes the underlying <code>Reader</code> used to create this class.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.PennTreeReaderFactory">
            <summary>
            Vends {@link PennTreeReader} objects.
            
            @author Roger Levy (rog@nlp.stanford.edu)
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.PennTreeReaderFactory.#ctor">
            <summary>
            Default constructor; uses a {@link LabeledScoredTreeFactory},
            with StringLabels, a {@link PennTreebankTokenizer}, and a {@link TreeNormalizer}.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.PennTreeReaderFactory.#ctor(OpenNLP.Tools.Trees.ITreeFactory)">
            <summary>
            Specify your own {@link TreeFactory};
            uses a {@link PennTreebankTokenizer}, and a {@link TreeNormalizer}.
            </summary>
            <param name="tf">The TreeFactory to use in building Tree objects to return</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.PennTreeReaderFactory.#ctor(OpenNLP.Tools.Trees.TreeNormalizer)">
            <summary>
            Specify your own {@link TreeNormalizer};
            uses a {@link PennTreebankTokenizer}, and a {@link LabeledScoredTreeFactory}.
            </summary>
            <param name="tn">The TreeNormalizer to use in building Tree objects to return</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.PennTreeReaderFactory.#ctor(OpenNLP.Tools.Trees.ITreeFactory,OpenNLP.Tools.Trees.TreeNormalizer)">
            <summary>
            Specify your own {@link TreeFactory};
            uses a {@link PennTreebankTokenizer}, and a {@link TreeNormalizer}.
            </summary>
            <param name="tf">The TreeFactory to use in building Tree objects to return</param>
            <param name="tn">The TreeNormalizer to use</param>
        </member>
        <member name="T:OpenNLP.Tools.Trees.QpTreeTransformer">
            <summary>
            Transforms an English structure parse tree in order to get the dependencies right:
            Adds an extra structure in QP phrases:
            (QP (RB well) (IN over) (CD 9)) becomes
            (QP (XS (RB well) (IN over)) (CD 9))
            (QP (...) (CC ...) (...)) becomes
            (QP (NP ...) (CC ...) (NP ...))
            
            @author mcdm
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.QpTreeTransformer.TransformTree(OpenNLP.Tools.Trees.Tree)">
            <summary>
            Right now (Jan 2013) we only deal with the following QP structures:
            <ul>
            <li> NP (QP ...) (QP (CC and/or) ...)</li>
            <li> QP (RB IN CD|DT ...)   well over, more than</li>
            <li> QP (JJR IN CD|DT ...)  fewer than</li>
            <li> QP (IN JJS CD|DT ...)  at least</li>
            <li> QP (... CC ...)        between 5 and 10</li>
            </ul>
            </summary>
            <param name="t">tree to be transformed</param>
            <returns>
            The tree t with an extra layer if there was a QP structure matching the ones mentioned above
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.QpTreeTransformer.QpTransform(OpenNLP.Tools.Trees.Tree)">
            <summary>
            Transforms t if it contains one of the following QP structure:
            <ul>
            <li> NP (QP ...) (QP (CC and/or) ...)</li>
            <li> QP (RB IN CD|DT ...)   well over, more than</li>
            <li> QP (JJR IN CD|DT ...)  fewer than</li>
            <li> QP (IN JJS CD|DT ...)  at least</li>
            <li> QP (... CC ...)        between 5 and 10</li>
            </ul>
            </summary>
            <param name="t">a tree to be transformed</param>
            <returns>t transformed</returns>
        </member>
        <member name="T:OpenNLP.Tools.Trees.SemanticHeadFinder">
            <summary>
            Implements a 'semantic head' variant of the the HeadFinder found
            in Michael Collins' 1999 thesis.
            This version chooses the semantic head verb rather than the verb form
            for cases with verbs.  And it makes similar themed changes to other
            categories: e.g., in question phrases, like "Which Brazilian game", the
            head is made "game" not "Which" as in common PTB head rules.<p/>
            
            By default the SemanticHeadFinder uses a treatment of copula where the
            complement of the copula is taken as the head.  That is, a sentence like
            "Bill is big" will be analyzed as
            
            <code>nsubj</code>(big, Bill)
            <code>cop</code>(big, is)
            
            This analysis is used for questions and declaratives for adjective
            complements and declarative nominal complements.  However Wh-sentences
            with nominal complements do not receive this treatment.
            "Who is the president?" is analyzed with "the president" as nsubj and "who"
            as "attr" of the copula:
            <code>nsubj</code>(is, president)
            <code>attr</code>(is, Who)
            
            (Such nominal copula sentences are complex: arguably, depending on the
            circumstances, several analyses are possible, with either the overt NP able
            to be any of the subject, the predicate, or one of two referential entities
            connected by an equational copula.  These uses aren't differentiated.)
            
            Existential sentences are treated as follows:
            "There is a man"
            <code>expl</code>(is, There) <br/>
            <code>det</code>(man-4, a-3) <br/>
            <code>nsubj</code>(is-2, man-4)<br/>
            
            @author John Rappaport
            @author Marie-Catherine de Marneffe
            @author Anna Rafferty
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.SemanticHeadFinder.#ctor(OpenNLP.Tools.Trees.AbstractTreebankLanguagePack,System.Boolean)">
            <summary>
            Create a SemanticHeadFinder
            </summary>
            <param name="tlp">
            The TreebankLanguagePack, used by the superclass to get basic category of constituents
            </param>
            <param name="noCopulaHead">
            If true, a copular verb (be, seem, appear, stay, remain, resemble, become)
            is not treated as head when it has an AdjP or NP complement.  If false,
            a copula verb is still always treated as a head.  But it will still
            be treated as an auxiliary in periphrastic tenses with a VP complement.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.SemanticHeadFinder.RuleChanges">
            <summary>
            Makes modifications of Collins' rules to better fit with semantic notions of heads
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.SemanticHeadFinder.PostOperationFix(System.Int32,OpenNLP.Tools.Trees.Tree[])">
            <summary>
            Overwrite the postOperationFix method.  For "a, b and c" or similar: we want "a" to be the head.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.SemanticHeadFinder.RemoveTmpAndAdv">
            <summary>
            We use this to avoid making a -TMP or -ADV the head of a copular phrase.
            For example, in the sentence "It is hands down the best dessert ...",
            we want to avoid using "hands down" as the head.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.SemanticHeadFinder.DetermineNonTrivialHead(OpenNLP.Tools.Trees.Tree,OpenNLP.Tools.Trees.Tree)">
            <summary>
            Determine which daughter of the current parse tree is the head.
            It assumes that the daughters already have had their heads determined.
            Uses special rule for VP heads
            </summary>
            <param name="t">
            The parse tree to examine the daughters of.
            This is assumed to never be a leaf
            </param>
            <returns>The parse tree that is the head</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.SemanticHeadFinder.IsExistential(OpenNLP.Tools.Trees.Tree,OpenNLP.Tools.Trees.Tree)">
            <summary>
            Checks whether the tree t is an existential constituent
            There are two cases:
            -- affirmative sentences in which "there" is a left sister of the VP
            -- questions in which "there" is a daughter of the SQ.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.SemanticHeadFinder.IsWhQ(OpenNLP.Tools.Trees.Tree,OpenNLP.Tools.Trees.Tree)">
            <summary>
            Is the tree t a WH-question?
            At present this is only true if the tree t is a SQ having a WH.* sister and headed by a SBARQ.
            (It was changed to looser definition in Feb 2006.)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.SemanticHeadFinder.IsVerbalAuxiliary(OpenNLP.Tools.Trees.Tree)">
            <summary>
            Returns true if this tree is a preterminal that is a verbal auxiliary.
            </summary>
            <param name="t">A tree to examine for being an auxiliary.</param>
            <returns>Whether it is a verbal auxiliary (be, do, have, get)</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.SemanticHeadFinder.HasVerbalAuxiliary(OpenNLP.Tools.Trees.Tree[],OpenNLP.Tools.Util.Set{System.String},System.Boolean)">
            <summary>
            This looks to see whether any of the children is a preterminal headed by a word
            which is within the set verbalSet (which in practice is either
            auxiliary or copula verbs).  It only returns true if it's a preterminal head, since
            you don't want to pick things up in phrasal daughters.  That is an error.
            </summary>
            <param name="kids">The child trees</param>
            <param name="verbalSet">The set of words</param>
            <param name="allowTagOnlyMatch">
            If true, it's sufficient to match on an unambiguous auxiliary tag.
            Make true iff verbalSet is "all auxiliaries"
            </param>
            <returns>
            true if one of the child trees is a preterminal verb headed by a word in verbalSet
            </returns>
        </member>
        <member name="T:OpenNLP.Tools.Trees.SimpleConstituent">
            <summary>
            A <code>SimpleConstituent</code> object defines a generic edge in a graph.
            The <code>SimpleConstituent</code> records only the endpoints of the
            <code>Constituent</code>, as two integers.
            It doesn't label the edges.
            (It doesn't implement equals() since this actually decreases
            performance on a non-final class (requires dynamic resolution of which to call).)
            
            @author Christopher Manning
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.SimpleConstituent._start">
            <summary>
            Left node of edge
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.SimpleConstituent._end">
            <summary>
            End node of edge
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.SimpleConstituent.#ctor">
            <summary>
            Create an empty <code>SimpleConstituent</code> object
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.SimpleConstituent.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a <code>SimpleConstituent</code> object with given values
            </summary>
            <param name="start">start node of edge</param>
            <param name="end">end node of edge</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.SimpleConstituent.Start">
            <summary>
            access start node
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.SimpleConstituent.SetStart(System.Int32)">
            <summary>
            set start node
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.SimpleConstituent.End">
            <summary>
            access end node
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.SimpleConstituent.SetEnd(System.Int32)">
            <summary>
            set end node
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.SimpleConstituent.SimpleConstituentLabelFactory">
            <summary>
            A <code>SimpleConstituentLabelFactory</code> object makes a
            <code>StringLabel</code> <code>LabeledScoredConstituent</code>.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.SimpleConstituent.LabelFactory">
            <summary>
            Return a factory for this kind of label.
            The factory returned is always the same one (a singleton)
            </summary>
            <returns>the label factory</returns>
        </member>
        <member name="T:OpenNLP.Tools.Trees.SimpleConstituent.ConstituentFactoryHolder.SimpleConstituentFactory">
            <summary>
            A <code>SimpleConstituentFactory</code> acts as a factory for
            creating objects of class <code>SimpleConstituent</code>.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.SimpleConstituent.ConstituentFactory">
            <summary>
            Return a factory for this kind of constituent.
            The factory returned is always the same one (a singleton).
            </summary>
            <returns>The constituent factory</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.SimpleConstituent.Factory">
            <summary>
            Return a factory for this kind of constituent.
            The factory returned is always the same one (a singleton).
            </summary>
            <returns>The constituent factory</returns>
        </member>
        <member name="T:OpenNLP.Tools.Trees.SimpleConstituentFactory">
            <summary>
            A <code>ConstituentFactory</code> acts as a factory for creating objects
            of class <code>Constituent</code>, or some descendent class.
            
            @author Christopher Manning
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.SimpleTree">
            <summary>
            A <code>SimpleTree</code> is a minimal concrete implementation of an
            unlabeled, unscored <code>Tree</code>.  It has a tree structure, but
            nothing is stored at a node (no label or score).
            So, most of the time, this is the wrong class to use!
            Look at {@code LabeledScoredTreeNode}.
            
            @author Christopher Manning
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.SimpleTree.daughterTrees">
            <summary>Daughters of the parse tree</summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.SimpleTree.#ctor">
            <summary>
            Create an empty parse tree
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.SimpleTree.#ctor(OpenNLP.Tools.Ling.ILabel)">
            <summary>
            Create parse tree with given root and null daughters
            </summary>
            <param name="label">root label of new tree to construct.
            For a SimpleTree this parameter is ignored</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.SimpleTree.#ctor(OpenNLP.Tools.Ling.ILabel,System.Collections.Generic.List{OpenNLP.Tools.Trees.Tree})">
            <summary>
            Create parse tree with given root and array of daughter trees
            </summary>
            <param name="label">
            root label of tree to construct.  For a SimpleTree this parameter is ignored
            </param>
            <param name="daughterTreesList">list of daughter trees to construct</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.SimpleTree.Children">
            <summary>
            Returns an array of children for the current node, or null if it is a leaf.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.SimpleTree.SetChildren(OpenNLP.Tools.Trees.Tree[])">
            <summary>
            Sets the children of this <code>Tree</code>.
            If given <code>null</code>, this method sets the Tree's children to a
            unique zero-length Tree[] array.
            </summary>
            <param name="children">An array of child trees</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.SimpleTree.TreeFactory">
            <summary>
            Return a <code>TreeFactory</code> that produces trees of the
            <code>SimpleTree</code> type.
            The factory returned is always the same one (a singleton).
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.SimpleTree.Factory">
            <summary>
            Return a <code>TreeFactory</code> that produces trees of the
            <code>SimpleTree</code> type.
            The factory returned is always the same one (a singleton).
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.SimpleTreeFactory">
            <summary>
            A {@code SimpleTreeFactory} acts as a factory for creating objects of class {@code SimpleTree}.
            
            NB: A SimpleTree stores tree geometries but no node labels.  Make sure
            this is what you really want.
            
            @author Christopher Manning
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.Tree">
            <summary>
            The abstract class <code>Tree</code> is used to collect all of the
            tree types, and acts as a generic extendable type.  This is the
            standard implementation of inheritance-based polymorphism.
            All <code>Tree</code> objects support accessors for their children (a
            <code>Tree[]</code>), their label (a <code>Label</code>), and their
            score (a <code>double</code>).  However, different concrete
            implementations may or may not include the latter two, in which
            case a default value is returned.  The class Tree defines no data
            fields.  The two abstract methods that must be implemented are:
            <code>children()</code>, and <code>treeFactory()</code>.
            Notes that <code>setChildren(Tree[])</code> is now an optional
            operation, whereas it was previously required to be
            implemented. There is now support for finding the parent of a
            tree.  This may be done by search from a tree root, or via a
            directly stored parent.  The <code>Tree</code> class now
            implements the <code>Collection</code> interface: in terms of
            this, each <i>node</i> of the tree is an element of the
            collection; hence one can explore the tree by using the methods of
            this interface.  A <code>Tree</code> is regarded as a read-only
            <code>Collection</code> (even though the <code>Tree</code> class
            has various methods that modify trees).  Moreover, the
            implementation is <i>not</i> thread-safe: no attempt is made to
            detect and report concurrent modifications.
            
            @author Christopher Manning
            @author Dan Klein
            @author Sarah Spikes (sdspikes@cs.stanford.edu) - filled in types
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.Tree.EmptyTreeArray">
            <summary>
             A leaf node should have a zero-length array for its children.
            For efficiency, classes can use this array as a return value 
            for children() for leaf nodes if desired.
            This can also be used elsewhere when you want an empty Tree array
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.IsLeaf">
            <summary>
            Says whether a node is a leaf.
            Can be used on an arbitrary <code>Tree</code>.
            Being a leaf is defined as having no children.
            This must be implemented as returning a zero-length Tree[] array for children().
            </summary>
            <returns>true if this object is a leaf</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.NumChildren">
            <summary>
            Says how many children a tree node has in its local tree.
            Can be used on an arbitrary <code>Tree</code>.  Being a leaf is defined
            as having no children.
            </summary>
            <returns>The number of direct children of the tree node</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.IsUnaryRewrite">
            <summary>
            Says whether the current node has only one child.
            Can be used on an arbitrary <code>Tree</code>
            </summary>
            <returns>Whether the node heads a unary rewrite</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.IsPreTerminal">
            <summary>
            Return whether this node is a preterminal or not.
            A preterminal is defined to be a node with one child which is itself a leaf.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.IsPrePreTerminal">
            <summary>
            Return whether all the children of this node are preterminals or not.
            A preterminal is defined to be a node with one child which is itself a leaf.
            Considered false if the node has no children
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.IsPhrasal">
            <summary>
            Return whether this node is a phrasal node or not.
            A phrasal node is defined to be a node which is not a leaf or a preterminal.
            Worded positively, this means that it must have two or more children,
            or one child that is not a leaf.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.Equals(System.Object)">
            <summary>
            Implements equality for Tree's.
            Two Tree objects are equal if they have equal {@link #value}s,
            the same number of children, and their children are pairwise equal.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.GetHashCode">
            <summary>
            Implements a hashCode for Tree's.  
            Two trees should have the same hashcode if they are equal, 
            so we hash on the label value and the children's label values.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.ObjectIndexOf(OpenNLP.Tools.Trees.Tree)">
            <summary>
            Returns the position of a Tree in the children list, if present,
            or -1 if it is not present.  Trees are checked for presence with
            object equality, ==.  Note that there are very few cases where an
            indexOf that used .equals() instead of == would be useful and
            correct.  In most cases, you want to figure out which child of
            the parent a known tree is, so looking for object equality will
            be faster and will avoid cases where you happen to have two
            subtrees that are exactly the same.
            </summary>
            <param name="tree">The tree to look for in children list</param>
            <returns>Its index in the list or -1</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.Children">
            <summary>
            Returns an array of children for the current node.
            If there are no children (if the node is a leaf), this must return a
            Tree[] array of length 0.  A null children() value for tree
            leaves was previously supported, but no longer is.
            A caller may assume that either <code>isLeaf()</code> returns
            true, or this node has a nonzero number of children.
            </summary>
            <returns>The children of the node</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.GetChildrenAsList">
            <summary>
            Returns a List of children for the current node.  If there are no
            children, then a (non-null) <code>List&lt;Tree&gt;</code> of size 0 will
            be returned.  The list has new list structure but pointers to,
            not copies of the children.  That is, the returned list is mutable,
            and simply adding to or deleting items from it is safe, but beware
            changing the contents of the children.
            </summary>
            <returns>The children of the node</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.SetChildren(OpenNLP.Tools.Trees.Tree[])">
            <summary>
            Set the children of this node to be the children given in the array.
            This is an <b>optional</b> operation; by default it is unsupported.
            Note for subclasses that if there are no children, 
            the children() method must return a Tree[] array of length 0.
            This class provides a {@code EMPTY_TREE_ARRAY} canonical zero-length Tree[] array
            to represent zero children, but it is <i>not</i> required that
            leaf nodes use this particular zero-length array to represent a leaf node.
            </summary>
            <param name="children">The array of children, each a <code>Tree</code></param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.SetChildren(System.Collections.Generic.List{OpenNLP.Tools.Trees.Tree})">
            <summary>
            Set the children of this tree node to the given list.
            This method is implemented in the <code>Tree</code> class by
            converting the <code>List</code> into a tree array and calling
            the array-based method.  Subclasses which use a
            <code>List</code>-based representation of tree children should
            override this method.  This implementation allows the case
            that the <code>List</code> is <code>null</code>: it yields a
            node with no children (represented by a canonical zero-length children() array).
            </summary>
            <param name="childTreesList">
            A list of trees to become children of the node.
            This method does not retain the List that you pass it (copying is done), 
            but it will retain the individual children (they are not copied)
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.Label">
            <summary>
            Returns the label associated with the current node, or null
            if there is no label.  The default implementation always returns {@code null}.
            </summary>
            <returns>The label of the node</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.SetLabel(OpenNLP.Tools.Ling.ILabel)">
            <summary>
            Sets the label associated with the current node, if there is one.
            The default implementation ignores the label.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.Score">
            <summary>
            Returns the score associated with the current node, 
            or NaN if there is no score.  The default implementation returns NaN.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.SetScore(System.Double)">
            <summary>
            Sets the score associated with the current node, if there is one.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.FirstChild">
            <summary>
            Returns the first child of a tree, or <code>null</code> if none.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.LastChild">
            <summary>
            Returns the last child of a tree, or <code>null</code> if none.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.UpperMostUnary(OpenNLP.Tools.Trees.Tree)">
            <summary>
            Return the highest node of the (perhaps trivial) unary chain that this node is part of.
            In case this node is the only child of its parent, trace up the chain of
            unaries, and return the uppermost node of the chain (the node whose
            parent has multiple children, or the node that is the root of the tree).
            </summary>
            <param name="root">The root of the tree that contains this subtree</param>
            <returns>
            The uppermost node of the unary chain, if this node is in a unary
            chain, or else the current node
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.SetSpans">
            <summary>
            Assign a SpanAnnotation on each node of this tree. The index starts at zero
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.Constituents">
            <summary>
            Returns the Constituents generated by the parse tree. 
            Constituents are computed with respect to whitespace (e.g., at the word level)
            </summary>
            <returns>
            a Set of the constituents as constituents of type <code>Constituent</code>
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.Constituents(OpenNLP.Tools.Trees.IConstituentFactory)">
            <summary>
            Returns the Constituents generated by the parse tree.
            The Constituents of a sentence include the preterminal categories but not the leaves.
            </summary>
            <param name="cf">ConstituentFactory used to build the Constituent objects</param>
            <returns>a Set of the constituents as SimpleConstituent type
            (in the current implementation, a <code>HashSet</code></returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.Constituents(OpenNLP.Tools.Trees.IConstituentFactory,System.Int32)">
            <summary>
            Returns the Constituents generated by the parse tree.
            The Constituents of a sentence include the preterminal categories but not the leaves.
            </summary>
            <param name="cf">ConstituentFactory used to build the Constituent objects</param>
            <param name="maxDepth">
            The maximum depth at which to add constituents, where 0 is the root level.
            Negative maxDepth indicates no maximum.
            </param>
            <returns>
            a Set of the constituents as SimpleConstituent type (in the current implementation, a <code>HashSet</code>
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.Constituents(OpenNLP.Tools.Trees.IConstituentFactory,System.Boolean)">
            <summary>
            Returns the Constituents generated by the parse tree.
            The Constituents of a sentence include the preterminal categories but not the leaves.
            </summary>
            <param name="cf">ConstituentFactory used to build the Constituent objects</param>
            <param name="charLevel">If true, compute bracketings irrespective of whitespace boundaries.</param>
            <returns>
            a Set of the constituents as SimpleConstituent type (in the current implementation, a <code>HashSet</code>
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.ConstituentsNodes(System.Int32)">
            <summary>
            Same as int constituents but just puts the span as an IntPair
            in the CoreLabel of the nodes.
            </summary>
            <param name="left">The left position to begin labeling from</param>
            <returns>The index of the right frontier of the constituent</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.Constituents(OpenNLP.Tools.Util.Set{OpenNLP.Tools.Trees.Constituent},System.Int32,OpenNLP.Tools.Trees.IConstituentFactory,System.Boolean,System.Predicate{OpenNLP.Tools.Trees.Tree},System.Int32,System.Int32)">
            <summary>
            Adds the constituents derived from <code>this</code> tree to
            the ordered <code>Constituent</code> <code>Set</code>, beginning
            numbering from the second argument and returning the number of
            the right edge.  The reason for the return of the right frontier
            is in order to produce bracketings recursively by threading through
            the daughters of a given tree.
            </summary>
            <param name="constituentsSet">set of constituents to add results of bracketing this tree to</param>
            <param name="left">left position to begin labeling the bracketings with</param>
            <param name="cf">ConstituentFactory used to build the Constituent objects</param>
            <param name="charLevel">If true, compute constituents without respect to whitespace. Otherwise, preserve whitespace boundaries</param>
            <param name="filter">A filter to use to decide whether or not to add a tree as a constituent</param>
            <param name="maxDepth">The maximum depth at which to allow constituents.  Set to negative to indicate all depths allowed.</param>
            <param name="depth">The current depth</param>
            <returns>Index of right frontier of Constituent</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.LocalTree">
            <summary>
            Returns a new Tree that represents the local Tree at a certain node.
            That is, it builds a new tree that copies the mother and daughter
            nodes (but not their Labels), as non-Leaf nodes,
            but zeroes out their children.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.LocalTrees">
            <summary>
            Returns a set of one level <code>Tree</code>s that ares the local trees
            of the tree.
            That is, it builds a new tree that copies the mother and daughter
            nodes (but not their Labels), for each phrasal node, but zeroes out their children.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.Tree.InitialPrintStringBuilderSize">
            <summary>
            Most instances of <code>Tree</code> will take a lot more than
            than the default <code>StringBuffer</code> size of 16 to print
            as an indented list of the whole tree, so we enlarge the default.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.ToStringBuilder(System.Text.StringBuilder)">
            <summary>
            Appends the printed form of a parse tree (as a bracketed String) to a {@code StringBuilder}.
            The implementation of this may be more efficient than for
            {@code ToString()} on complex trees.
            </summary>
            <param name="sb">The {@code StringBuilder} to which the tree will be appended</param>
            <returns>Returns the {@code StringBuilder} passed in with extra stuff in it</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.ToStringBuilder(System.Text.StringBuilder,System.Boolean)">
            <summary>
            Appends the printed form of a parse tree (as a bracketed String)
            to a {@code StringBuilder}.
            The implementation of this may be more efficient than for
            {@code ToString()} on complex trees.
            </summary>
            <param name="sb">The {@code StringBuilder} to which the tree will be appended</param>
            <param name="printOnlyLabelValue">If true, print only the value() of each node's label</param>
            <returns>the {@code StringBuilder} passed in with extra stuff in it</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.ToString">
            <summary>
            Converts parse tree to string in Penn Treebank format.
            
            Implementation note: Internally, the method gains
            efficiency by chaining use of a single <code>StringBuilder</code> through all the printing.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.NodeString">
            <summary>
            Returns the value of the nodes label as a string.
            This is done by calling <code>ToString()</code> on the value, if it exists.
            Otherwise, an empty string is returned.
            </summary>
            <returns>The label of a tree node as a String</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.Depth">
            <summary>
            Finds the depth of the tree.  The depth is defined as the length
            of the longest path from this node to a leaf node.  Leaf nodes
            have depth zero.  POS tags have depth 1. Phrasal nodes have
            depth >= 2.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.Depth(OpenNLP.Tools.Trees.Tree)">
            <summary>
            Finds the distance from this node to the specified node.
            return -1 if this is not an ancestor of node.
            </summary>
            <param name="node">A subtree contained in this tree</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.HeadTerminal(OpenNLP.Tools.Trees.IHeadFinder,OpenNLP.Tools.Trees.Tree)">
            <summary>
            Returns the tree leaf that is the head of the tree.
            </summary>
            <param name="hf">The head-finding algorithm to use</param>
            <param name="parent">The parent of this tree</param>
            <returns>The head tree leaf if any, else <code>null</code></returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.HeadTerminal(OpenNLP.Tools.Trees.IHeadFinder)">
            <summary>
            Returns the tree leaf that is the head of the tree
            </summary>
            <param name="hf">The headfinding algorithm to use</param>
            <returns>The head tree leaf if any, else <code>null</code></returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.HeadPreTerminal(OpenNLP.Tools.Trees.IHeadFinder)">
            <summary>
            Returns the preterminal tree that is the head of the tree.
            See {@link #isPreTerminal()} for
            the definition of a preterminal node. Beware that some tree nodes may
            have no preterminal head.
            </summary>
            <param name="hf">The headfinding algorithm to use</param>
            <returns>The head preterminal tree, if any, else <code>null</code></returns>
            <exception cref="T:System.ArgumentException">if called on a leaf node</exception>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.PercolateHeadAnnotations(OpenNLP.Tools.Trees.IHeadFinder)">
            <summary>
            Finds the head words of each tree and assigns HeadWordAnnotation
            to each node pointing to the correct node.  This relies on the
            nodes being CoreLabels, so it throws an IllegalArgumentException
            if this is ever not true.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.PercolateHeads(OpenNLP.Tools.Trees.IHeadFinder)">
            <summary>
            Finds the heads of the tree.  This code assumes that the label
            does store and return sensible values for the category, word, and tag.
            It will be a no-op otherwise.  The tree is modified.  The routine
            assumes the Tree has word leaves and tag preterminals, and copies
            their category to word and tag respectively, if they have a null value.
            </summary>
            <param name="hf">The headfinding algorithm to use</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.Dependencies">
            <summary>
            Return a Set of TaggedWord-TaggedWord dependencies, represented as
            Dependency objects, for the Tree.  This will only give
            useful results if the internal tree node labels support HasWord and
            HasTag, and head percolation has already been done (see percolateHeads()).
            </summary>
            <returns>Set of dependencies (each a Dependency)</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.MakeDependencyLabel(OpenNLP.Tools.Ling.ILabel,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Convert a constituency label to a dependency label. Options are provided for selecting annotations to copy.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.Dependencies(System.Predicate{OpenNLP.Tools.Trees.IDependency{OpenNLP.Tools.Ling.ILabel,OpenNLP.Tools.Ling.ILabel,System.Object}},System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Return a set of TaggedWord-TaggedWord dependencies, represented as
            Dependency objects, for the Tree.  This will only give
            useful results if the internal tree node labels support HasWord and
            head percolation has already been done (see percolateHeads()).
            </summary>
            <param name="f">
            Dependencies are excluded for which the Dependency is not accepted by the Filter
            </param>
            <returns>Set of dependencies (each a Dependency)</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.MapDependencies(System.Predicate{OpenNLP.Tools.Trees.IDependency{OpenNLP.Tools.Ling.ILabel,OpenNLP.Tools.Ling.ILabel,System.Object}},OpenNLP.Tools.Trees.IHeadFinder)">
            <summary>
            Return a set of Label-Label dependencies, represented as
            Dependency objects, for the Tree.  The Labels are the ones of the leaf
            nodes of the tree, without mucking with them.
            </summary>
            <param name="f">
            Dependencies are excluded for which the Dependency is not accepted by the Filter
            </param>
            <param name="hf">
            The HeadFinder to use to identify the head of constituents.
            The code assumes that it can use <code>headPreTerminal(hf)</code> to find a
            tag and word to make a CoreLabel.
            </param>
            <returns>
            Set of dependencies (each a <code>Dependency</code> between two
            <code>CoreLabel</code>s, which each contain a tag(), word(),
            and value(), the last two of which are identical).
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.MapDependencies(System.Predicate{OpenNLP.Tools.Trees.IDependency{OpenNLP.Tools.Ling.ILabel,OpenNLP.Tools.Ling.ILabel,System.Object}},OpenNLP.Tools.Trees.IHeadFinder,System.String)">
            <summary>
            Return a set of Label-Label dependencies, represented as
            Dependency objects, for the Tree.  The Labels are the ones of the leaf
            nodes of the tree, without mucking with them. The head of the sentence is a
            dependent of a synthetic "root" label.
            </summary>
            <param name="f">Dependencies are excluded for which the Dependency is not accepted by the Filter</param>
            <param name="hf">
            The HeadFinder to use to identify the head of constituents.
            The code assumes that it can use <code>headPreTerminal(hf)</code> to find a tag and word to make a CoreLabel.
            </param>
            <param name="rootName">rootName Name of the root node</param>
            <returns>
            Set of dependencies (each a <code>Dependency</code> between two
            <code>CoreLabel</code>s, which each contain a tag(), word(),
            and value(), the last two of which are identical).
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.Yield">
            <summary>
            Gets the yield of the tree.  The <code>Label</code> of all leaf nodes
            is returned as a list ordered by the natural left to right order of the
            leaves.  Null values, if any, are inserted into the list like any other value.
            </summary>
            <returns>a <code>List</code> of the data in the tree's leaves</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.Yield(System.Collections.Generic.List{OpenNLP.Tools.Ling.ILabel})">
            <summary>
            Gets the yield of the tree.  The <code>Label</code> of all leaf nodes
            is returned as a list ordered by the natural left to right order of the
            leaves.  Null values, if any, are inserted into the list like any other value.
            
            <i>Implementation notes:</i> c. 2003: This has been rewritten to thread, so only one List
            is used. 2007: This method was duplicated to start to give type safety to Sentence.
            This method will now make a Word for any Leaf which does not itself implement HasWord, and
            put the Word into the Sentence, so the Sentence elements MUST implement HasWord.
            </summary>
            <param name="y">
            The list in which the yield of the tree will be placed.
            Normally, this will be empty when the routine is called, 
            but if not, the new yield is added to the end of the list.
            </param>
            <returns>a <code>List</code> of the data in the tree's leaves.</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.Yield``1(System.Collections.Generic.List{``0})">
            <summary>
            Gets the yield of the tree.  The <code>Label</code> of all leaf nodes is returned
            as a list ordered by the natural left to right order of the
            leaves.  Null values, if any, are inserted into the list like any
            other value.  This has been rewritten to thread, so only one List is used.
            </summary>
            <param name="y">
            The list in which the yield of the tree will be placed.
            Normally, this will be empty when the routine is called, 
            but if not, the new yield is added to the end of the list.
            </param>
            <returns>a <code>List</code> of the data in the tree's leaves.</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.TaggedYield">
            <summary>
            Gets the tagged yield of the tree.
            The <code>Label</code> of all leaf nodes is returned
            as a list ordered by the natural left to right order of the
            leaves.  Null values, if any, are inserted into the list like any other value.
            </summary>
            <returns>a <code>List</code> of the data in the tree's leaves</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.TaggedYield(System.Collections.Generic.List{OpenNLP.Tools.Ling.TaggedWord})">
            <summary>
            Gets the tagged yield of the tree -- that is, get the preterminals
            as well as the terminals.  The <code>Label</code> of all leaf nodes
            is returned as a list ordered by the natural left to right order of the
            leaves.  Null values, if any, are inserted into the list like any
            other value.  This has been rewritten to thread, so only one List is used.
            
            <i>Implementation note:</i> when we summon up enough courage, this
            method will be changed to take and return a List of TaggedWord.
            </summary>
            <param name="ty">
            The list in which the tagged yield of the tree will be placed. 
            Normally, this will be empty when the routine is called, 
            but if not, the new yield is added to the end of the list.
            </param>
            <returns>a <code>List</code> of the data in the tree's leaves</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.PreTerminalYield">
            <summary>
            Gets the preterminal yield (i.e., tags) of the tree.
            All data in preterminal nodes is returned as a list ordered by the natural left to right order of the tree.
            Null values, if any, are inserted into the list like any other value.  Pre-leaves are nodes of height 1.
            </summary>
            <returns>a {@code List} of the data in the tree's pre-leaves</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.PreTerminalYield(System.Collections.Generic.List{OpenNLP.Tools.Ling.ILabel})">
            <summary>
            Gets the preterminal yield (i.e., tags) of the tree.
            All data in preleaf nodes is returned as a list ordered by the natural left to right order of the tree.
            Null values, if any, are inserted into the list like any other value.  Pre-leaves are nodes of height 1.
            </summary>
            <param name="y">
            The list in which the preterminals of the tree will be placed.
            Normally, this will be empty when the routine is called, 
            but if not, the new yield is added to the end of the list.
            </param>
            <returns>a <code>List</code> of the data in the tree's pre-leaves</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.GetLeaves">
            <summary>
            Gets the leaves of the tree.
            All leaves nodes are returned as a list ordered by the natural left to right order of the tree.
            Null values, if any, are inserted into the list like any other value.
            </summary>
            <returns>a <code>List</code> of the leaves</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.GetLeaves(System.Collections.Generic.List{OpenNLP.Tools.Trees.Tree})">
            <summary>
            Gets the leaves of the tree.
            </summary>
            <param name="list">
            The list in which the leaves of the tree will be placed.
            Normally, this will be empty when the routine is called,
            but if not, the new yield is added to the end of the list.
            </param>
            <returns>a <code>List</code> of the leaves</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.Labels">
            <summary>
            Get the set of all node and leaf {@code Label}s,
            null or otherwise, contained in the tree.
            </summary>
            <returns>
            The {@code Collection} (actually, Set) of all values in the tree.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.Flatten">
            <summary>
            Return a flattened version of a tree.  In many circumstances, this
            will just return the tree, but if the tree is something like a
            binarized version of a dependency grammar tree, then it will be
            flattened back to a dependency grammar tree representation.  Formally,
            a node will be removed from the tree when: it is not a terminal or
            preterminal, and its <code>label()</code> is <code>equal()</code> to
            the <code>label()</code> of its parent, and all its children will
            then be promoted to become children of the parent (in the same
            position in the sequence of daughters.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.Flatten(OpenNLP.Tools.Trees.ITreeFactory)">
            <summary>
            Return a flattened version of a tree.  In many circumstances, this
            will just return the tree, but if the tree is something like a
            binarized version of a dependency grammar tree, then it will be
            flattened back to a dependency grammar tree representation.  Formally,
            a node will be removed from the tree when: it is not a terminal or
            preterminal, and its <code>label()</code> is <code>equal()</code> to
            the <code>label()</code> of its parent, and all its children will
            then be promoted to become children of the parent (in the same
            position in the sequence of daughters.
            
            Note: In the current implementation, the tree structure is mainly
            duplicated, but the links between preterminals and terminals aren't.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.SubTrees">
            <summary>
            Get the set of all subtrees inside the tree by returning a tree
            rooted at each node.  These are <i>not</i> copies, but all share
            structure.  The tree is regarded as a subtree of itself.
            
            Note: If you only want to form this Set so that you can
            iterate over it, it is more efficient to simply use the Tree class's
            own iterator() method. This will iterate over the exact same
            elements (but perhaps/probably in a different order).
            </summary>
            <returns>the <code>Set</code> of all subtrees in the tree</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.SubTreeList">
            <summary>
            Get the list of all subtrees inside the tree by returning a tree
            rooted at each node.  These are <i>not</i> copies, but all share
            structure.  The tree is regarded as a subtree of itself.
            
            Note: If you only want to form this Collection so that you can
            iterate over it, it is more efficient to simply use the Tree class's
            own iterator() method. This will iterate over the exact same
            elements (but perhaps/probably in a different order).
            </summary>
            <returns>the <code>List</code> of all subtrees in the tree.</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.SubTrees``1(``0)">
            <summary>
            Add the set of all subtrees inside a tree (including the tree itself)
            to the given <code>Collection</code>.
            
            Note: If you only want to form this Collection so that you can
            iterate over it, it is more efficient to simply use the Tree class's
            own iterator() method. This will iterate over the exact same
            elements (but perhaps/probably in a different order).
            </summary>
            <param name="n">A collection of nodes to which the subtrees will be added.</param>
            <returns>The collection parameter with the subtrees added.</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.DeepCopy">
            <summary>
            Makes a deep copy of not only the Tree structure but of the labels as well.
            Uses the TreeFactory of the root node given by treeFactory().
            Assumes that your labels give a non-null labelFactory().
            </summary>
            <returns>A deep copy of the tree structure and its labels</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.DeepCopy(OpenNLP.Tools.Trees.ITreeFactory)">
            <summary>
            Makes a deep copy of not only the Tree structure but of the labels as well.
            The new tree will have nodes made by the given TreeFactory.
            Each Label is copied using the labelFactory() returned
            by the corresponding node's label.
            It assumes that your labels give non-null labelFactory.
            </summary>
            <param name="tf">The TreeFactory used to make all nodes in the copied tree structure</param>
            <returns>A Tree that is a deep copy of the tree structure and Labels of the original tree.</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.DeepCopy(OpenNLP.Tools.Trees.ITreeFactory,OpenNLP.Tools.Ling.ILabelFactory)">
            <summary>
            Makes a deep copy of not only the Tree structure but of the labels as well.
            Each tree is copied with the given TreeFactory.
            Each Label is copied using the given LabelFactory.
            That is, the tree and label factories can transform the nature of the data representation.
            </summary>
            <param name="tf">The TreeFactory used to make all nodes in the copied tree structure</param>
            <param name="lf">The LabelFactory used to make all nodes in the copied tree structure</param>
            <returns>A Tree that is a deep copy of the tree structure and Labels of the original tree.</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.TreeSkeletonCopy">
            <summary>
            Create a deep copy of the tree structure.
            The entire structure is recursively copied, but label data themselves are not cloned.
            The copy is built using a <code>TreeFactory</code> that will
            produce a <code>Tree</code> like the input one.
            </summary>
            <returns>A deep copy of the tree structure (but not its labels)</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.TreeSkeletonCopy(OpenNLP.Tools.Trees.ITreeFactory)">
            <summary>
            Create a deep copy of the tree structure.  The entire structure is
            recursively copied, but label data themselves are not cloned.
            By specifying an appropriate <code>TreeFactory</code>, this
            method can be used to change the type of a <code>Tree</code>.
            </summary>
            <param name="tf">The <code>TreeFactory</code> to be used for creating the returned <code>Tree</code></param>
            <returns>A deep copy of the tree structure (but not its labels).</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.Transform(OpenNLP.Tools.Trees.ITreeTransformer)">
            <summary>
            Create a transformed Tree.  The tree is traversed in a depth-first,
            left-to-right order, and the <code>TreeTransformer</code> is called
            on each node.  It returns some <code>Tree</code>.  The transformed
            tree has a new tree structure (i.e., a "deep copy" is done), but it
            will usually share its labels with the original tree.
            </summary>
            <param name="transformer">The function that transforms tree nodes or subtrees</param>
            <returns>a transformation of this <code>Tree</code></returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.Transform(OpenNLP.Tools.Trees.ITreeTransformer,OpenNLP.Tools.Trees.ITreeFactory)">
            <summary>
            Create a transformed Tree.  The tree is traversed in a depth-first,
            left-to-right order, and the <code>TreeTransformer</code> is called
            on each node.  It returns some <code>Tree</code>.  The transformed
            tree has a new tree structure (i.e., a deep copy of the structure of the tree is done), but it
            will usually share its labels with the original tree.
            </summary>
            <param name="transformer">The function that transforms tree nodes or subtrees</param>
            <param name="tf">
            The <code>TreeFactory</code> which will be used for creating new nodes for the returned <code>Tree</code>
            </param>
            <returns>a transformation of this <code>Tree</code></returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.SpliceOut(System.Predicate{OpenNLP.Tools.Trees.Tree})">
            <summary>
            Creates a (partial) deep copy of the tree, where all nodes that the
            filter does not accept are spliced out.  If the result is not a tree
            (that is, it's a forest), an empty root node is generated.
            </summary>
            <param name="nodeFilter">a Filter method which returns true to mean keep this node, false to mean delete it</param>
            <returns>a filtered copy of the tree</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.SpliceOut(System.Predicate{OpenNLP.Tools.Trees.Tree},OpenNLP.Tools.Trees.ITreeFactory)">
            <summary>
            Creates a (partial) deep copy of the tree, where all nodes that the
            filter does not accept are spliced out.  That is, the particular
            modes for which the <code>Filter</code> returns <code>false</code>
            are removed from the <code>Tree</code>, but those nodes' children
            are kept (assuming they pass the <code>Filter</code>, and they are
            added in the appropriate left-to-right ordering as new children of
            the parent node.  If the root node is deleted, so that the result
            would not be a tree (that is, it's a forest), an empty root node is
            generated.  If nothing is accepted, <code>null</code> is returned.
            </summary>
            <param name="nodeFilter">
            a Filter method which returns true to mean keep this node, false to mean delete it
            </param>
            <param name="tf">
            A <code>TreeFactory</code> for making new trees. Used if the root node is deleted.
            </param>
            <returns>a filtered copy of the tree</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.Prune(System.Predicate{OpenNLP.Tools.Trees.Tree})">
            <summary>
            Creates a deep copy of the tree, where all nodes that the filter
            does not accept and all children of such nodes are pruned.
            If all of a node's children are pruned, that node is cut as well.
            A <code>Filter</code> can assume
            that it will not be called with a <code>null</code> argument.
            
            For example, the following code excises all PP nodes from a Tree:
            <code>
            Filter{Tree} f = new Filter{Tree} {
                public bool accept(Tree t) {
                    return ! t.label().value().equals(PP);
                }
            }; 
            tree.prune(f);
            </code>
            
            If the root of the tree is pruned, null will be returned.
            </summary>
            <param name="filter">the filter to be applied</param>
            <returns>
            a filtered copy of the tree, including the possibility of
            <code>null</code> if the root node of the tree is filtered
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.Prune(System.Predicate{OpenNLP.Tools.Trees.Tree},OpenNLP.Tools.Trees.ITreeFactory)">
            <summary>
            Creates a deep copy of the tree, where all nodes that the filter
            does not accept and all children of such nodes are pruned.
            If all of a node's children are pruned, that node is cut as well.
            A <code>Filter</code> can assume
            that it will not be called with a <code>null</code> argument.
            </summary>
            <param name="filter">the filter to be applied</param>
            <param name="tf">the TreeFactory to be used to make new Tree nodes if needed</param>
            <returns>
            a filtered copy of the tree, including the possibility 
            of <code>null</code> if the root node of the tree is filtered
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.SkipRoot">
            <summary>
            Returns first child if this is unary and if the label at the current
            node is either "ROOT" or empty.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.TreeFactory">
            <summary>
            Return a <code>TreeFactory</code> that produces trees of the appropriate type.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.Parent">
            <summary>
            Return the parent of the tree node. 
            This routine may return <code>null</code> meaning simply 
            that the implementation doesn't know how to determine 
            the parent node, rather than there is no such node.
            </summary>
            <returns>The parent <code>Tree</code> node or <code>null</code></returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.Parent(OpenNLP.Tools.Trees.Tree)">
            <summary>
            Return the parent of the tree node.  This routine will traverse
            a tree (depth first) from the given <code>root</code>, and will
            correctly find the parent, regardless of whether the concrete
            class stores parents.  It will only return <code>null</code> if this
            node is the <code>root</code> node, or if this node is not
            contained within the tree rooted at <code>root</code>.
            </summary>
            <param name="root">The root node of the whole Tree</param>
            <returns>
            the parent <code>Tree</code> node if any; else <code>null</code>
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.Size">
            <summary>
            Returns the number of nodes the tree contains.
            This method implements the <code>size()</code> function required by the
            <code>Collections</code> interface.  The size of the tree is the
            number of nodes it contains (of all types, including the leaf nodes and the root).
            </summary>
            <returns>The size of the tree</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.Ancestor(System.Int32,OpenNLP.Tools.Trees.Tree)">
            <summary>
            Return the ancestor tree node <code>height</code> nodes up from the current node.
            </summary>
            <param name="height">
            How many nodes up to go. A parameter of 0 means return this node, 
            1 means to return the parent node and so on.
            </param>
            <param name="root">The root node that this Tree is embedded under</param>
            <returns>
            The ancestor at height <code>height</code>.  It returns null
            if it does not exist or the tree implementation does not keep track of parents
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.Iterator">
            <summary>
            Returns an iterator over all the nodes of the tree.
            This method implements the <code>iterator()</code> method required by the
            <code>Collections</code> interface.  It does a preorder
            (children after node) traversal of the tree.  (A possible
            extension to the class at some point would be to allow different
            traversal orderings via variant iterators.)
            </summary>
            <returns>An iterator over the nodes of the tree</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.ValueOf(System.String)">
            <summary>
            This gives you a tree from a string representation 
            (as a bracketed Tree, of the kind produced by <code>ToString()</code>,
            <code>pennPrint()</code>, or as in the Penn Treebank).
            It's not the most efficient thing to do for heavy duty usage.
            The Tree returned is created by a
            LabeledScoredTreeReaderFactory. This means that "standard"
            normalizations (stripping functional categories, indices,
            empty nodes, and A-over-A nodes) will be done on it.
            </summary>
            <param name="str">The tree as a bracketed list in a string</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.ValueOf(System.String,OpenNLP.Tools.Trees.ITreeReaderFactory)">
            <summary>
            This gives you a tree from a string representation (as a
            bracketed Tree, of the kind produced by <code>ToString()</code>,
            <code>pennPrint()</code>, or as in the Penn Treebank.
            It's not the most efficient thing to do for heavy duty usage.
            </summary>
            <param name="str">The tree as a bracketed list in a string.</param>
            <param name="trf">The TreeFactory used to make the new Tree</param>
            <returns>The Tree</returns>
            <exception cref="T:System.SystemException">If the Tree format is not valid</exception>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.GetChild(System.Int32)">
            <summary>
            Return the child at some daughter index.
            The children are numbered starting with an index of 0.
            </summary>
            <param name="i">The daughter index</param>
            <returns>The tree at that daughter index</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.RemoveChild(System.Int32)">
            <summary>
            Destructively removes the child at some daughter index and returns it.
            Note that this method will throw an {@link ArrayIndexOutOfBoundsException} if
            the daughter index is too big for the list of daughters.
            </summary>
            <param name="i">The daughter index</param>
            <returns>The tree at that daughter index</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.AddChild(System.Int32,OpenNLP.Tools.Trees.Tree)">
            <summary>
            Adds the tree t at the index position among the daughters
            Note that this method will throw an {@link ArrayIndexOutOfBoundsException} if
            the daughter index is too big for the list of daughters.
            </summary>
            <param name="i">the index position at which to add the new daughter</param>
            <param name="t">the new daughter</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.AddChild(OpenNLP.Tools.Trees.Tree)">
            <summary>
            Adds the tree t at the last index position among the daughters.
            </summary>
            <param name="t">the new daughter</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.SetChild(System.Int32,OpenNLP.Tools.Trees.Tree)">
            <summary>
            Replaces the <code>i</code>th child of <code>this</code> with the tree t.
            Note that this method will throw an {@link ArrayIndexOutOfBoundsException} if
            the child index is too big for the list of children.
            </summary>
            <param name="i">The index position at which to replace the child</param>
            <param name="t">The new child</param>
            <returns>The tree that was previously the ith d</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.Dominates(OpenNLP.Tools.Trees.Tree)">
            <summary>
            Returns true if <code>this</code> dominates the Tree passed in
            as an argument.  Object equality (==) rather than .equals() is used
            to determine domination.
            t.dominates(t) returns false.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.DominationPath(OpenNLP.Tools.Trees.Tree)">
            <summary>
            Returns the path of nodes leading down to a dominated node,
            including <code>this</code> and the dominated node itself.
            Returns null if t is not dominated by <code>this</code>.
            Object equality (==) is the relevant criterion. t.dominationPath(t) returns null.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.PathNodeToNode(OpenNLP.Tools.Trees.Tree,OpenNLP.Tools.Trees.Tree)">
            <summary>
            Given nodes <code>t1</code> and <code>t2</code> which are
            dominated by this node, returns a list of all the nodes on the
            path from t1 to t2, inclusive, or null if none found.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.JoinNode(OpenNLP.Tools.Trees.Tree,OpenNLP.Tools.Trees.Tree)">
            <summary>
            Given nodes <code>t1</code> and <code>t2</code> which are
            dominated by this node, returns their "join node": the node
            <code>j</code> such that <code>j</code> dominates both
            <code>t1</code> and <code>t2</code>, and every other node which
            dominates both <code>t1</code> and <code>t2</code>
            dominates <code>j</code>.
            In the special case that t1 dominates t2, return t1, and vice versa.
            Return <code>null</code> if no such node can be found.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.CCommands(OpenNLP.Tools.Trees.Tree,OpenNLP.Tools.Trees.Tree)">
            <summary>
            Given nodes {@code t1} and {@code t2} which are
            dominated by this node, returns {@code true} iff
            {@code t1} c-commands {@code t2}.  (A node c-commands
            its sister(s) and any nodes below its sister(s).)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.Siblings(OpenNLP.Tools.Trees.Tree)">
            <summary>
            Returns the siblings of this Tree node.
            The siblings are all children of the parent of this node except this node.
            </summary>
            <param name="root">The root within which this tree node is contained</param>
            <returns>
            The siblings as a list, an empty list if there are no siblings.
            The returned list is a modifiable new list structure, but contains the actual children.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.InsertDtr(OpenNLP.Tools.Trees.Tree,System.Int32)">
            <summary>
            Insert <code>dtr</code> after <code>position</code> existing daughters in <code>this</code>.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.LabelFactory">
            <summary>
            Returns a factory that makes labels of the same type as this one.
            May return <code>null</code> if no appropriate factory is known.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.LeftCharEdge(OpenNLP.Tools.Trees.Tree)">
            <summary>
            Returns the positional index of the left edge of  <i>node</i> within the tree,
            as measured by characters.  Returns -1 if <i>node is not found.</i>
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.RightCharEdge(OpenNLP.Tools.Trees.Tree)">
            <summary>
            Returns the positional index of the right edge of  <i>node</i> within the tree,
            as measured by characters. Returns -1 if <i>node is not found.</i>
            rightCharEdge returns the index of the rightmost character + 1, so that
            rightCharEdge(getLeaves().get(i)) == leftCharEdge(getLeaves().get(i+1))
            </summary>
            <param name="node">The subtree to look for in this Tree</param>
            <returns>The positional index of the right edge of node</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.NodeNumber(OpenNLP.Tools.Trees.Tree)">
            <summary>
            Calculates the node's <i>number</i>, defined as the number of nodes traversed in a left-to-right, 
            depth-first search of the tree starting at <code>root</code> and ending at <code>this</code>.
            Returns -1 if <code>root</code> does not contain <code>this</code>.
            </summary>
            <param name="root">the root node of the relevant tree</param>
            <returns>the number of the current node, or -1 if <code>root</code> does not contain <code>this</code></returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.GetNodeNumber(System.Int32)">
            <summary>
            Fetches the <code>i</code>th node in the tree, with node numbers defined
            as in {@link #nodeNumber(Tree)}
            </summary>
            <param name="i">the node number to fetch</param>
            <returns>the <code>i</code>th node in the tree</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.IndexLeaves">
            <summary>
            Assign sequential integer indices to the leaves of the tree
            rooted at this <code>Tree</code>, starting with 1.
            The leaves are traversed from left to right. 
            If the node is already indexed, then it uses the existing index.
            This will only work if the leaves extend CoreMap.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.IndexLeaves(System.Boolean)">
            <summary>
            Index the leaves, and optionally overwrite existing IndexAnnotations if they exist.
            </summary>
            <param name="overWrite">Whether to replace an existing index for a leaf.</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.IndexLeaves(System.Int32,System.Boolean)">
            <summary>
            Assign sequential integer indices to the leaves of the subtree
            rooted at this <code>Tree</code>, beginning with <code>startIndex</code>, 
            and traversing the leaves from left to right. 
            If node is already indexed, then it uses the existing index.
            This method only works if the labels of the tree implement CoreLabel!
            </summary>
            <param name="startIndex">index for this node</param>
            <param name="overWrite">Whether to replace an existing index for a leaf</param>
            <returns>the next index still unassigned</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.PercolateHeadIndices">
            <summary>
            Percolates terminal indices through a dependency tree. The terminals should be indexed, e.g.,
            by calling indexLeaves() on the tree.
            
            This method assumes CoreLabels!
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Tree.IndexSpans(OpenNLP.Tools.Util.MutableWrapper{System.Int32})">
            <summary>
            Assigns span indices (BeginIndexAnnotation and EndIndexAnnotation) to all nodes in a tree.
            The beginning index is equivalent to the IndexAnnotation of the first leaf in the constituent.
            The end index is equivalent to the first integer after the IndexAnnotation of the last leaf in the constituent.
            </summary>
            <param name="startIndex">Begin indexing at this value</param>
        </member>
        <member name="T:OpenNLP.Tools.Trees.TreeCoreAnnotations">
            <summary>
            Set of common annotations for {@link edu.stanford.nlp.util.CoreMap}s 
            that require classes from the trees package.  See 
            {@link edu.stanford.nlp.ling.CoreAnnotations} for more information.
            This class exists so that
            {@link edu.stanford.nlp.ling.CoreAnnotations} need not depend on
            trees classes, making distributions easier.
            
            @author Anna Rafferty
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.TreeCoreAnnotations.TreeAnnotation">
            <summary>
            The CoreMap key for getting the syntactic parse tree of a sentence.
            This key is typically set on sentence annotations.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.TreeCoreAnnotations.BinarizedTreeAnnotation">
            <summary>
            The CoreMap key for getting the binarized version of the
            syntactic parse tree of a sentence.
            This key is typically set on sentence annotations.  It is only
            set if the parser annotator was specifically set to parse with
            this (parse.saveBinarized).  The sentiment annotator requires
            this kind of tree, but otherwise it is not typically used.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.TreeCoreAnnotations.HeadWordAnnotation">
            <summary>
            The standard key for storing a head word in the map as a pointer to another node
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.TreeCoreAnnotations.HeadTagAnnotation">
            <summary>
            The standard key for storing a head tag in the map as a pointer to another node
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.TreeGraphNode">
            <summary>
            A <code>TreeGraphNode</code> is simply a
            {@link Tree <code>Tree</code>}
            with some additional functionality.  For example, the
            <code>parent()</code> method works without searching from the root.
            Labels are always assumed to be
            {@link CoreLabel <code>CoreLabel</code>}
            
            This class makes the horrible mistake of changing the semantics of
            equals and hashCode to go back to "==" and System.identityHashCode,
            despite the semantics of the superclass's equality.
            
            @author Bill MacCartney
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TreeGraphNode._label">
            <summary>
            Label for this node
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TreeGraphNode._parent">
            <summary>
            Parent of this node
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TreeGraphNode._children">
            <summary>
            Children of this node
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TreeGraphNode.tg">
            <summary>
            The {@link GrammaticalStructure <code>GrammaticalStructure</code>} of which this node is part
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TreeGraphNode.ZeroTgnChildren">
            <summary>
            A leaf node should have a zero-length array for its children. 
            For efficiency, subclasses can use this array as a return value 
            for children() for leaf nodes if desired. Should this be public instead?
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TreeGraphNode.#ctor">
            <summary>
            Create a new empty <code>TreeGraphNode</code>
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TreeGraphNode.#ctor(OpenNLP.Tools.Ling.ILabel)">
            <summary>
            Create a new <code>TreeGraphNode</code> with the supplied label
            </summary>
            <param name="label">the label for this node</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TreeGraphNode.#ctor(OpenNLP.Tools.Ling.ILabel,System.Collections.Generic.List{OpenNLP.Tools.Trees.Tree})">
            <summary>
            Create a new <code>TreeGraphNode</code> with the supplied
            label and list of child nodes
            </summary>
            <param name="label">the label for this node</param>
            <param name="children">the list of child <code>TreeGraphNode</code>s for this node</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TreeGraphNode.#ctor(OpenNLP.Tools.Trees.Tree,OpenNLP.Tools.Trees.GrammaticalStructure)">
            <summary>
            Create a new <code>TreeGraphNode</code> having the same tree
            structure and label values as an existing tree (but no shared storage)
            </summary>
            <param name="t">the tree to copy</param>
            <param name="graph">the graph of which this node is a part</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TreeGraphNode.#ctor(OpenNLP.Tools.Trees.Tree,OpenNLP.Tools.Trees.TreeGraphNode)">
            <summary>
            Create a new <code>TreeGraphNode</code> having the same tree structure 
            and label values as an existing tree (but no shared storage).
            Operates recursively to construct an entire subtree
            </summary>
            <param name="t">the tree to copy</param>
            <param name="parent">the parent node</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TreeGraphNode.Equals(System.Object)">
            <summary>
            Implements equality for <code>TreeGraphNode</code>s.
            Unlike <code>Tree</code>s, <code>TreeGraphNode</code>s should be
            considered equal only if they are ==.  <i>Implementation note:</i>
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TreeGraphNode.Label">
            <summary>
            Returns the label associated with the current node, or null if there is no label.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TreeGraphNode.SetLabel(OpenNLP.Tools.Ling.CoreLabel)">
            <summary>
            Sets the label associated with the current node
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TreeGraphNode.Index">
            <summary>
            Get the index for the current node.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TreeGraphNode.SetIndex(System.Int32)">
            <summary>
            Set the index for the current node
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TreeGraphNode.Parent">
            <summary>
            Get the parent for the current node
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TreeGraphNode.SetParent(OpenNLP.Tools.Trees.TreeGraphNode)">
            <summary>
            Set the parent for the current node
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TreeGraphNode.Children">
            <summary>
            Returns an array of the children of this node
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TreeGraphNode.SetChildren(OpenNLP.Tools.Trees.Tree[])">
            <summary>
            Sets the children of this <code>TreeGraphNode</code>.
            If given <code>null</code>, this method sets
            the node's children to the canonical zero-length Tree[] array.
            </summary>
            <param name="children">an array of child trees</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TreeGraphNode.TreeGraph">
            <summary>
            Get the <code>GrammaticalStructure</code> of which this node is a part
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TreeGraphNode.SetTreeGraph(OpenNLP.Tools.Trees.GrammaticalStructure)">
            <summary>
            Set pointer to the <code>GrammaticalStructure</code> of which this node
            is a part.  Operates recursively to set pointer for all descendants too
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TreeGraphNode.PercolateHeads(OpenNLP.Tools.Trees.IHeadFinder)">
            <summary>
            Uses the specified {@link HeadFinder <code>HeadFinder</code>}
            to determine the heads for this node and all its descendants,
            and to store references to the head word node and head tag node
            in this node's {@link CoreLabel <code>CoreLabel</code>} and the
            <code>CoreLabel</code>s of all its descendants.
            
            Note that, in contrast to {@link Tree#percolateHeads
            <code>Tree.percolateHeads()</code>}, which assumes {@link
            edu.stanford.nlp.ling.CategoryWordTag
            <code>CategoryWordTag</code>} labels and therefore stores head
            words and head tags merely as <code>string</code>s, this
            method stores references to the actual nodes.  This mitigates
            potential problems in sentences which contain the same word more than once.
            </summary>
            <param name="hf">The headfinding algorithm to use</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TreeGraphNode.HeadWordNode">
            <summary>
            Return the node containing the head word for this node (or
            <code>null</code> if none), as recorded in this node's {@link
            CoreLabel <code>CoreLabel</code>}.  (In contrast to {@link
            edu.stanford.nlp.ling.CategoryWordTag
            <code>CategoryWordTag</code>}, we store head words and head
            tags as references to nodes, not merely as <code>string</code>s.)
            </summary>
            <returns>the node containing the head word for this node</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TreeGraphNode.SetHeadWordNode(OpenNLP.Tools.Trees.TreeGraphNode)">
            <summary>
            Store the node containing the head word for this node by 
            storing it in this node's {@link CoreLabel
            <code>CoreLabel</code>}.  (In contrast to {@link
            edu.stanford.nlp.ling.CategoryWordTag
            <code>CategoryWordTag</code>}, we store head words and head
            tags as references to nodes, not merely as <code>string</code>s.)
            </summary>
            <param name="hwn">the node containing the head word for this node</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TreeGraphNode.HeadTagNode">
            <summary>
            Return the node containing the head tag for this node (or
            <code>null</code> if none), as recorded in this node's {@link
            CoreLabel <code>CoreLabel</code>}.  (In contrast to {@link
            edu.stanford.nlp.ling.CategoryWordTag
            <code>CategoryWordTag</code>}, we store head words and head
            tags as references to nodes, not merely as <code>string</code>s.)
            </summary>
            <returns>the node containing the head tag for this node</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TreeGraphNode.SetHeadTagNode(OpenNLP.Tools.Trees.TreeGraphNode)">
            <summary>
            Store the node containing the head tag for this node by
            storing it in this node's {@link CoreLabel <code>CoreLabel</code>}.
            (In contrast to {@link edu.stanford.nlp.ling.CategoryWordTag
            <code>CategoryWordTag</code>}, we store head words and head
            tags as references to nodes, not merely as
            <code>string</code>s.)
            </summary>
            <param name="htn">the node containing the head tag for this node</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TreeGraphNode.SafeCast(System.Object)">
            <summary>
            Safely casts an <code>Object</code> to a <code>TreeGraphNode</code>
            if possible, else returns <code>null</code>
            </summary>
            <param name="t">any <code>Object</code></param>
            <returns>
            <code>t</code> if it is a <code>TreeGraphNode</code>;<code>null</code> otherwise
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TreeGraphNode.HighestNodeWithSameHead">
            <summary>
            Checks the node's ancestors to find the highest ancestor with the
            same <code>headWordNode</code> as this node
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TreeGraphNode.TreeFactory">
            <summary>
            Returns a <code>TreeFactory</code> that produces 
            <code>TreeGraphNode</code>s.  The <code>Label</code> of
            <code>this</code> is examined, and providing it is not
            <code>null</code>, a <code>LabelFactory</code> which will
            produce that kind of <code>Label</code> is supplied to the
            <code>TreeFactory</code>.  If the <code>Label</code> is
            <code>null</code>, a <code>CoreLabel.factory()</code> will be used.  
            The factories returned on different calls are different: a new one is
            allocated each time.
            </summary>
            <returns>a factory to produce treegraphs</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TreeGraphNode.Factory">
            <summary>
            Return a <code>TreeFactory</code> that produces trees of type <code>TreeGraphNode</code>.
            The factory returned is always the same one (a singleton).
            </summary>
            <returns>a factory to produce treegraphs</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TreeGraphNode.Factory(OpenNLP.Tools.Ling.ILabelFactory)">
            <summary>
            Return a <code>TreeFactory</code> that produces trees of type
            <code>TreeGraphNode</code>, with the <code>Label</code> made
            by the supplied <code>LabelFactory</code>.  The factory
            returned is a different one each time.
            </summary>
            <param name="lf">The <code>LabelFactory</code> to use</param>
            <returns>a factory to produce treegraphs</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TreeGraphNode.ToPrettyString(System.Int32)">
            <summary>
            Returns a <code>string</code> representation of this node and
            its subtree with one node per line, indented according to <code>indentLevel</code>.
            </summary>
            <param name="indentLevel">how many levels to indent (0 for root node)</param>
            <returns><code>string</code> representation of this subtree</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TreeGraphNode.ToOneLineString">
            <summary>
            Returns a <code>string</code> representation of this node and
            its subtree as a one-line parenthesized list 
            </summary>
            <returns><code>string</code> representation of this subtree</returns>
        </member>
        <member name="T:OpenNLP.Tools.Trees.TreeGraphNodeFactory">
            <summary>
            A <code>TreeGraphNodeFactory</code> acts as a factory for creating
            nodes in a {@link TreeGraph <code>TreeGraph</code>}.
            Unless another {@link LabelFactory <code>LabelFactory</code>} is
            supplied, it will use a CoreLabelFactory by default.
            
            @author Bill MacCartney
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TreeGraphNodeFactory.#ctor">
            <summary>
            Make a <code>TreeFactory</code> that produces <code>TreeGraphNode</code>s.
            The labels are of class <code>CoreLabel</code>.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.TreeNormalizer">
            <summary>
            A class for tree normalization.  The default one does no normalization.
            Other tree normalizers will change various node labels, or perhaps the
            whole tree geometry (by doing such things as deleting functional tags or
            empty elements).  Another operation that a <code>TreeNormalizer</code>
            may wish to perform is interning the <code>string</code>s passed to
            it.  Can be reused as a Singleton.  Designed to be extended.
            
            The <code>TreeNormalizer</code> methods are in two groups.
            The contract for this class is that first normalizeTerminal or
            normalizeNonterminal will be called on each <code>string</code> that will
            be put into a <code>Tree</code>, when they are read from files or
            otherwise created.  Then <code>normalizeWholeTree</code> will
            be called on the <code>Tree</code>.  It normally walks the
            <code>Tree</code> making whatever modifications it wishes to. A
            <code>TreeNormalizer</code> need not make a deep copy of a
            <code>Tree</code>.  It is assumed to be able to work destructively,
            because afterwards we will only use the normalized <code>Tree</code>.
            
            <i>Implementation note:</i> This is a very old legacy class used in conjunction
            with PennTreeReader.  It seems now that it would be better to move the
            string normalization into the tokenizer, and then we are just left with a
            (possibly destructive) TreeTransformer.
            
            @author Christopher Manning
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TreeNormalizer.NormalizeTerminal(System.String)">
            <summary>
            Normalizes a leaf contents (and maybe intern it).
            </summary>
            <param name="leaf">The string that decorates the leaf</param>
            <returns>The normalized form of this leaf String</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TreeNormalizer.NormalizeNonterminal(System.String)">
            <summary>
            Normalizes a nonterminal contents (and maybe intern it)
            </summary>
            <param name="category">The string that decorates this nonterminal node</param>
            <returns>The normalized form of this nonterminal String</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TreeNormalizer.NormalizeWholeTree(OpenNLP.Tools.Trees.Tree,OpenNLP.Tools.Trees.ITreeFactory)">
            <summary>
            Normalize a whole tree -- this method assumes that the argument
            that it is passed is the root of a complete <code>Tree</code>.
            It is normally implemented as a Tree-walking routine.
            This method may return <code>null</code>. This is interpreted to
            mean that this is a tree that should not be included in further
            processing.  PennTreeReader recognizes this return value, and
            asks for another Tree from the input Reader.
            </summary>
            <param name="tree">The tree to be normalized</param>
            <param name="tf">the TreeFactory to create new nodes (if needed)</param>
            <returns>the normalized tree</returns>
        </member>
        <member name="T:OpenNLP.Tools.Trees.Trees">
            <summary>
            Various static utilities for the <code>Tree</code> class.
            
            @author Roger Levy
            @author Dan Klein
            @author Aria Haghighi (tree path methods)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Trees.LeftEdge(OpenNLP.Tools.Trees.Tree,OpenNLP.Tools.Trees.Tree)">
            <summary>
            Returns the positional index of the left edge of a tree <i>t</i>
            within a given root, as defined by the size of the yield of all
            material preceding <i>t</i>.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Trees.RightEdge(OpenNLP.Tools.Trees.Tree,OpenNLP.Tools.Trees.Tree)">
            <summary>
            Returns the positional index of the right edge of a tree
            <i>t</i> within a given root, as defined by the size of the yield
            of all material preceding <i>t</i> plus all the material contained in <i>t</i>.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Trees.Leaves(OpenNLP.Tools.Trees.Tree)">
            <summary>
            Returns the leaves in a Tree in the order that they're found
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Trees.LeafLabels(OpenNLP.Tools.Trees.Tree)">
            <summary>
            Returns the labels of the leaves in a Tree in the order that they're found
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Trees.TaggedLeafLabels(OpenNLP.Tools.Trees.Tree)">
            <summary>
            Returns the labels of the leaves in a Tree, augmented with POS tags.  a
            Assumes that the labels are CoreLabels.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Trees.MaximalProjection(OpenNLP.Tools.Trees.Tree,OpenNLP.Tools.Trees.Tree,OpenNLP.Tools.Trees.IHeadFinder)">
            <summary>
            Returns the maximal projection of <code>head</code> in
            <code>root</code> given a {@link HeadFinder}
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Trees.LocalTreeAsCatList(OpenNLP.Tools.Trees.Tree)">
            <summary>
            Returns the syntactic category of the tree as a list of the syntactic categories of the mother and the daughters
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Trees.ObjectEqualityIndexOf(OpenNLP.Tools.Trees.Tree,OpenNLP.Tools.Trees.Tree)">
            <summary>
            Returns the index of <code>daughter</code> in <code>parent</code> by ==.
            Returns -1 if <code>daughter</code> not found.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Trees.TreeToLatex(OpenNLP.Tools.Trees.Tree)">
            Turns a sentence into a flat phrasal tree.
              The structure is S -> tag*.  And then each tag goes to a word.
              The tag is either found from the label or made "WD".
              The tag and phrasal node have a StringLabel.
            
              @param s The Sentence to make the Tree from
              @param lf The LabelFactory with which to create the new Tree labels
              @return The one phrasal level Tree
        </member>
        <member name="M:OpenNLP.Tools.Trees.Trees.GetLowestCommonAncestor(System.Collections.Generic.List{OpenNLP.Tools.Trees.Tree},OpenNLP.Tools.Trees.Tree)">
            <summary>
            Get lowest common ancestor of all the nodes in the list with the tree rooted at root
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Trees.PathNodeToNode(OpenNLP.Tools.Trees.Tree,OpenNLP.Tools.Trees.Tree,OpenNLP.Tools.Trees.Tree)">
            <summary>
            Returns a list of categories that is the path from Tree from to Tree
            to within Tree root.  If either from or to is not in root,
            Returns null.  Otherwise includes both from and to in the list.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Trees.PathFromRoot(OpenNLP.Tools.Trees.Tree,OpenNLP.Tools.Trees.Tree)">
            <summary>
            Returns list of tree nodes to root from t.
            Includes root and t. Returns null if tree not found dominated by root
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Trees.ReplaceNode(OpenNLP.Tools.Trees.Tree,OpenNLP.Tools.Trees.Tree,OpenNLP.Tools.Trees.Tree)">
            <summary>
            Replaces all instances (by ==) of node with node1.
            Doesn't affect the node t itself
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Trees.GetLowestCommonAncestor(OpenNLP.Tools.Trees.Tree,OpenNLP.Tools.Trees.Tree,OpenNLP.Tools.Trees.Tree)">
            <summary>
            Returns the node of a tree which represents the lowest common
            ancestor of nodes t1 and t2 dominated by root. If either t1 or
            or t2 is not dominated by root, returns null.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Trees.ConvertToCoreLabels(OpenNLP.Tools.Trees.Tree)">
            <summary>
            Converts the tree labels to CoreLabels.
            We need this because we store additional info in the CoreLabel, like token span.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.Trees.SetSentIndex(OpenNLP.Tools.Trees.Tree,System.Int32)">
            <summary>
            Set the sentence index of all the leaves in the tree (only works on CoreLabel)
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.TreeTokenizerFactory">
            <summary>
            Wrapper for TreeReaderFactory.  Any IOException in the readTree() method
            of the TreeReader will result in a null tree returned.
            
            @author Roger Levy (rog@stanford.edu)
            @author javanlp
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TreeTokenizerFactory.#ctor(OpenNLP.Tools.Trees.ITreeReaderFactory)">
            <summary>
            Create a TreeTokenizerFactory from a TreeReaderFactory.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TreeTokenizerFactory.GetTokenizer(System.IO.TextReader)">
            <summary>
            Gets a tokenizer from a reader
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TreeTokenizerFactory.GetIterator(System.IO.TextReader)">
            <summary>
            Same as getTokenizer()
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.CoordinationPattern.#ctor(System.Collections.Generic.List{OpenNLP.Tools.Trees.TRegex.TregexPattern},System.Boolean)">
            <summary>
            if isConj is true, then it is an "AND" ; if it is false, it is an "OR"
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.CoordinationPattern.CoordinationMatcher.Matches">
            <summary>
            find the next local match
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.DescriptionPattern.MaxStringMatcherSize">
            <summary>
            What size string matchers to use before switching to regex for disjunction matches
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.DescriptionPattern.name">
            <summary>The name to give the matched node</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.DescriptionPattern.linkedName">
            <summary>If this pattern is a link, this is the node linked to</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.DescriptionPattern.variableGroups">
            <summary>also conceptually readonly, but it depends on the child</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.DescriptionPattern.basicCatFunction">
            <summary>specifies the groups in a regex that are captured as matcher-global string variables</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.DescriptionPattern.SingleWordPattern">
            <summary>
            Used to detect regex expressions which can be simplified to exact matches
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.DescriptionPattern.MultiWordPattern">
            <summary>for example, /^-NONE-$/</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.DescriptionPattern.PrefixPattern">
            <summary>
            Used to detect regex expressions which can be simplified to exact matches
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.DescriptionPattern.DescriptionMatcher.nextTreeNodeMatchCandidate">
            <summary>
            The Tree node that this DescriptionMatcher node is trying to match on
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.DescriptionPattern.DescriptionMatcher.finished">
            <summary>
            when finished = true, it means I have exhausted my potential tree node match candidates
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.DescriptionPattern.DescriptionMatcher.GoToNextTreeNodeMatch">
            <summary>
            goes to the next node in the tree that is a successful match to my description pattern.
            This is the hotspot method in running tregex, but not clear how to make it faster.
            When finished = false; break; is called, it means I successfully matched
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.DescriptionPattern.DescriptionMatcher.MatchChild">
            <summary>
            Tries to match the unique child of the DescriptionPattern node to a Tree node.
            </summary>
            <returns>"true" if succeeds</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.DescriptionPattern.DescriptionMatcher.Matches">
            <summary>
            find the next local match
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.TRegex.ParseException">
            <summary>
            This exception is thrown when parse errors are encountered.
            You can explicitly create objects of this exception type by
            calling the method generateParseException in the generated parser.
            
            You can modify this class to customize your error reporting
            mechanisms so long as you retain the public fields.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.ParseException.#ctor(OpenNLP.Tools.Trees.TRegex.Token,System.Int32[][],System.String[])">
            <summary>
            This constructor is used by the method "generateParseException"
            in the generated parser.  Calling this constructor generates
            a new object of this type with the fields "currentToken",
            "expectedTokenSequences", and "tokenImage" set.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.ParseException.#ctor">
            <summary>
            The following constructors are for use by you for whatever
            purpose you can think of.  Constructing the exception in this
            manner makes the exception behave in the normal way - i.e., as
            documented in the class "Throwable".  The fields "errorToken",
            "expectedTokenSequences", and "tokenImage" do not contain
            relevant information.  The JavaCC generated code does not use these constructors.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.ParseException.#ctor(System.String)">
            <summary>
            Constructor with message
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.ParseException.CurrentToken">
            <summary>
            This is the last token that has been consumed successfully.
            If this object has been created due to a parse error, the token
            followng this token will (therefore) be the first error token.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.ParseException.ExpectedTokenSequences">
            <summary>
            Each entry in this array is an array of integers.
            Each array of integers represents a sequence of tokens (by their ordinal
            values) that is expected at this point of the parse.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.ParseException.TokenImage">
            <summary>
            This is a reference to the "tokenImage" array of the generated
            parser within which the parse error occurred.  This array is
            defined in the generated ...Constants interface.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.ParseException.Initialize(OpenNLP.Tools.Trees.TRegex.Token,System.Int32[][],System.String[])">
            <summary>
            It uses "currentToken" and "expectedTokenSequences" to generate a parse
            error message and returns it.  If this object has been created
            due to a parse error, and you do not catch it (it gets thrown
            from the parser) the correct error message gets displayed.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.ParseException.Eol">
            <summary>
            The end of line string for this machine
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.ParseException.Add_escapes(System.String)">
            <summary>
            Used to convert raw characters to their escaped version
            when these raw version cannot be used as part of an ASCII string literal.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.TRegex.Relation">
            <summary>
            An abstract base class for relations between tree nodes in tregex. There are
            two types of subclasses: static anonymous singleton instantiations for
            relations that do not require arguments, and private subclasses for those
            with arguments. All invocations should be made through the static factory
            methods, which insure that there is only a single instance of each relation.
            Thus == can be used instead of .equals.
            
            If you want to add a new relation, you just have to fill in the definition of satisfies and
            searchNodeIterator. Also be careful to make the appropriate adjustments to
            getRelation and SIMPLE_RELATIONS. Finally, if you are using the TregexParser,
            you need to add the new relation symbol to the list of tokens.
            
            @author Galen Andrew
            @author Roger Levy
            @author Christopher Manning
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Relation.Satisfies(OpenNLP.Tools.Trees.Tree,OpenNLP.Tools.Trees.Tree,OpenNLP.Tools.Trees.Tree,OpenNLP.Tools.Trees.TRegex.TregexMatcher)">
            <summary>
            Whether this relationship is satisfied between two trees
            </summary>
            <param name="t1">The tree that is the left operand</param>
            <param name="t2">The tree that is the right operand</param>
            <param name="root">The common root of t1 and t2</param>
            <returns>Whether this relationship is satisfied</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Relation.GetSearchNodeIterator(OpenNLP.Tools.Trees.Tree,OpenNLP.Tools.Trees.TRegex.TregexMatcher)">
            <summary>
            For a given node, returns an {@link Iterator} over the nodes
            of the tree containing the node that satisfy the relation.
            </summary>
            <param name="t">A node in a Tree</param>
            <param name="matcher">The matcher that nodes have to satisfy</param>
            <returns>An Iterator over the nodes of the root tree that satisfy the relation.</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Relation.GetRelation(System.String,System.Func{System.String,System.String},OpenNLP.Tools.Trees.IHeadFinder)">
            <summary>
            Static factory method for all relations with no arguments. Includes:
            DOMINATES, DOMINATED_BY, PARENT_OF, CHILD_OF, PRECEDES,
            IMMEDIATELY_PRECEDES, HAS_LEFTMOST_DESCENDANT, HAS_RIGHTMOST_DESCENDANT,
            LEFTMOST_DESCENDANT_OF, RIGHTMOST_DESCENDANT_OF, SISTER_OF, LEFT_SISTER_OF,
            RIGHT_SISTER_OF, IMMEDIATE_LEFT_SISTER_OF, IMMEDIATE_RIGHT_SISTER_OF,
            HEADS, HEADED_BY, IMMEDIATELY_HEADS, IMMEDIATELY_HEADED_BY, ONLY_CHILD_OF,
            HAS_ONLY_CHILD, EQUALS
            </summary>
            <param name="s">The string representation of the relation</param>
            <returns>The singleton static relation of the specified type</returns>
            <exception cref="T:OpenNLP.Tools.Trees.TRegex.ParseException">If bad relation s</exception>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Relation.GetRelation(System.String,System.String,System.Func{System.String,System.String},OpenNLP.Tools.Trees.IHeadFinder)">
            <summary>
            Static factory method for relations requiring an argument, including
            HAS_ITH_CHILD, ITH_CHILD_OF, UNBROKEN_CATEGORY_DOMINATES,
            UNBROKEN_CATEGORY_DOMINATED_BY.
            </summary>
            <param name="s">The string representation of the relation</param>
            <param name="arg">The argument to the relation, as a string; could be a node description or an integer</param>
            <returns>
            The singleton static relation of the specified type with the specified argument. Uses Interner to insure singleton-ity
            </returns>
            <exception cref="T:OpenNLP.Tools.Trees.TRegex.ParseException">If bad relation s</exception>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Relation.ConstructMultiRelation(System.String,System.Collections.Generic.List{OpenNLP.Tools.Trees.TRegex.DescriptionPattern},System.Func{System.String,System.String},OpenNLP.Tools.Trees.IHeadFinder)">
            <summary>
            Produce a TregexPattern which represents the given MULTI_RELATION and its children
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.TRegex.Relation.SearchNodeIterator">
            <summary>
            This abstract Iterator implements a NULL iterator, but by subclassing and
            overriding advance and/or initialize, it is an efficient implementation.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Relation.SearchNodeIterator._next">
            <summary>
            This is the next tree to be returned by the iterator, or null if there are no more items.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Relation.Root">
            <summary>Used in TregexParser</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Relation.PatternSplitter">
            <summary>
            This is a "dummy" relation that allows you to segment patterns
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Relation.UnbrokenCategoryDominates.#ctor(System.String,System.Func{System.String,System.String})">
            <summary>
            
            </summary>
            <param name="arg">
            This may have a ! and then maybe a @ and then either an identifier or regex
            </param>
        </member>
        <member name="T:OpenNLP.Tools.Trees.TRegex.Relation.UnbrokenCategoryPrecedes">
            <summary>
            Note that this only works properly for context-free trees.
            Also, the use of initialize and advance is not very efficient just yet.  Finally, each node in the tree
            is added only once, even if there is more than one unbroken-category precedence path to it.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Relation.UnbrokenCategoryPrecedes.#ctor(System.String,System.Func{System.String,System.String})">
            <summary>
            
            </summary>
            <param name="arg">The pattern to match, perhaps preceded by ! and/or @</param>
        </member>
        <member name="T:OpenNLP.Tools.Trees.TRegex.Relation.UnbrokenCategoryFollows">
            <summary>
            Note that this only works properly for context-free trees.
            Also, the use of initialize and advance is not very efficient just yet.  Finally, each node in the tree
            is added only once, even if there is more than one unbroken-category precedence path to it.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Relation.UnbrokenCategoryFollows.#ctor(System.String,System.Func{System.String,System.String})">
            <summary>
            
            </summary>
            <param name="arg">The pattern to match, perhaps preceded by ! and/or @</param>
        </member>
        <member name="T:OpenNLP.Tools.Trees.TRegex.SimpleCharStream">
            <summary>
            An implementation of interface CharStream, where the stream is assumed to
            contain only ASCII characters (without unicode processing).
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.SimpleCharStream.staticFlag">
            <summary>
            Whether parser is static
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.SimpleCharStream.bufpos">
            <summary>Position in buffer</summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.SimpleCharStream.ReadChar">
            <summary>Read a character</summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.SimpleCharStream.GetEndColumn">
            <summary>
            Get token end column number
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.SimpleCharStream.GetEndLine">
            <summary>
            Get token end line number
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.SimpleCharStream.GetBeginColumn">
            <summary>
            Get token beginning column number
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.SimpleCharStream.GetBeginLine">
            <summary>
            Get token beginning line number
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.SimpleCharStream.Backup(System.Int32)">
            <summary>
            Backup a number of characters
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.SimpleCharStream.#ctor(System.IO.TextReader,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.SimpleCharStream.#ctor(System.IO.TextReader,System.Int32,System.Int32)">
            <summary>Constructor</summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.SimpleCharStream.#ctor(System.IO.TextReader)">
            <summary>Constructor</summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.SimpleCharStream.ReInit(System.IO.TextReader,System.Int32,System.Int32,System.Int32)">
            <summary>Reinitialize</summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.SimpleCharStream.ReInit(System.IO.TextReader,System.Int32,System.Int32)">
            <summary>Reinitialize</summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.SimpleCharStream.ReInit(System.IO.TextReader)">
            <summary>Reinitialize</summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.SimpleCharStream.#ctor(System.IO.Stream,System.String,System.Int32,System.Int32,System.Int32)">
            <summary>Constructor</summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.SimpleCharStream.#ctor(System.IO.Stream,System.Int32,System.Int32,System.Int32)">
            <summary>Constructor</summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.SimpleCharStream.#ctor(System.IO.Stream,System.String,System.Int32,System.Int32)">
            <summary>Constructor</summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.SimpleCharStream.#ctor(System.IO.Stream,System.Int32,System.Int32)">
            <summary>Constructor</summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.SimpleCharStream.#ctor(System.IO.Stream,System.String)">
            <summary>Constructor</summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.SimpleCharStream.#ctor(System.IO.Stream)">
            <summary>Constructor</summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.SimpleCharStream.ReInit(System.IO.Stream,System.String,System.Int32,System.Int32,System.Int32)">
            <summary>Reinitialize</summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.SimpleCharStream.ReInit(System.IO.Stream,System.Int32,System.Int32,System.Int32)">
            <summary>Reinitialize</summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.SimpleCharStream.ReInit(System.IO.Stream,System.String)">
            <summary>Reinitialize</summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.SimpleCharStream.ReInit(System.IO.Stream)">
            <summary>Reinitialize</summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.SimpleCharStream.ReInit(System.IO.Stream,System.String,System.Int32,System.Int32)">
            <summary>Reinitialize</summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.SimpleCharStream.ReInit(System.IO.Stream,System.Int32,System.Int32)">
            <summary>Reinitialize</summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.SimpleCharStream.GetImage">
            <summary>
            Get token literal value
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.SimpleCharStream.GetSuffix(System.Int32)">
            <summary>
            Get the suffix
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.SimpleCharStream.Done">
            <summary>
            Reset buffer when finished
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.SimpleCharStream.AdjustBeginLineColumn(System.Int32,System.Int32)">
            <summary>
            Adjust line and column numbers for the start of a token
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.TRegex.Token">
            <summary>
            Describes the input token stream
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Token.Kind">
            <summary>
            An integer that describes the kind of this token.  This numbering
            system is determined by JavaCCParser, and a table of these numbers is
            stored in the file ...Constants.java.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Token.BeginLine">
            <summary>
            The line number of the first character of this Token
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Token.BeginColumn">
            <summary>
            The column number of the first character of this Token
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Token.EndLine">
            <summary>
            The line number of the last character of this Token
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Token.EndColumn">
            <summary>
            The column number of the last character of this Token
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Token.Image">
            <summary>
            The string image of the token
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Token.Next">
            <summary>
            A reference to the next regular (non-special) token from the input
            stream.  If this is the last token from the input stream, or if the
            token manager has not read tokens beyond this one, this field is
            set to null.  This is true only if this token is also a regular
            token.  Otherwise, see below for a description of the contents of
            this field.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Token.SpecialToken">
            <summary>
            This field is used to access special tokens that occur prior to this
            token, but after the immediately preceding regular (non-special) token.
            If there are no such special tokens, this field is set to null.
            When there are more than one such special token, this field refers
            to the last of these special tokens, which in turn refers to the next
            previous special token through its specialToken field, and so on
            until the first special token (whose specialToken field is null).
            The next fields of special tokens refer to other special tokens that
            immediately follow it (without an intervening regular token).  If there
            is no such token, this field is null.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Token.GetValue">
            <summary>
            An optional attribute value of the Token.
            Tokens which are not used as syntactic sugar will often contain
            meaningful values that will be used later on by the compiler or
            interpreter. This attribute value is often different from the image.
            Any subclass of Token that actually wants to return a non-null value can
            override this method as appropriate.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Token.#ctor">
            <summary>
            No-argument constructor
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Token.#ctor(System.Int32)">
            <summary>
            Constructs a new token for the specified Image
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Token.#ctor(System.Int32,System.String)">
            <summary>
            Constructs a new token for the specified Image and Kind
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Token.ToString">
            <summary>
            Returns the image
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Token.NewToken(System.Int32,System.String)">
            <summary>
            Returns a new Token object, by default. However, if you want, you
            can create and return subclass objects based on the value of ofKind.
            Simply add the cases to the switch for all those special cases.
            For example, if you have a subclass of Token called IDToken that
            you want to create if ofKind is ID, simply add something like :
                case MyParserConstants.ID : return new IDToken(ofKind, image);
            to the following switch statement. Then you can cast matchedToken
            variable to the appropriate type and use sit in your lexical actions.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.TokenMgrException.LexError">
            <summary>
            Lexical error occurred
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.TokenMgrException.InvalidLexicalState">
            <summary>
            Tried to change to an invalid lexical state
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.TokenMgrException.LoopDetected">
            <summary>
            Detected (and bailed out of) an infinite loop in the token manager.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.TokenMgrException.errorCode">
            <summary>
            Indicates the reason why the exception is thrown. 
            It will have one of the above 4 values.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TokenMgrException.AddEscapes(System.String)">
            <summary>
            Replaces unprintable characters by their escaped (or unicode escaped)
            equivalents in the given string
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TokenMgrException.LexicalError(System.Boolean,System.Int32,System.Int32,System.Int32,System.String,System.Char)">
            <summary>
            Returns a detailed message for the Error when it is thrown by the
            token manager to indicate a lexical error.
            Note: You can customize the lexical error message by modifying this method.
            </summary>
            <param name="eofSeen">indicates if EOF caused the lexical error</param>
            <param name="lexState">lexical state in which this error occurred</param>
            <param name="errorLine">line number when the error occurred</param>
            <param name="errorColumn">column number when the error occurred</param>
            <param name="errorAfter">prefix that was seen before this error occurred</param>
            <param name="curChar">the offending character</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TokenMgrException.GetMessage">
            <summary>
            You can also modify the body of this method to customize your error messages.
            For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
            of end-users concern, so you can return something like :
                 "Internal Error : Please file a bug report .... "
            from this method for such cases in the release version of your parser.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TokenMgrException.#ctor">
            <summary>
            No arg constructor
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TokenMgrException.#ctor(System.String,System.Int32)">
            <summary>
            Constructor with message and reason
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TokenMgrException.#ctor(System.Boolean,System.Int32,System.Int32,System.Int32,System.String,System.Char,System.Int32)">
            <summary>
            Full Constructor
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.TRegex.TregexMatcher">
            <summary>
            A TregexMatcher can be used to match a {@link TregexPattern} against a {@link edu.stanford.nlp.trees.Tree}.
            Usage should be similar to a {@link java.util.regex.Matcher}.
            
            @author Galen Andrew
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TregexMatcher.Reset">
            <summary>
            Resets the matcher so that its search starts over
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TregexMatcher.ResetChildIter(OpenNLP.Tools.Trees.Tree)">
            <summary>
            Resets the matcher to start searching on the given tree for matching subexpressions
            </summary>
            <param name="tree">The tree to start searching on</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TregexMatcher.ResetChildIter">
            <summary>
            Resets the matcher to restart search for matching subexpressions
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TregexMatcher.Matches">
            <summary>
            Does the pattern match the tree?  It's actually closer to java.util.regex's
            "lookingAt" in that the root of the tree has to match the root of the pattern
            but the whole tree does not have to be "accounted for".  Like with lookingAt
            the beginning of the string has to match the pattern, but the whole string
            doesn't have to be "accounted for".
            </summary>
            <returns>whether the tree matches the pattern</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TregexMatcher.MatchesAt(OpenNLP.Tools.Trees.Tree)">
            <summary>
            Rests the matcher and tests if it matches on the tree when rooted at <code>node</code>
            </summary>
            <param name="node">The node where the match is checked</param>
            <returns>whether the matcher matches at node</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TregexMatcher.GetMatch">
            <summary>
            Get the last matching tree -- that is, the tree node that matches the root node of the pattern. 
            </summary>
            <returns>last match, null if there has not been a match.</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TregexMatcher.Find">
            <summary>
            Find the next match of the pattern on the tree
            </summary>
            <returns>whether there is a match somewhere in the tree</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TregexMatcher.FindAt(OpenNLP.Tools.Trees.Tree)">
            <summary>
            Similar to {@code find()}, but matches only if {@code node} is
            the root of the match.  All other matches are ignored.  If you
            know you are looking for matches with a particular root, this is
            much faster than iterating over all matches and taking only the
            ones that work and faster than altering the tregex to match only
            the correct node.
            
            If called multiple times with the same node, this will return
            subsequent matches in the same manner as find() returns
            subsequent matches in the same tree.  If you want to call this using
            the same TregexMatcher on more than one node, call reset() first;
            otherwise, an AssertionError will be thrown.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TregexMatcher.FindNextMatchingNode">
            <summary>
            Find the next match of the pattern on the tree such that the
            matching node (that is, the tree node matching the root node of
            the pattern) differs from the previous matching node.
            </summary>
            <returns>true iff another matching node is found</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TregexMatcher.GetNode(System.String)">
            <summary>
            Returns the node labeled with <code>name</code> in the pattern
            </summary>
            <param name="name">the name of the node, specified in the pattern</param>
            <returns>node labeled by the name</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TregexMatcher.GetVariableString(System.String)">
            <summary>
            If there is a current match, and that match involves setting this
            particular variable string, this returns that string.  Otherwise,
            it returns null.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.TRegex.TregexParseException">
            <summary>
            A runtime exception that indicates something went wrong parsing a
            tregex expression.  The purpose is to make those exceptions
            unchecked exceptions, as there are only a few circumstances in
            which one could recover.
            
            @author John Bauer
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.TregexParser.underNegation">
            <summary>
            this is so we can tell, at any point during the parse
            whether we are under a negation, which we need to know
            because labeling nodes under negation is illegal
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.TregexParser.knownVariables">
            <summary>
            keep track of which variables we've seen, so that we can reject
            some nonsense patterns such as ones that reset variables or link
            to variables that haven't been set
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TregexParser.Root">
            <summary>
            the grammar starts here
            each of these BNF rules will be converted into a function
            first expr is return val- passed up the tree after a production
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TregexParser.Node(OpenNLP.Tools.Trees.TRegex.Relation)">
            <summary>
            passing arguments down the tree - in this case the relation that
            pertains to this node gets passed all the way down to the Description node
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.TregexParser.token_source">
            <summary>Generated Token Manager</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.TregexParser.token">
            <summary>Current token</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.TregexParser.jj_nt">
            <summary>Next token</summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TregexParser.#ctor(System.IO.Stream)">
            <summary>Constructor with Stream</summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TregexParser.#ctor(System.IO.Stream,System.String)">
            <summary>
            Constructor with Stream and supplied encoding
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TregexParser.ReInit(System.IO.Stream)">
            <summary>Reinitialize</summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TregexParser.ReInit(System.IO.Stream,System.String)">
            <summary>Reinitialize</summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TregexParser.#ctor(System.IO.TextReader)">
            <summary>Constructor</summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TregexParser.ReInit(System.IO.TextReader)">
            <summary>Reinitialize</summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TregexParser.#ctor(OpenNLP.Tools.Trees.TRegex.TregexParserTokenManager)">
            <summary>
            Constructor with generated Token Manager
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TregexParser.ReInit(OpenNLP.Tools.Trees.TRegex.TregexParserTokenManager)">
            <summary>Reinitialize</summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TregexParser.GetNextToken">
            <summary>Get the next Token</summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TregexParser.GetToken(System.Int32)">
            <summary>Get the specific Token</summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TregexParser.GenerateParseException">
            <summary>Generate ParseException</summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.TRegex.TregexParserConstants">
            <summary>
            Token literal values and constants.
            Generated by org.javacc.parser.OtherFilesGen#start()
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.TregexParserConstants.Eof">
            <summary>End of File</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.TregexParserConstants.RELATION">
            <summary>RegularExpression Id</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.TregexParserConstants.MultiRelation">
            <summary>RegularExpression Id</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.TregexParserConstants.RelWStrArg">
            <summary>RegularExpression Id</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.TregexParserConstants.Number">
            <summary>RegularExpression Id</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.TregexParserConstants.Identifier">
            <summary>RegularExpression Id</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.TregexParserConstants.Blank">
            <summary>RegularExpression Id</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.TregexParserConstants.Regex">
            <summary>RegularExpression Id</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.TregexParserConstants.Varname">
            <summary>RegularExpression Id</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.TregexParserConstants.Default">
            <summary>Lexical state</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.TregexParserConstants.TokenImage">
            <summary>Literal token values</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.TregexParserTokenManager.JjstrLiteralImages">
            <summary>
            Token literal values
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TregexParserTokenManager.GetNextToken">
            <summary>
            Get the next Token
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TregexParserTokenManager.#ctor(OpenNLP.Tools.Trees.TRegex.SimpleCharStream)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TregexParserTokenManager.#ctor(OpenNLP.Tools.Trees.TRegex.SimpleCharStream,System.Int32)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TregexParserTokenManager.ReInit(OpenNLP.Tools.Trees.TRegex.SimpleCharStream)">
            <summary>
            Reinitialise parser
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TregexParserTokenManager.ReInit(OpenNLP.Tools.Trees.TRegex.SimpleCharStream,System.Int32)">
            <summary>
            Reinitialise parser
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TregexParserTokenManager.SwitchTo(System.Int32)">
            <summary>
            Switch to specified lex state
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.TregexParserTokenManager.LexStateNames">
            <summary>
            Lexer state names.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:OpenNLP.Tools.Trees.TRegex.TregexPattern" -->
        <member name="M:OpenNLP.Tools.Trees.TRegex.TregexPattern.Matcher(OpenNLP.Tools.Trees.Tree)">
            <summary>
            Get a {@link TregexMatcher} for this pattern on this tree.
            </summary>
            <param name="t">a tree to match on</param>
            <returns>a TregexMatcher</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TregexPattern.Matcher(OpenNLP.Tools.Trees.Tree,OpenNLP.Tools.Trees.IHeadFinder)">
            <summary>
            Get a {@link TregexMatcher} for this pattern on this tree.
            Any Relations which use heads of trees should use the provided HeadFinder.
            </summary>
            <param name="t">a tree to match on</param>
            <param name="headFinder">a HeadFinder to use when matching</param>
            <returns>a TregexMatcher</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TregexPattern.Compile(System.String)">
            <summary>
            Creates a pattern from the given string using the default HeadFinder and
            BasicCategoryFunction.  If you want to use a different HeadFinder or
            BasicCategoryFunction, use a {@link TregexPatternCompiler} object.
            </summary>
            <param name="tregex">the pattern string</param>
            <returns>a TregexPattern for the string.</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TregexPattern.SafeCompile(System.String,System.Boolean)">
            <summary>
            Creates a pattern from the given string using the default HeadFinder and
            BasicCategoryFunction.  If you want to use a different HeadFinder or
            BasicCategoryFunction, use a {@link TregexPatternCompiler} object.
            Rather than throwing an exception when the string does not parse,
            simply returns null.
            </summary>
            <param name="tregex">the pattern string</param>
            <param name="verbose">whether to log errors when the string doesn't parse</param>
            <returns>a TregexPattern for the string, or null if the string does not parse.</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TregexPattern.SetPatternString(System.String)">
            <summary>
            Only used by the TregexPatternCompiler to set the pattern. Pseudo-final
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.TregexPattern.CodePattern">
            @return A single-line string representation of the pattern
        </member>
        <member name="T:OpenNLP.Tools.Trees.TRegex.TregexPatternCompiler">
            <summary>
            A class for compiling TregexPatterns with specific HeadFinders and or basicCategoryFunctions.
            
            @author Galen Andrew
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TregexPatternCompiler.#ctor(OpenNLP.Tools.Trees.AbstractTreebankLanguagePack.BasicCategoryStringFunction)">
            <summary>
            A compiler that uses this basicCatFunction and the default HeadFinder.
            </summary>
            <param name="basicCatFunction">the function mapping strings to Strings</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TregexPatternCompiler.#ctor(OpenNLP.Tools.Trees.IHeadFinder)">
            <summary>
            A compiler that uses this HeadFinder and the default basicCategoryFunction
            </summary>
            <param name="headFinder">the HeadFinder</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TregexPatternCompiler.#ctor(OpenNLP.Tools.Trees.IHeadFinder,OpenNLP.Tools.Trees.AbstractTreebankLanguagePack.BasicCategoryStringFunction)">
            <summary>
            A compiler that uses this HeadFinder and this basicCategoryFunction
            </summary>
            <param name="headFinder">the HeadFinder</param>
            <param name="basicCatFunction">The function mapping strings to strings</param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TregexPatternCompiler.AddMacro(System.String,System.String)">
            <summary>
            Define a macro for rewriting a pattern in any tregex expression compiled
            by this compiler. The semantics of this is that all instances of the
            original in the pattern are replaced by the replacement, using exactly
            the semantics of string.replaceAll(original, replacement) and the
            result will then be compiled by the compiler. As such, note that a
            macro can replace any part of a tregex expression, in a syntax
            insensitive way.  Here's an example:
            {@code tpc.addMacro("FINITE_BE_AUX", "/^(?i:am|is|are|was|were)$/");}
            </summary>
            <param name="original">
            The string to match; becomes the first argument of a string.replaceAll()
            </param>
            <param name="replacement">
            The replacement String; becomes the second argument of a string.replaceAll()
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.TregexPatternCompiler.Compile(System.String)">
            <summary>
            Create a TregexPattern from this tregex string using the headFinder and
            basicCat function this TregexPatternCompiler was created with.
            Implementation note: If there is an invalid token in the Tregex
            parser, JavaCC will throw a TokenMgrError.  This is a class
            that extends Error, not Exception (OMG! - bad!), and so rather than
            requiring clients to catch it, we wrap it in a ParseException.
            (The original Error's are thrown in TregexParserTokenManager.)
            </summary>
            <param name="tregex">The pattern to parse</param>
            <returns>A new TregexPattern object based on this string</returns>
            <exception cref="T:OpenNLP.Tools.Trees.TRegex.TregexParseException">If the expression is syntactically invalid</exception>
        </member>
        <member name="T:OpenNLP.Tools.Trees.TRegex.Tsurgeon.AdjoinNode">
            <summary>
            Adjoin in a tree (like in TAG).
            
            @author Roger Levy (rog@nlp.stanford.edu)
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.TRegex.Tsurgeon.AdjoinToFootNode">
            <summary>
            Adjoin in a tree (like in TAG), but retain the target of adjunction as the foot of the auxiliary tree.
            
            @author Roger Levy (rog@nlp.stanford.edu)
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.TRegex.Tsurgeon.AdjoinToHeadNode">
            <summary>
            Adjoin in a tree (like in TAG), but retain the target of adjunction as the root of the auxiliary tree.
            
            @author Roger Levy (rog@nlp.stanford.edu)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Tsurgeon.AuxiliaryTree.Copy(OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonMatcher)">
            <summary>
            Copies the Auxiliary tree.  Also, puts the new names->nodes map in the TsurgeonMatcher that called copy.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Tsurgeon.AuxiliaryTree.FindFootNode(OpenNLP.Tools.Trees.Tree)">
            <summary>
            Returns the foot node of the adjunction tree, which is the terminal node
            that ends in @.  In the process, turns the foot node into a TreeNode
            (rather than a leaf), and destructively un-escapes all the escaped
            instances of @ in the tree.  Note that readonly @ in a non-terminal node is
            ignored, and left in.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.AuxiliaryTree.NamePattern">
            <summary>
            There are two ways in which you can can match the start of a name expression.
            The first is if you have any number of non-escaping characters
            preceding an "=" and a name.  This is the ([^\\\\]*) part.
            The second is if you have any number of any characters, followed
            by a non-"\" character, as "\" is used to escape the "=".  After
            that, any number of pairs of "\" are allowed, as we let "\" also
            escape itself.  After that comes "=" and a name.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Tsurgeon.AuxiliaryTree.InitializeNamesNodesMaps(OpenNLP.Tools.Trees.Tree)">
            <summary>
            Looks for new names, destructively strips them out.
            Destructively unescapes escaped chars, including "=", as well.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.CoindexationGenerator.coindexationPattern">
            <summary>
            We require at least one character before the - so that negative
            numbers do not get treated as indexed nodes.  This seems more
            likely than a node having an index on an otherwise blank label.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.TRegex.Tsurgeon.CreateSubtreeNode">
            <summary>
            Given the start and end children of a particular node, takes all
            children between start and end (including the endpoints) and
            combines them in a new node with the given label.
            
            @author John Bauer
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Tsurgeon.CreateSubtreeNode.FindFoot">
            We want to support a command syntax where a simple node label can
            be given (i.e., without using a tree literal).
            
            Check if this syntax is being used, and simulate a foot if so.
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Tsurgeon.CreateSubtreeNode.Matcher.Evaluate(OpenNLP.Tools.Trees.Tree,OpenNLP.Tools.Trees.TRegex.TregexMatcher)">
            Combines all nodes between start and end into one subtree, then
            replaces those nodes with the new subtree in the corresponding
            location under parent
        </member>
        <member name="T:OpenNLP.Tools.Trees.TRegex.Tsurgeon.ExciseNode">
            <summary>
            Excises all nodes from the top to the bottom, and puts all the children of bottom node in where the top was.
            
            @author Roger Levy (rog@stanford.edu)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Tsurgeon.ExciseNode.#ctor(OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonPattern,OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonPattern)">
            <summary>
            Top should evaluate to a node that dominates bottom, but this is not checked!
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Tsurgeon.ExciseNode.#ctor(OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonPattern)">
            <summary>
            Excises only the directed node
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.TRegex.Tsurgeon.IfExistsNode">
            <summary>
            Executes the give children only if the named Tregex node exists in
            the TregexMatcher at match time (allows for OR relations or
            optional relations)
            
            @author John Bauer (horatio@gmail.com)
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.TRegex.Tsurgeon.INode">
            <summary>
            All AST nodes must implement this interface.  It provides basic
            machinery for constructing the parent and child relationships
            between nodes.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Tsurgeon.INode.JjtOpen">
            <summary>
            This method is called after the node has been made the current node.
            It indicates that child nodes can now be added to it
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Tsurgeon.INode.JjtClose">
            <summary>
            This method is called after all the child nodes have been added
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Tsurgeon.INode.JjtSetParent(OpenNLP.Tools.Trees.TRegex.Tsurgeon.INode)">
            <summary>
            This pair of methods are used to inform the node of its parent
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Tsurgeon.INode.JjtAddChild(OpenNLP.Tools.Trees.TRegex.Tsurgeon.INode,System.Int32)">
            <summary>
            This method tells the node to add its argument to the node's list of children
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Tsurgeon.INode.JjtGetChild(System.Int32)">
            <summary>
            This method returns a child node.  The children are numbered from zero, left to right
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Tsurgeon.INode.JjtGetNumChildren">
            <summary>
            Return the number of children the node has
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.JjtTsurgeonParserState.sp">
            <summary>number of nodes on stack</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.JjtTsurgeonParserState.mk">
            <summary>current mark</summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Tsurgeon.JjtTsurgeonParserState.NodeCreated">
            <summary>
            Determines whether the current node was actually closed and pushed.
            This should only be called in the final user action of a node scope.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Tsurgeon.JjtTsurgeonParserState.Reset">
            <summary>
            Call this to reinitialize the node stack.
            It is called automatically by the parser's ReInit() method.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Tsurgeon.JjtTsurgeonParserState.RootNode">
            <summary>
            Returns the root node of the AST.  It only makes sense to call this after a successful parse.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Tsurgeon.JjtTsurgeonParserState.PushNode(OpenNLP.Tools.Trees.TRegex.Tsurgeon.INode)">
            <summary>
            Pushes a node on to the stack
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Tsurgeon.JjtTsurgeonParserState.PopNode">
            <summary>
            Returns the node on the top of the stack, and remove it from the stack.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Tsurgeon.JjtTsurgeonParserState.PeekNode">
            <summary>
            Returns the node currently on the top of the stack.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Tsurgeon.JjtTsurgeonParserState.NodeArity">
            <summary>
            Returns the number of children on the stack in the current node scope.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Tsurgeon.JjtTsurgeonParserState.CloseNodeScope(OpenNLP.Tools.Trees.TRegex.Tsurgeon.INode,System.Int32)">
            <summary>
            A definite node is constructed from a specified number of children.
            That number of nodes are popped from the stack and
            made the children of the definite node.
            Then the definite node is pushed on to the stack.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Tsurgeon.JjtTsurgeonParserState.CloseNodeScope(OpenNLP.Tools.Trees.TRegex.Tsurgeon.INode,System.Boolean)">
            <summary>
            A conditional node is constructed if its condition is true.
            All the nodes that have been pushed since the node was opened are
            made children of the conditional node, which is then pushed
            on to the stack.  If the condition is false the node is not
            constructed and they are left on the stack.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.TRegex.Tsurgeon.MoveNode">
            <summary>
            Does a delete (NOT prune!) + insert operation
            
            @author Roger Levy (rog@stanford.edu)
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.TRegex.Tsurgeon.PruneNode">
            <summary>
            Pruning differs from deleting in that if a non-terminal node winds up having no children, it is pruned as well.
            
            @author Roger Levy (rog@nlp.stanford.edu)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.RelabelNode.RegexPatternString">
            <summary>
            Overly complicated pattern to identify regexes surrounded by /,
            possibly with / escaped inside the regex.  
            The purpose of the [^/]*[^/\\\\] is to match characters that
            aren't / and to allow escaping of other characters.
            The purpose of the \\\\/ is to allow escaped / inside the pattern.
            The purpose of the \\\\\\\\ is to allow escaped \ at the end of
            the pattern, so you can match, for example, /\\/.  There need to
            be 8x\ because both java and regexes need escaping, resulting in 4x.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.RelabelNode.NodePatternString">
            <summary>
            This pattern finds relabel snippets that use a named node.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.RelabelNode.VariablePatternString">
            <summary>
            This pattern finds relabel snippets that use a captured variable
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.RelabelNode.OneGeneralReplacement">
            <summary>
            Finds one chunk of a general relabel operation, either named node or captured variable
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.RelabelNode.SubstPattern">
            <summary>
            Identifies a node using the regex replacement strategy
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TreeLocation.LocationMatcher">
            TODO: it would be nice to refactor this with TsurgeonMatcher somehow 
        </member>
        <member name="T:OpenNLP.Tools.Trees.TRegex.Tsurgeon.Tsurgeon">
            <summary>
            Tsurgeon provides a way of editing trees based on a set of operations that
            are applied to tree locations matching a tregex pattern.
            A simple example from the command-line:
            <blockquote>
            java edu.stanford.nlp.trees.tregex.tsurgeon.Tsurgeon -treeFile atree exciseNP renameVerb
            </blockquote>
            
            The file {@code atree} has Penn Treebank (S-expression) format trees.
            The other (here, two) files have Tsurgeon operations.  These consist of
            a list of pairs of a tregex expression on one or more
            lines, a blank line, and then some number of lines of Tsurgeon operations and then
            another blank line.
            
            Tsurgeon uses the Tregex engine to match tree patterns on trees;
            for more information on Tregex's tree-matching functionality,
            syntax, and semantics, please see the documentation for the
            {@link TregexPattern} class.
            
            If you want to use Tsurgeon as an API, the relevant method is
            {@link #processPattern}.  You will also need to look at the
            {@link TsurgeonPattern} class and the {@link Tsurgeon#parseOperation} method.
            
            Here's the simplest form of invocation on a single Tree:
            <pre>
            Tree t = Tree.valueOf("(ROOT (S (NP (NP (NNP Bank)) (PP (IN of) (NP (NNP America)))) (VP (VBD called)) (. .)))");
            TregexPattern pat = TregexPattern.compile("NP &lt;1 (NP &lt;&lt; Bank) &lt;2 PP=remove");
            TsurgeonPattern surgery = Tsurgeon.parseOperation("excise remove remove");
            Tsurgeon.processPattern(pat, surgery, t).pennPrint();
            </pre>
            
            Here is another sample invocation:
            <pre>
            TregexPattern matchPattern = TregexPattern.compile("SQ=sq &lt; (/^WH/ $++ VP)");
            List&lt;TsurgeonPattern&gt; ps = new ArrayList&lt;TsurgeonPattern&gt;();
            TsurgeonPattern p = Tsurgeon.parseOperation("relabel sq S");
            ps.add(p);
            
            Treebank lTrees;
            List&lt;Tree&gt; result = Tsurgeon.processPatternOnTrees(matchPattern,Tsurgeon.collectOperations(ps),lTrees);
            </pre>
            
            Note: If you want to apply multiple surgery patterns, you
            will not want to call processPatternOnTrees, for each individual
            pattern.  Rather, you should either call processPatternsOnTree and
            loop through the trees yourself, or, as above, use
            <code>collectOperations</code> to collect all the surgery patterns
            into one TsurgeonPattern, and then to call processPatternOnTrees.
            Either of these latter methods is much faster.
            
            The parser also has the ability to collect multiple
            TsurgeonPatterns into one pattern by itself by enclosing each
            pattern in <code>[ ... ]</code>.  For example,
            
            <code>Tsurgeon.parseOperation("[relabel foo BAR] [prune bar]")</code>
            
            For more information on using Tsurgeon from the command line,
            see the {@link #main} method and the package Javadoc.
            
            @author Roger Levy
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Tsurgeon.Tsurgeon.ProcessPatternOnTrees(OpenNLP.Tools.Trees.TRegex.TregexPattern,OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonPattern,System.Collections.Generic.List{OpenNLP.Tools.Trees.Tree})">
            <summary>
            Applies {#processPattern} to a collection of trees.
            </summary>
            <param name="matchPattern">A {@link TregexPattern} to be matched against a {@link Tree}.</param>
            <param name="p">A {@link TsurgeonPattern} to apply.</param>
            <param name="inputTrees">The input trees to be processed</param>
            <returns>A List of the transformed trees</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Tsurgeon.Tsurgeon.ProcessPattern(OpenNLP.Tools.Trees.TRegex.TregexPattern,OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonPattern,OpenNLP.Tools.Trees.Tree)">
            <summary>
            Tries to match a pattern against a tree.  If it succeeds, apply the surgical operations contained in a {@link TsurgeonPattern}.
            </summary>
            <param name="matchPattern">A {@link TregexPattern} to be matched against a {@link Tree}.</param>
            <param name="p">A {@link TsurgeonPattern} to apply.</param>
            <param name="t">the {@link Tree} to match against and perform surgery on.</param>
            <returns>t, which has been surgically modified.</returns>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.Tsurgeon.matchedOnTree">
            <summary>Hack-in field for seeing whether there was a match</summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Tsurgeon.Tsurgeon.ParseOperation(System.String)">
            <summary>
            Parses an operation string into a {@link TsurgeonPattern}.  Throws an {@link TsurgeonParseException} if
            the operation string is ill-formed.
            
            Example of use:
            TsurgeonPattern p = Tsurgeon.parseOperation("prune ed");
            </summary>
            <param name="operationString">The operation to perform, as a text string</param>
            <returns>the operation pattern</returns>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Tsurgeon.Tsurgeon.CollectOperations(System.Collections.Generic.List{OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonPattern})">
            <summary>
            Collects a list of operation patterns into a sequence of operations to be applied.
            Required to keep track of global properties across a sequence of operations.
            For example, if you want to insert a named node and then coindex it with another node,
            you will need to collect the insertion and coindexation operations into a single TsurgeonPattern so that tsurgeon is aware
            of the name of the new node and coindexation becomes possible.
            </summary>
            <param name="patterns">a list of {@link TsurgeonPattern} operations that you want to collect together into a single compound operation</param>
            <returns>a new {@link TsurgeonPattern} that performs all the operations in the sequence of the <code>patterns</code> argument</returns>
        </member>
        <member name="T:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonMatcher">
            <summary>
            An object factored out to keep the state of a <code>Tsurgeon</code>
            operation separate from the <code>TsurgeonPattern</code> objects.
            This makes it easier to reset state between invocations and makes
            it easier to use in a threadsafe manner.
            
            TODO: it would be nice to go through all the patterns and make sure
            they update <code>newNodeNames</code> or look for appropriate nodes
            in <code>newNodeNames</code> when possible.
            
            It would also be nicer if the call to <code>matcher()</code> took
            the tree &amp; tregex instead of <code>evaluate()</code>, but that
            is a little more complicated because of the way the
            <code>TsurgeonMatcher</code> is used in <code>Tsurgeon</code>.
            Basically, you would need to move that code from
            <code>Tsurgeon</code> to <code>TsurgeonMatcher</code>.
            
            @author John Bauer
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonMatcher.Evaluate(OpenNLP.Tools.Trees.Tree,OpenNLP.Tools.Trees.TRegex.TregexMatcher)">
            <summary>
            Evaluates the surgery pattern against a {@link Tree} and a {@link TregexMatcher}
            that has been successfully matched against the tree.
            </summary>
            <param name="tree">
            The {@link Tree} that has been matched upon; typically this tree will be destructively modified.
            </param>
            <param name="tregex">The successfully matched {@link TregexMatcher}.</param>
            <returns>
            Some node in the tree; depends on implementation and use of the specific subclass.
            </returns>
        </member>
        <member name="T:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParseException">
            <summary>
             A runtime exception that indicates something went wrong parsing a
            Tsurgeon expression.  The purpose is to make those exceptions
            unchecked exceptions, as there are only a few circumstances in
            which one could recover.
            
            @author John Bauer
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParser.token_source">
            <summary>Generated Token Manager</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParser.token">
            <summary>Current token</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParser.jj_nt">
            <summary>Next token</summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParser.#ctor(System.IO.Stream)">
            <summary>Constructor with Stream</summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParser.#ctor(System.IO.Stream,System.String)">
            <summary>Constructor with Stream</summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParser.#ctor(System.IO.TextReader)">
            <summary>Constructor with TextReader</summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParser.Jj_consume_token(System.Int32)">
            Reinitialise. 
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParser.GetNextToken">
            <summary>
            Get the next Token
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParser.Jj_ntk_f">
            Get the specific Token. 
        </member>
        <member name="T:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParserConstants">
            <summary>
            Token literal values and constants.
            Generated by org.javacc.parser.OtherFilesGen#start()
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParserConstants.Eof">
            <summary>End of File</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParserConstants.OpenBracket">
            <summary>RegularExpression Id</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParserConstants.If">
            <summary>RegularExpression Id</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParserConstants.Not">
            <summary>RegularExpression Id</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParserConstants.Exists">
            <summary>RegularExpression Id</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParserConstants.Delete">
            <summary>RegularExpression Id</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParserConstants.Prune">
            <summary>RegularExpression Id</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParserConstants.Relabel">
            <summary>RegularExpression Id</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParserConstants.Excise">
            <summary>RegularExpression Id</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParserConstants.Insert">
            <summary>RegularExpression Id</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParserConstants.Move">
            <summary>RegularExpression Id</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParserConstants.Replace">
            <summary>RegularExpression Id</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParserConstants.CreateSubtree">
            <summary>RegularExpression Id</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParserConstants.Adjoin">
            <summary>RegularExpression Id</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParserConstants.AdjoinToHead">
            <summary>RegularExpression Id</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParserConstants.AdjoinToFoot">
            <summary>RegularExpression Id</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParserConstants.Coindex">
            <summary>RegularExpression Id</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParserConstants.Name">
            <summary>RegularExpression Id</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParserConstants.CloseBracket">
            <summary>RegularExpression Id</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParserConstants.Selection">
            <summary>RegularExpression Id</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParserConstants.GeneralRelabel">
            <summary>RegularExpression Id</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParserConstants.Identifier">
            <summary>RegularExpression Id</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParserConstants.LocationRelation">
            <summary>RegularExpression Id</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParserConstants.Regex">
            <summary>RegularExpression Id</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParserConstants.Quotex">
            <summary>RegularExpression Id</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParserConstants.HashInteger">
            <summary>RegularExpression Id</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParserConstants.TreeNodeTerminalLabel">
            <summary>RegularExpression Id</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParserConstants.TreeNodeNonterminalLabel">
            <summary>RegularExpression Id</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParserConstants.CloseParen">
            <summary>RegularExpression Id</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParserConstants.Operation">
            <summary>Lexical state</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParserConstants.Conditional">
            <summary>Lexical state</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParserConstants.Default">
            <summary>Lexical state</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParserConstants.TokenImages">
            <summary>Literal token values</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParserTokenManager.JjStrLiteralImages">
            <summary>Token literal values</summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParserTokenManager.GetNextToken">
            <summary>Get the next Token</summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParserTokenManager.#ctor(OpenNLP.Tools.Trees.TRegex.SimpleCharStream)">
            <summary>Constructor</summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParserTokenManager.#ctor(OpenNLP.Tools.Trees.TRegex.SimpleCharStream,System.Int32)">
            <summary>Constructor</summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParserTokenManager.ReInit(OpenNLP.Tools.Trees.TRegex.SimpleCharStream)">
            <summary>Reinitialise parser</summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParserTokenManager.ReInit(OpenNLP.Tools.Trees.TRegex.SimpleCharStream,System.Int32)">
            <summary>Reinitialise parser</summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParserTokenManager.SwitchTo(System.Int32)">
            <summary>Switch to specified lex state</summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParserTokenManager.LexStateNames">
            <summary>
            Lexer state names.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonParserTokenManager.JjnewLexState">
            <summary>
            Lex State array
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonPattern">
            <summary>
            An abstract class for patterns to manipulate {@link Tree}s when
            successfully matched on with a {@link TregexMatcher}.
            
            @author Roger Levy
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonPattern.#ctor(System.String,OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonPattern[])">
            <summary>
            In some cases, the order of the children has special meaning.
            For example, in the case of ReplaceNode, the first child will
            evaluate to the node to be replaced, and the other(s) will
            evaluate to the replacement.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonPatternRoot.SetCoindexes">
            <summary>
            If one of the children is a CoindexNodes (or something else that
            wants coindexing), it can call this at the time of setRoot()
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonPatternRoot.Matcher.Evaluate(OpenNLP.Tools.Trees.Tree,OpenNLP.Tools.Trees.TRegex.TregexMatcher)">
            <summary>
            Returns null if one of the surgeries eliminates the tree entirely.
            The operated-on tree is not to be trusted in this instance.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonRuntimeException">
            <summary>
            Something has gone wrong internally in Tsurgeon
            
            @author John Bauer
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.TRegex.Tsurgeon.TsurgeonRuntimeException.#ctor(System.String)">
            <summary>
            Creates a new exception with a message.
            </summary>
            <param name="message">the message for the exception</param>
        </member>
        <member name="T:OpenNLP.Tools.Trees.TRegex.VariableStrings">
            <summary>
             A class that takes care of the stuff necessary for variable strings.
            
             @author Roger Levy (rog@nlp.stanford.edu)
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.TypedDependency">
            <summary>
            A <code>TypedDependency</code> is a relation between two words in a
            <code>GrammaticalStructure</code>.  Each <code>TypedDependency</code>
            consists of a governor word, a dependent word, and a relation, which is
            normally an instance of {@link GrammaticalRelation
            <code>GrammaticalRelation</code>}.
            
            @author Bill MacCartney
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.UnnamedConcreteDependency">
            <summary>
            An individual dependency between a head and a dependent. The dependency 
            is associated with the token indices of the lexical items. 
            A key difference between this class and UnnamedDependency is the equals() method. 
            Equality of two UnnamedConcreteDependency objects is defined solely 
            with respect to the indices. The surface forms are not considered. 
            This permits a use case in which dependencies in two different parse trees have slightly different 
            pre-processing, possibly due to pre-processing.
            
            @author Spence Green
            
            Code..
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.UnnamedConcreteDependency.ToString(System.String)">
            <summary>
            Provide different printing options via a string keyword.
            The recognized options are currently "xml", and "predicate".
            Otherwise the default ToString() is used.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.UnnamedConcreteDependency.UnnamedConcreteDependencyFactory">
            <summary>
            A <code>DependencyFactory</code> acts as a factory for creating objects
            of class <code>Dependency</code>
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.UnnamedConcreteDependency.UnnamedConcreteDependencyFactory.NewDependency(OpenNLP.Tools.Ling.ILabel,OpenNLP.Tools.Ling.ILabel)">
            <summary>
            Create a new <code>Dependency</code>.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.UnnamedConcreteDependency.UnnamedConcreteDependencyFactory.NewDependency(OpenNLP.Tools.Ling.ILabel,OpenNLP.Tools.Ling.ILabel,System.Object)">
            <summary>
            Create a new <code>Dependency</code>.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Trees.UnnamedDependency">
            <summary>
            An individual dependency between a head and a dependent.
            The head and dependent are represented as a Label.
            For example, these can be a Word or a WordTag. 
            If one wishes the dependencies to preserve positions 
            in a sentence, then each can be a LabeledConstituent. 
            
            @author Christopher Manning
            @author Spence Green
            
            Code ...
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.UnnamedDependency.ToString(System.String)">
            Provide different printing options via a string keyword.
            The recognized options are currently "xml", and "predicate".
            Otherwise the default ToString() is used.
        </member>
        <member name="T:OpenNLP.Tools.Trees.UnnamedDependency.UnnamedDependencyFactory">
            <summary>
            A <code>DependencyFactory</code> acts as a factory for creating objects 
            of class <code>Dependency</code>
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.UnnamedDependency.UnnamedDependencyFactory.NewDependency(OpenNLP.Tools.Ling.ILabel,OpenNLP.Tools.Ling.ILabel)">
            <summary>
            Create a new <code>Dependency</code>.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Trees.UnnamedDependency.UnnamedDependencyFactory.NewDependency(OpenNLP.Tools.Ling.ILabel,OpenNLP.Tools.Ling.ILabel,System.Object)">
            <summary>
            Create a new <code>Dependency</code>.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Util.AbstractCollection`1">
            <summary>
            This class provides a skeletal implementation of the <tt>Collection</tt> interface, 
            to minimize the effort required to implement this interface.
            
            To implement an unmodifiable collection, the programmer needs only to extend 
            this class and provide implementations for the <tt>iterator</tt> and <tt>size</tt> methods.
            (The iterator returned by the <tt>iterator</tt> method must implement <tt>hasNext</tt> and <tt>next</tt>.)
            
            To implement a modifiable collection, the programmer must additionally
            override this class's <tt>add</tt> method (which otherwise throws an <tt>UnsupportedOperationException</tt>),
            and the iterator returned by the <tt>iterator</tt> method must additionally implement its <tt>remove</tt> method.
            
            The programmer should generally provide a void (no argument) and <tt>Collection</tt> constructor,
            as per the recommendation in the <tt>Collection</tt> interface specification.
            
            The documentation for each non-abstract method in this class describes its implementation in detail.
            Each of these methods may be overridden if the collection being implemented admits a more efficient implementation.
            
            This class is a member of the <a href="{@docRoot}/../technotes/guides/collections/index.html">Java Collections Framework</a>.
            
            @author  Josh Bloch
            @author  Neal Gafter
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.AbstractCollection`1.Any">
            <summary>
            This implementation returns <tt>size() == 0</tt>.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.AbstractCollection`1.Contains(`0)">
            <summary>
            This implementation iterates over the elements in the collection,
            checking each element in turn for equality with the specified element.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.AbstractCollection`1.ToArray">
            <summary>
            This implementation returns an array containing all the elements
            returned by this collection's iterator, in the same order, 
            stored in consecutive elements of the array, starting with index {@code 0}.
            The length of the returned array is equal to the number of elements returned by the iterator, 
            even if the size of this collection changes during iteration, 
            as might happen if the collection permits concurrent modification during iteration.
            The {@code size} method is called only as an optimization hint; 
            the correct result is returned even if the iterator returns a different number of elements.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Util.AbstractCollection`1.MaxArraySize">
            <summary>
            The maximum size of array to allocate.
            Some VMs reserve some header words in an array.
            Attempts to allocate larger arrays may result in
            OutOfMemoryError: Requested array size exceeds VM limit
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.AbstractCollection`1.Add(`0)">
             Reallocates the array being used within toArray when the iterator
             returned more elements than expected, and finishes filling it from
             the iterator.
            
             @param r the array, replete with previously stored elements
             @param it the in-progress iterator over this collection
             @return array containing the elements in the given array, plus any
                     further elements returned by the iterator, trimmed to size
        </member>
        <member name="M:OpenNLP.Tools.Util.AbstractCollection`1.ContainsAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            This implementation iterates over the specified collection,
            checking each element returned by the iterator in turn to see 
            if it's contained in this collection.
            If all elements are so contained <tt>true</tt> is returned, otherwise <tt>false</tt>.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.AbstractCollection`1.AddAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            This implementation iterates over the specified collection, 
            and adds each object returned by the iterator to this collection, in turn.
            
            Note that this implementation will throw an <tt>UnsupportedOperationException</tt> 
            unless <tt>add</tt> is overridden (assuming the specified collection is non-empty).
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.AbstractCollection`1.GetEnumerator">
             Returns a string representation of this collection.  The string
             representation consists of a list of the collection's elements in the
             order they are returned by its iterator, enclosed in square brackets
             (<tt>"[]"</tt>).  Adjacent elements are separated by the characters
             <tt>", "</tt> (comma and space).  Elements are converted to strings as
             by {@link String#valueOf(Object)}.
            
             @return a string representation of this collection
        </member>
        <member name="T:OpenNLP.Tools.Util.ArrayCoreMap">
            <summary>
            Base implementation of {@link CoreMap} backed by two Java arrays.
            
            Reasonable care has been put into ensuring that this class is both fast and
            has a light memory footprint.
            
            Note that like the base classes in the Collections API, this implementation
            is <em>not thread-safe</em>. For speed reasons, these methods are not
            synchronized. A synchronized wrapper could be developed by anyone so inclined.
            
            Equality is defined over the complete set of keys and values currently
            stored in the map.  Because this class is mutable, it should not be used
            as a key in a Map.
            
            @author dramage
            @author rafferty
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Util.ArrayCoreMap.InitialCapacity">
            <summary>Initial capacity of the array</summary>
        </member>
        <member name="F:OpenNLP.Tools.Util.ArrayCoreMap.keys">
            <summary>Array of keys</summary>
        </member>
        <member name="F:OpenNLP.Tools.Util.ArrayCoreMap.values">
            Array of values 
        </member>
        <member name="P:OpenNLP.Tools.Util.ArrayCoreMap.psize">
            <summary>Total number of elements actually in keys,values</summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.ArrayCoreMap.#ctor">
            <summary>
            Default constructor - initializes with default initial annotation capacity of 4.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.ArrayCoreMap.#ctor(System.Int32)">
            <summary>
            Initializes this ArrayCoreMap, pre-allocating arrays to hold up to capacity key,value pairs.
            This array will grow if necessary.
            </summary>
            <param name="capacity">Initial capacity of object in key,value pairs</param>
        </member>
        <member name="M:OpenNLP.Tools.Util.ArrayCoreMap.#ctor(OpenNLP.Tools.Util.ArrayCoreMap)">
            <summary>
            Copy constructor.
            </summary>
            <param name="other">The ArrayCoreMap to copy. It may not be null.</param>
        </member>
        <member name="M:OpenNLP.Tools.Util.ArrayCoreMap.#ctor(OpenNLP.Tools.Util.ICoreMap)">
            <summary>
            Copy constructor.
            </summary>
            <param name="other">The ArrayCoreMap to copy. It may not be null.</param>
        </member>
        <member name="M:OpenNLP.Tools.Util.ArrayCoreMap.Compact">
            <summary>
            Reduces memory consumption to the minimum for representing 
            the values currently stored stored in this object.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Util.ArrayCoreMap.ToStringCalled">
            <summary>
            Keeps track of which ArrayCoreMaps have had ToString called on them.
            We do not want to loop forever when there are cycles in the annotation graph.
            This is kept on a per-thread basis so that each thread 
            where ToString gets called can keep track of its own state.
            When a call to ToString is about to return, this is reset to null for that particular thread.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.ArrayCoreMap.ToShortString(System.String[])">
            <summary>
            This gives a very short string representation of a CoreMap
            by leaving it to the content to reveal what field is being printed.
            </summary>
            <param name="what">
            An array (varargs) of strings that say what annotation keys to print.
            These need to be provided in a shortened form where you are just giving 
            the part of the class name without package and up to "Annotation".
            That is, edu.stanford.nlp.ling.CoreAnnotations.PartOfSpeechAnnotation -> PartOfSpeech.
            As a special case, an empty array means to print everything, not nothing.
            </param>
            <returns>
            Brief string where the field values are just separated by a character.
            If the string contains spaces, it is wrapped in "{...}".
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.ArrayCoreMap.ToShortString(System.Char,System.String[])">
            <summary>
            This gives a very short string representation of a CoreMap
            by leaving it to the content to reveal what field is being printed.
            </summary>
            <param name="separator">Character placed between fields in output</param>
            <param name="what">
            An array (varargs) of strings that say what annotation keys to print.
            These need to be provided in a shortened form where you are just giving 
            the part of the class name without package and up to "Annotation". 
            That is, edu.stanford.nlp.ling.CoreAnnotations.PartOfSpeechAnnotation -> PartOfSpeech.
            As a special case, an empty array means to print everything, not nothing.
            </param>
            <returns>
            Brief string where the field values are just separated by a character. 
            If the string contains spaces, it is wrapped in "{...}".
            </returns>
        </member>
        <member name="F:OpenNLP.Tools.Util.ArrayCoreMap.EqualsCalled">
            <summary>
            Keeps track of which pairs of ArrayCoreMaps have had equals called on them.
            We do not want to loop forever when there are cycles in the annotation graph.
            This is kept on a per-thread basis so that each thread where equals gets called can keep track of its own state.
            When a call to ToString is about to return, this is reset to null for that particular thread.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.ArrayCoreMap.Equals(System.Object)">
            <summary>Two CoreMaps are equal iff all keys and values are .equal.</summary>
        </member>
        <member name="F:OpenNLP.Tools.Util.ArrayCoreMap.HashCodeCalled">
            <summary>
            Keeps track of which ArrayCoreMaps have had hashCode called on them.
            We do not want to loop forever when there are cycles in the annotation graph.
            This is kept on a per-thread basis so that each thread where hashCode gets called can keep track of its own state.
            When a call to ToString is about to return, this is reset to null for that particular thread.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Util.BeamSearch">
            <summary>
            Performs k-best search over sequence.  This is besed on the description in
            Ratnaparkhi (1998), PhD diss, Univ. of Pennsylvania. 
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.BeamSearch.#ctor(System.Int32,OpenNLP.Tools.Util.IBeamSearchContextGenerator,SharpEntropy.IMaximumEntropyModel)">
            <summary>Creates new search object</summary>
            <param name="size">The size of the beam (k)</param>
            <param name="contextGenerator">the context generator for the model</param>
            <param name="model">the model for assigning probabilities to the sequence outcomes</param>
        </member>
        <member name="M:OpenNLP.Tools.Util.BeamSearch.#ctor(System.Int32,OpenNLP.Tools.Util.IBeamSearchContextGenerator,SharpEntropy.IMaximumEntropyModel,System.Int32)">
            <summary>Creates new search object</summary>
            <param name="size">The size of the beam (k)</param>
            <param name="contextGenerator">the context generator for the model</param>
            <param name="model">the model for assigning probabilities to the sequence outcomes</param>
            <param name="cacheSizeInMegaBytes">size of the cache to use for performance</param>
        </member>
        <member name="M:OpenNLP.Tools.Util.BeamSearch.BestSequences(System.Int32,System.String[],System.Object[])">
            <summary>
            Returns the best sequence of outcomes based on model for this object.
            </summary>
            <param name="numSequences">The maximum number of sequences to be returned</param>
            <param name="sequence">The input sequence</param>
            <param name="additionalContext">
            An object[] of additional context.
            This is passed to the context generator blindly with the assumption that the context are appropiate.
            </param>
            <returns>An array of the top ranked sequences of outcomes</returns>		
        </member>
        <member name="M:OpenNLP.Tools.Util.BeamSearch.BestSequences(System.Int32,System.String[],System.Object[],System.Double)">
            <summary>
            Returns the best sequence of outcomes based on model for this object.</summary>
            <param name="numSequences">The maximum number of sequences to be returned</param>
            <param name="sequence">The input sequence</param>
            <param name="additionalContext">
            An object[] of additional context.  This is passed to the context generator blindly with the assumption that the context are appropiate.
            </param>
            <param name="minSequenceScore">A lower bound on the score of a returned sequence</param>
            <returns>An array of the top ranked sequences of outcomes</returns>		
        </member>
        <member name="M:OpenNLP.Tools.Util.BeamSearch.BestSequence(System.String[],System.Object[])">
            <summary>
            Returns the best sequence of outcomes based on model for this object.
            </summary>
            <param name="sequence">The input sequence</param>
            <param name="additionalContext">
            An object[] of additional context.
            This is passed to the context generator blindly with the assumption that the context are appropiate.
            </param>
            <returns>The top ranked sequence of outcomes</returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.BeamSearch.ValidSequence(System.Int32,System.Collections.ArrayList,OpenNLP.Tools.Util.Sequence,System.String)">
            <summary>
            Determines whether a particular continuation of a sequence is valid.  
            This is used to restrict invalid sequences such as thoses used in start/continue tag-based chunking 
            or could be used to implement tag dictionary restrictions.
            </summary>
            <param name="index">The index in the input sequence for which the new outcome is being proposed</param>
            <param name="inputSequence">The input sequnce</param>
            <param name="outcomesSequence">The outcomes so far in this sequence</param>
            <param name="outcome">The next proposed outcome for the outcomes sequence</param>
            <returns>true if the sequence would still be valid with the new outcome, false otherwise</returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.BeamSearch.ValidSequence(System.Int32,System.Object[],System.String[],System.String)">
            <summary>
            Determines whether a particular continuation of a sequence is valid.  
            This is used to restrict invalid sequences such as thoses used in start/continure tag-based chunking 
            or could be used to implement tag dictionary restrictions.
            </summary>
            <param name="index">The index in the input sequence for which the new outcome is being proposed</param>
            <param name="inputSequence">The input sequnce</param>
            <param name="outcomesSequence">The outcomes so far in this sequence</param>
            <param name="outcome">The next proposed outcome for the outcomes sequence</param>
            <returns>true if the sequence would still be valid with the new outcome, false otherwise</returns>
        </member>
        <member name="T:OpenNLP.Tools.Util.BinaryHeapPriorityQueue`1">
            <summary>
            PriorityQueue with explicit double priority values.  Larger doubles are higher priorities.  BinaryHeap-backed.
            For each entry, uses ~ 24 (entry) + 16? (Map.Entry) + 4 (List entry) = 44 bytes?
            
            @author Dan Klein
            @author Christopher Manning
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
            <typeparam name="E">Type of elements in the priority queue</typeparam>
        </member>
        <member name="T:OpenNLP.Tools.Util.BinaryHeapPriorityQueue`1.Entry`1">
            <summary>
            An {@code Entry} stores an object in the queue along with
            its current location (array position) and priority.
            uses ~ 8 (self) + 4 (key ptr) + 4 (index) + 8 (priority) = 24 bytes?
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Util.BinaryHeapPriorityQueue`1.indexToEntry">
            <summary>
            {@code indexToEntry} maps linear array locations (not priorities) to heap entries.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Util.BinaryHeapPriorityQueue`1.keyToEntry">
            <summary>
            {@code keyToEntry} maps heap objects to their heap entries.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.BinaryHeapPriorityQueue`1.Swap(OpenNLP.Tools.Util.BinaryHeapPriorityQueue{`0}.Entry{`0},OpenNLP.Tools.Util.BinaryHeapPriorityQueue{`0}.Entry{`0})">
            <summary>Structural swap of two entries.</summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.BinaryHeapPriorityQueue`1.RemoveLastEntry">
            <summary>Remove the last element of the heap (last in the index array)</summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.BinaryHeapPriorityQueue`1.GetEntry(`0)">
            <summary>Get the entry by key (null if none)</summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.BinaryHeapPriorityQueue`1.GetEntry(System.Int32)">
            <summary>Get entry by index, exception if none.</summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.BinaryHeapPriorityQueue`1.HeapifyUp(OpenNLP.Tools.Util.BinaryHeapPriorityQueue{`0}.Entry{`0})">
            <summary>iterative heapify up: move item o at index up until correctly placed</summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.BinaryHeapPriorityQueue`1.HeapifyDown(OpenNLP.Tools.Util.BinaryHeapPriorityQueue{`0}.Entry{`0})">
            <summary>
            On the assumption that leftChild(entry) and rightChild(entry) satisfy the heap property,
            make sure that the heap at entry satisfies this property by possibly
            percolating the element entry downwards.  I've replaced the obvious
            recursive formulation with an iterative one to gain (marginal) speed.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.BinaryHeapPriorityQueue`1.RemoveFirst">
            <summary>
            Finds the E with the highest priority, removes it, and returns it.
            </summary>
            <returns>the E with highest priority</returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.BinaryHeapPriorityQueue`1.GetFirst">
            <summary>
            Finds the E with the highest priority and returns it, without modifying the queue.
            </summary>
            <returns>the E with minimum key</returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.BinaryHeapPriorityQueue`1.GetObject(`0)">
            <summary>
            Searches for the object in the queue and returns it. 
            May be useful if you can create a new object that is .equals() to an object in the queue
            but is not actually identical, or if you want to modify an object that is in the queue.
            </summary>
            <returns>null if the object is not in the queue, otherwise returns the object.</returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.BinaryHeapPriorityQueue`1.Add(`0)">
            <summary>
            Adds an object to the queue with the minimum priority (Double.NEGATIVE_INFINITY).
            If the object is already in the queue with worse priority, this does nothing.  
            If the object is already present, with better priority, it will NOT cause an a decreasePriority.
            </summary>
            <param name="key">an <code>E</code> value</param>
            <returns>whether the key was present before</returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.BinaryHeapPriorityQueue`1.RelaxPriority(`0,System.Double)">
            <summary>
            Promotes a key in the queue, adding it if it wasn't there already.
            If the specified priority is worse than the current priority, nothing happens.
            Faster than add if you don't care about whether the key is new.
            </summary>
            <param name="key">an <code>Object</code> value</param>
            <returns>whether the priority actually improved.</returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.BinaryHeapPriorityQueue`1.DecreasePriority(`0,System.Double)">
            <summary>
            Demotes a key in the queue, adding it if it wasn't there already.
            If the specified priority is better than the current priority, nothing happens.
            If you decrease the priority on a non-present key, it will get added, but at it's old implicit priority of Double.NEGATIVE_INFINITY.
            </summary>
            <param name="key">an <code>Object</code> value</param>
            <returns>whether the priority actually improved.</returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.BinaryHeapPriorityQueue`1.ChangePriority(`0,System.Double)">
            <summary>
            Changes a priority, either up or down, adding the key it if it wasn't there already.
            </summary>
            <param name="key">an <code>Object</code> value</param>
            <returns>whether the priority actually changed.</returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.BinaryHeapPriorityQueue`1.IsEmpty">
            <summary>
            Checks if the queue is empty.
            </summary>
            <returns>a <code>bool</code> value</returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.BinaryHeapPriorityQueue`1.Size">
            <summary>
            Get the number of elements in the queue.
            </summary>
            <returns>queue size</returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.BinaryHeapPriorityQueue`1.Contains(`0)">
            <summary>
            Returns whether the queue contains the given key.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.BinaryHeapPriorityQueue`1.Clear">
            <summary>
            Clears the queue.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Util.Cache">
            <summary>
             Provides fixed size, pre-allocated, least recently used replacement cache.
             </summary>
        </member>
        <member name="F:OpenNLP.Tools.Util.Cache.mFirstElement">
            <summary>
            The element in the linked list which was most recently used.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Util.Cache.mLastElement">
            <summary>
            The element in the linked list which was least recently used.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Util.Cache.mLastKey">
            <summary>
            Temporary holder of the key of the least-recently-used element.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Util.Cache.mTempSwapWrapper">
            <summary>
            Temporary value used in swap.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Util.Cache.mWrappers">
            <summary>
            Holds the object wrappers which the keys are mapped to.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Util.Cache.mMap">
            <summary>
            Hashtable which stores the keys and values of the cache.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Util.Cache.mCacheSize">
            <summary>
            The size of the cache.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.Cache.#ctor(System.Int32)">
            <summary>
            Creates a new cache of the specified size.
            </summary>
            <param name="size">
            The size of the cache.
            </param>
        </member>
        <member name="T:OpenNLP.Tools.Util.DoubleLinkedListElement">
            <summary>
            An entry in a double-linked list.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Util.DoubleLinkedList">
            <summary>
            A double-linked list implementation.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Util.Cache`2.mMap">
            <summary>
            Hashtable which stores the keys of the cache.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Util.Cache`2.mList">
            <summary>
            Double-linked list which stores the values of the cache.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Util.Cache`2.mCacheSize">
            <summary>
            The size of the cache.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.Cache`2.#ctor(System.Int32)">
            <summary>
            Creates a new cache of the specified size.
            </summary>
            <param name="size">
            The size of the cache.
            </param>
        </member>
        <member name="T:OpenNLP.Tools.Util.CollectionEventReader">
            <summary>
            Creates an event stream out of a collection of events.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Util.CountedSet`1">
            <summary>
            Set which counts the number of times a values are added to it.  
            This value can be accessed with the GetCount method.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.CountedSet`1.#ctor">
            <summary> Creates a new counted set.</summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.CountedSet`1.#ctor(System.Int32)">
            <summary>
            Creates a new counted set of the specified initial size.
            </summary>
            <param name="size">
            The initial size of this set.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Util.CountedSet`1.Subtract(`0)">
            <summary>
            Reduces the count associated with this object by 1.  If this causes the count
            to become 0, then the object is removed form the set.
            </summary>
            <param name="item">The item whose count is being reduced.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Util.CountedSet`1.SetCount(`0,System.Int32)">
            <summary>
            Assigns the specified object the specified count in the set.
            </summary>
            <param name="item">
            The item to be added or updated in the set.
            </param>
            <param name="count">
            The count of the specified item.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Util.CountedSet`1.GetCount(`0)">
            <summary> Return the count of the specified object.</summary>
            <param name="item">the object whose count needs to be determined.
            </param>
            <returns> the count of the specified object.
            </returns>
        </member>
        <member name="T:OpenNLP.Tools.Util.Filters">
            <summary>
            Some simple implementations of the {@link java.util.function.Predicate} interface.
            
            @author Christopher Manning
            @version 1.0
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.Filters.AcceptFilter``1">
            <summary>
            The acceptFilter accepts everything.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.Filters.RejectFilter``1">
            <summary>
            The rejectFilter accepts nothing.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.Filters.CollectionAcceptFilter``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            The collectionAcceptFilter accepts a certain collection.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.Filters.CollectionRejectFilter``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            The collectionRejectFilter rejects a certain collection.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.Filters.AndFilter``1(System.Predicate{``0},System.Predicate{``0})">
            <summary>
            Filter that accepts only when both filters accept (AND).
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.Filters.OrFilter``1(System.Predicate{``0},System.Predicate{``0})">
            <summary>
            Filter that accepts when either filter accepts (OR).
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.Filters.NotFilter``1(System.Predicate{``0})">
            <summary>
            Filter that does the opposite of given filter (NOT).
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.Filters.SwitchedFilter``1(System.Predicate{``0},System.Boolean)">
            <summary>
            Filter that's either negated or normal as specified.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Util.HashableCoreMap">
            <summary>
             An extension of {@link ArrayCoreMap} with an immutable set of key,value
            pairs that is used for equality and hashcode comparisons.
            
            @author dramage
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Util.HashableCoreMap.immutableKeys">
            <summary>Set of immutable keys</summary>
        </member>
        <member name="F:OpenNLP.Tools.Util.HashableCoreMap.hashcode">
            <summary>Pre-computed hashcode</summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.HashableCoreMap.#ctor(System.Collections.Generic.Dictionary{System.Type,System.Object})">
            <summary>
            Creates an instance of HashableCoreMap with initial key,value pairs
            for the immutable, hashable keys as provided in the given map.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.HashableCoreMap.Set(System.Type,System.Object)">
            <summary>
            Sets the value associated with the given key; if the the key is one
            of the hashable keys, throws an exception.
            </summary>
            <exception cref="T:OpenNLP.Tools.Util.HashableCoreMap.HashableCoreMapException">Attempting to set the value for an immutable, hashable key.</exception>
        </member>
        <member name="T:OpenNLP.Tools.Util.HashableCoreMap.HashableCoreMapException">
            <summary>
            An exception thrown when attempting to change the value associated
            with an (immutable) hash key in a HashableCoreMap.
            
            @author dramage
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Util.HashList`2">
            <summary>
            Class which creates mapping between keys and a list of values.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Util.HashSet`1">
            <summary> 
            This class manages a hash set of elements.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.HashSet`1.#ctor">
            <summary>
            Creates a new hash set collection.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new hash set collection.
            </summary>
            <param name="collection">
            The collection to initialize the hash set with.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Util.HashSet`1.#ctor(System.Int32)">
            <summary>
            Creates a new hash set with the given capacity.
            </summary>
            <param name="capacity">
            The initial capacity of the hash set.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Util.HashSet`1.#ctor(System.Int32,System.Single)">
            <summary>
            Creates a new hash set with the given capacity.
            </summary>
            <param name="capacity">
            The initial capacity of the hash set.
            </param>
            <param name="loadFactor">
            The load factor of the hash set.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Util.HashSet`1.HashSetClone">
            <summary>
            Creates a copy of the HashSet.
            </summary>
            <returns> A copy of the HashSet.</returns>
        </member>
        <member name="T:OpenNLP.Tools.Util.IBeamSearchContextGenerator">
            <summary>
            Interface for a context generator that uses a beam search. 
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.IBeamSearchContextGenerator.GetContext(System.Int32,System.String[],System.String[],System.Object[])">
            <summary>
            Returns the context for the specified position in the specified sequence (list).  </summary>
            <param name="index">
            The index of the sequence.
            </param>
            <param name="sequence">
            The sequence of items over which the beam search is performed.
            </param>
            <param name="priorDecisions">
            The sequence of decisions made prior to the context for which this decision is being made.
            </param>
            <param name="additionalContext">
            Any addition context specific to a class implementing this interface.
            </param>
            <returns>
            the context for the specified position in the specified sequence.
            </returns>
        </member>
        <member name="T:OpenNLP.Tools.Util.ICoreMap">
            <summary>
            Base type for all annotatable core objects. Should usually be instantiated as
            {@link ArrayCoreMap}. Many common key definitions live in
            {@link edu.stanford.nlp.ling.CoreAnnotations}, but others may be defined elsewhere.
            See {@link edu.stanford.nlp.ling.CoreAnnotations} for details.
            
            Note that implementations of this interface must take care to implement
            equality correctly: by default, two CoreMaps are .equal if they contain the
            same keys and all corresponding values are .equal. Subclasses that wish to
            change this behavior (such as {@link HashableCoreMap}) must make sure that
            all other CoreMap implementations have a special case in their .equals to use
            that equality definition when appropriate. Similarly, care must be taken when
            defining hashcodes. The default hashcode is 37 * sum of all keys' hashcodes
            plus the sum of all values' hashcodes. However, use of this class as HashMap
            keys is discouraged because the hashcode can change over time. Consider using
            a {@link HashableCoreMap}.
            
            @author dramage
            @author rafferty
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.ICoreMap.ToShorterString(System.String[])">
            <summary>
            Attempt to provide a briefer and more human readable string for the contents of a CoreMap.
            The method may not be capable of printing circular dependencies in CoreMaps.
            </summary>
            <param name="what">
            An array (varargs) of strings that say what annotation keys to print.
            These need to be provided in a shortened form where you are just giving 
            the part of the class name without package and up to "Annotation".
            That is, edu.stanford.nlp.ling.CoreAnnotations.PartOfSpeechAnnotation --> PartOfSpeech. 
            As a special case, an empty array means to print everything, not nothing.
            </param>
            <returns>A more human readable string giving possibly partial contents of a  CoreMap.</returns>
        </member>
        <member name="T:OpenNLP.Tools.Util.IdentityHashSet`1">
            <summary>
            This class provides a <code>IdentityHashMap</code>-backed
            implementation of the <code>Set</code> interface.
            This means that whether an object is an element of the set depends 
            on whether it is == (rather than <code>equals()</code>) to an element of the set.
            This is different from a normal <code>HashSet</code>, where set membership
            depends on <code>equals()</code>, rather than ==.
            
            Each element in the set is a key in the backing IdentityHashMap; each key
            maps to a static token, denoting that the key does, in fact, exist.
            
            Most operations are O(1), assuming no hash collisions.  In the worst
            case (where all hashes collide), operations are O(n).
            
            @author Bill MacCartney
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.IdentityHashSet`1.#ctor">
            Construct a new, empty IdentityHashSet whose backing IdentityHashMap
            has the default expected maximum size (21);
        </member>
        <member name="M:OpenNLP.Tools.Util.IdentityHashSet`1.#ctor(System.Collections.Generic.ICollection{`0})">
            <summary>
            Construct a new IdentityHashSet with the same elements as the supplied
            Collection (eliminating any duplicates, of course); the backing
            IdentityHashMap will have the default expected maximum size (21).
            </summary>
            <param name="c">
            a Collection containing the elements with which this set will be initialized.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Util.IdentityHashSet`1.Add(`0)">
            <summary>
            dds the specified element to this set if it is not already present.
            Remember that this set implementation uses == (not <code>equals()</code>)
            to test whether an element is present in the set.
            </summary>
            <param name="o">element to add to this set</param>
            <returns>true if the element was added, false otherwise</returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.IdentityHashSet`1.Clear">
            <summary>
            Removes all of the elements from this set.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.IdentityHashSet`1.Contains(`0)">
            <summary>
            Returns true if this set contains the specified element.
            Remember that this set implementation uses == (not <code>equals()</code>)
            to test whether an element is present in the set.
            </summary>
            <param name="o">Element whose presence in this set is to be</param>
            <returns><code>true</code> if this set contains the specified element.</returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.IdentityHashSet`1.IsEmpty">
            <summary>
            Returns <code>true</code> if this set contains no elements.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.IdentityHashSet`1.Remove(`0)">
            <summary>
            Removes the specified element from this set if it is present.
            Remember that this set implementation uses == (not <code>equals()</code>) 
            to test whether an element is present in the set.
            </summary>
            <param name="o">Object to be removed from this set, if present.</param>
            <returns><code>true</code> if the set contained the specified element.</returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.IdentityHashSet`1.Size">
            <summary>
            Returns the number of elements in this set (its cardinality).
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.IdentityHashSet`1.InternalAdd(`0)">
            <summary>
            Adds the supplied element to this set.
            This private method is used internally [by clone()] instead of add(), because add() 
            can be overridden to do unexpected things.
            </summary>
            <param name="o">the element to add to this set</param>
        </member>
        <member name="T:OpenNLP.Tools.Util.IHeap`1">
            <summary>
            Inteface for interacting with a Heap data structure.
            This implementation extract objects from smallest to largest based on either
            their natural ordering or the comparator provided to an implementation.
            While this is a typical of a heap it allows this objects natural ordering to
            match that of other sorted collections.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.IHeap`1.Extract">
            <summary>
            Removes the smallest element from the heap and returns it.
            </summary>
            <returns>
            The smallest element from the heap.
            </returns>
        </member>
        <member name="P:OpenNLP.Tools.Util.IHeap`1.Top">
            <summary>
            Returns the smallest element of the heap.
            </summary>
            <returns>
            The top element of the heap.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.IHeap`1.Add(`0)">
            <summary>
            Adds the specified object to the heap.
            </summary>
            <param name="input">
            The object to add to the heap.
            </param>
        </member>
        <member name="P:OpenNLP.Tools.Util.IHeap`1.Size">
            <summary>
            Returns the size of the heap.
            </summary>
            <returns>
            The size of the heap.
            </returns>
        </member>
        <member name="P:OpenNLP.Tools.Util.IHeap`1.IsEmpty">
             <summary>
             Returns whether the heap is empty.
             </summary>
             <returns> 
             true if the heap is empty; false otherwise.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.IHeap`1.Clear">
            <summary>
            Clears the contents of the heap.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Util.International.Morph.MorphoFeatures">
            <summary>
            Holds a set of morphosyntactic features for a given surface form.
            
            @author Spence Green
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.International.Morph.MorphoFeatures.GetTag(System.String)">
            <summary>
            Build a POS tag consisting of a base category plus inflectional features.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.International.Morph.MorphoFeatures.GetAltTag">
            <summary>
            An alternate tag form than the one produced by getTag().
            Subclasses may want to use this form to implement someone else's tagset (e.g., CC, ERTS, etc.)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.International.Morph.MorphoFeatures.FromTagString(System.String)">
            <summary>
            Assumes that the tag string has been formed using a call to getTag().
            As such, it removes the basic category from the feature string.
            
            Note that this method returns a <b>new</b> MorphoFeatures object.
            As a result, it behaves like a static method, but is non-static so that subclasses can override
            this method.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.International.Morph.MorphoFeatures.ToString">
            <summary>
            values() returns the values in the order in which they are declared.
            Thus we will not have the case where two feature types can yield two strings:
            -feat1:A-feat2:B
            -feat2:B-feat1:A
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Util.International.Morph.MorphoFeatureSpecification">
            <summary>
            Morphological feature specification for surface forms in a given language.
            Currently supported feature names are the values of MorphFeatureType.
            
            @author Spence Green
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Util.International.Morph.MorphoFeatureSpecification.MorphoMark">
            <summary>
            Delimiter for associating a surface form with a morphological analysis, e.g., his~#PRP_3ms
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Util.International.Morph.MorphoFeatureSpecification.MorphoFeatureType">
            <summary>
            WSGDEBUG -- Added NNUM and NGEN for nominals in Arabic
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.International.Morph.MorphoFeatureSpecification.SplitMorphString(System.String,System.String)">
            <summary>
            Returns the lemma as pair.first() and the morph analysis as pair.second()
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Util.Interner`1">
            <summary>
            For interning (canonicalizing) things.
            
            It maps any object to a unique interned version which .equals the
            presented object.  If presented with a new object which has no
            previous interned version, the presented object becomes the
            interned version.  You can tell if your object has been chosen as
            the new unique representative by checking whether o == intern(o).
            The interners use WeakHashMap, meaning that if the only pointers
            to an interned item are the interners' backing maps, that item can
            still be garbage collected.  Since the gc thread can silently
            remove things from the backing map, there's no public way to get
            the backing map, but feel free to add one at your own risk.
            
            Note that in general it is just as good or better to use the
            static Interner.globalIntern() method rather than making an
            instance of Interner and using the instance-level intern().
            
            @author Dan Klein
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.Interner`1.GetGlobal">
            <summary>
            For getting the instance that global methods use.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.Interner`1.GlobalIntern``1(``0)">
            <summary>
            Returns a unique object o' that .equals the argument o.
            If o itself is returned, this is the first request for an object
            .equals to o.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.Interner`1.Intern(`0)">
            <summary>
            Returns a unique object o' that .equals the argument o.
            If o itself is returned, this is the first request for an object
            .equals to o.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.Interner`1.InternAll(OpenNLP.Tools.Util.Set{`0})">
            <summary>
            Returns a <code>Set</code> such that each element in the returned set
            is a unique object e' that .equals the corresponding element e in the
            original set.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.IntPair.GetSource">
            <summary>
            Return the first element of the pair
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.IntPair.GetTarget">
            <summary>
            Return the second element of the pair
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenNLP.Tools.Util.IntTuple">
            <summary>
            A tuple of int. There are special classes for IntUni, IntPair, IntTriple
            and IntQuadruple. The motivation for that was the different hashCode implementations.
            By using the static IntTuple.getIntTuple(numElements) one can obtain an
            instance of the appropriate sub-class.
            
            @author Kristina Toutanova (kristina@cs.stanford.edu)
            
            Code ...
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Util.IntUni">
            <summary>
            Just a single integer
            
            @author Kristina Toutanova (kristina@cs.stanford.edu)
            Code ...
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.IOUtils.readerFromString(System.String)">
             Open a BufferedReader to a file, class path entry or URL specified by a String name.
             If the String starts with https?://, then it is first tried as a URL. It
             is next tried as a resource on the CLASSPATH, and then it is tried
             as a local file. Finally, it is then tried again in case it is some network-available
             file accessible by URL. If the String ends in .gz, it
             is interpreted as a gzipped file (and uncompressed). The file is then
             interpreted as a utf-8 text file.
            
             @param textFileOrUrl What to read from
             @return The BufferedReader
             @throws IOException If there is an I/O problem
        </member>
        <member name="T:OpenNLP.Tools.Util.IPriorityQueue`1">
            <summary>
            A Set that also represents an ordering of its elements, and responds
            quickly to {@code add()}, {@code changePriority()},
            {@code removeFirst()}, and {@code getFirst()} method calls. <p/>
            There are several important differences between this interface and
            the JDK {@link java.util.PriorityQueue}: <p/>
            <ol>
            <li> This interface uses explicitly-assigned <code>double</code> values
            as priorities for queue elements, while
            <code>java.util.PriorityQueue</code> uses either the elements'
            <i>natural order</i> (see {@link java.lang.Comparable}) or a {@link
            java.util.Comparator}.</li>
            
            <li> In this interface, larger <code>double</code>s represent higher
            priorities; in <code>java.util.PriorityQueue</code>, <i>lesser</i>
            elements (with respect to the specified ordering) have higher
            priorities.</li>
            
            <li> This interface enables you to <i>change</i> the priority of an
            element <i>after</i> it has entered the queue.  With
            <code>java.util.PriorityQueue</code>, that's not possible.</li>
            
            <li> However, there is a price to pay for this flexibility.  The primary
            implementation of this interface, {@link
            edu.stanford.nlp.util.BinaryHeapPriorityQueue}, is roughly 2x slower
            than <code>java.util.PriorityQueue</code> in informal benchmark
            testing.</li>
            
            <li> So, there's another implementation of this interface,
            FixedPrioritiesPriorityQueue, which trades flexibility for speed: while
            it is up to 2x faster than {@link BinaryHeapPriorityQueue} and nearly as
            fast as {@link java.util.PriorityQueue}, it does not support removing or
            changing the priority of an element.</li>
            </ol>
            
            On the other hand, this interface and {@link java.util.PriorityQueue}
            also have some characteristics in common: <p/>
            <ol>
            <li> Both make no guarantee about the order in which elements with equal
            priority are returned from the queue.  This does <i>not</i> mean that
            equal elements are returned in <i>random</i> order.  (In fact they are
            returned in an order which depends on the order of insertion em-dash but
            the implementations reserve the right to return them in any order
            whatsoever.)</li>
            </ol>
            
            @author Teg Grenager (grenager@cs.stanford.edu)
            @author Bill MacCartney
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.IPriorityQueue`1.RemoveFirst">
            <summary>
            Finds the object with the highest priority, removes it, and returns it.
            </summary>
            <returns>the object with highest priority</returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.IPriorityQueue`1.GetFirst">
            <summary>
            Finds the object with the highest priority and returns it, without modifying the queue.
            </summary>
            <returns>the object with minimum key</returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.IPriorityQueue`1.GetPriority">
            <summary>
            Gets the priority of the highest-priority element of the queue (without modifying the queue).
            </summary>
            <returns>The priority of the highest-priority element of the queue.</returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.IPriorityQueue`1.GetPriority(`0)">
            <summary>
            Get the priority of a key.
            </summary>
            <param name="key">The object to assess</param>
            <returns>A key's priority. If the key is not in the queue, Double.NEGATIVE_INFINITY is returned.</returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.IPriorityQueue`1.Add(`0,System.Double)">
            <summary>
            Convenience method for if you want to pretend relaxPriority doesn't exist,
            or if you really want to use the return conditions of add().
            
            Warning: The semantics of this method currently varies between implementations.
            In some implementations, nothing will be changed if the key is already in the
            priority queue. In others, the element will be added a second time with the
            new priority. We maybe should at least change things so that the priority
            will be change to the priority given if the element is in the queue with
            a lower priority, but that wasn't the historical behavior, and it seemed like
            we'd need to do a lot of archeology before changing the behavior.
            </summary>
            <returns> <tt>true</tt> if this set did not already contain the specified element.</returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.IPriorityQueue`1.ChangePriority(`0,System.Double)">
            <summary>
            Changes a priority, either up or down, adding the key it if it wasn't there already.
            </summary>
            <returns>whether the priority actually changed.</returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.IPriorityQueue`1.RelaxPriority(`0,System.Double)">
            <summary>
            Increases the priority of the E key to the new priority if the old priority
             was lower than the new priority. Otherwise, does nothing.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.IPriorityQueue`1.ToString(System.Int32)">
            <summary>
            Returns a representation of the queue in decreasing priority order,
            displaying at most maxKeysToPrint elements.
            </summary>
            <param name="maxKeysToPrint">The maximum number of keys to print. 
            Less are printed if there are less than this number of items in the PriorityQueue. 
            If this number is non-positive, then all elements in the PriorityQueue are printed.</param>
            <returns>A string representation of the high priority items in the queue.</returns>
        </member>
        <member name="T:OpenNLP.Tools.Util.ITypesafeMap">
            <summary>
            Type signature for a class that supports the basic operations required
            of a typesafe heterogeneous map.
            
            @author dramage
            
            Code ...
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.ITypesafeMap.Has(System.Type)">
            <summary>
            Returns true if the map contains the given key.
            TODO [cdm 2014]: This is synonymous with containsKey(), but used less, so we should just eliminate it.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.ITypesafeMap.Get(System.Type)">
            <summary>
            Returns the value associated with the given key or null if none is provided.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.ITypesafeMap.Set(System.Type,System.Object)">
            <summary>
            Associates the given value with the given type for future calls to get.
            Returns the value removed or null if no value was present.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.ITypesafeMap.Remove(System.Type)">
            <summary>
            Removes the given key from the map, returning the value removed.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.ITypesafeMap.KeySet">
            <summary>
            Collection of keys currently held in this map.
            Some implementations may have the returned set be immutable.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.ITypesafeMap.ContainsKey(System.Type)">
            <summary>
            Returns true if contains the given key.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.ITypesafeMap.Size">
            <summary>
            Returns the number of keys in the map.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Util.IKey`1">
            <summary>
            Base type of keys for the map.
            The classes that implement Key are the keys themselves - not instances of those classes.
            </summary>
            <typeparam name="T">The type of the value associated with this key.</typeparam>
        </member>
        <member name="T:OpenNLP.Tools.Util.ListHeap`1">
            <summary>
            This class implements the heap interface using a generic List as the underlying
            data structure.  This heap allows values which are equals to be inserted, however
            the order in which they are extracted is arbitrary.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Util.ListHeap`1.IsEmpty">
            <summary>
            True if the heap is empty.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.ListHeap`1.#ctor(System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Creates a new heap with the specified size using the sorted based on the
            specified comparator.
            </summary>
            <param name="size">
            The size of the heap.
            </param>
            <param name="comparer">
            The comparer to be used to sort heap elements.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Util.ListHeap`1.#ctor(System.Int32)">
            <summary>
            Createa a new heap of the specified size.
            </summary>
            <param name="size">
            The size of the new heap.
            </param>
        </member>
        <member name="P:OpenNLP.Tools.Util.ListHeap`1.Size">
            <summary>
            The size of the heap.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.ListHeap`1.ResetSize">
            <summary>
            Resets the heap size to its original value.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Util.ListHeap`1.Top">
            <summary>
            Gets the object on top of the heap.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Util.MapFactory`2">
            <summary>
            A factory class for vending different sorts of Maps.
            
            @author Dan Klein (klein@cs.stanford.edu)
            @author Kayur Patel (kdpatel@cs)
            Code ...
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.MapFactory`2.hashMapFactory``2">
            <summary>
            Return a MapFactory that returns a HashMap.
            Implementation note: This method uses the same trick as the methods
            like emptyMap() introduced in the Collections class in JDK1.5 where
            callers can call this method with apparent type safety because this
            method takes the hit for the cast.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.MapFactory`2.linkedHashMapFactory``2">
            <summary>
            Return a MapFactory that returns an LinkedHashMap.
            Implementation note: This method uses the same trick as the methods
            like emptyMap() introduced in the Collections class in JDK1.5 where
            callers can call this method with apparent type safety because this
            method takes the hit for the cast.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.MapFactory`2.arrayMapFactory``2">
            <summary>
            Return a MapFactory that returns an ArrayMap.
            Implementation note: This method uses the same trick as the methods
            like emptyMap() introduced in the Collections class in JDK1.5 where
            callers can call this method with apparent type safety because this
            method takes the hit for the cast.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.MapFactory`2.NewMap">
            <summary>
            Returns a new non-parameterized map of a particular sort
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.MapFactory`2.NewMap(System.Int32)">
            <summary>
            Returns a new non-parameterized map of a particular sort with an initial capacity.
            </summary>
            <param name="initCapacity">initial capacity of the map</param>
            <returns> A new non-parameterized map of a particular sort with an initial capacity</returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.MapFactory`2.NewSet">
            <summary>
            A set with the same <code>K</code> parameterization of the Maps
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.MapFactory`2.SetMap``2(System.Collections.Generic.Dictionary{``0,``1})">
            <summary>
            A method to get a parameterized (genericized) map out.
            </summary>
            <param name="map">A type-parameterized {@link Map} argument</param>
            <returns>A {@link Map} with type-parameterization identical to that of the argument</returns>
        </member>
        <member name="T:OpenNLP.Tools.Util.MutableWrapper`1">
            <summary>
            A wrapper for immutable objects to update their value
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:OpenNLP.Tools.Util.ObjectBank.IIteratorFromReaderFactory`1">
            <summary>
            An IteratorFromReaderFactory is used to convert a java.io.Reader
            into an Iterator over the Objects of type T represented by the text
            in the java.io.Reader.
            
            @author Jenny Finkel
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.ObjectBank.IIteratorFromReaderFactory`1.GetIterator(System.IO.TextReader)">
            <summary>
            Return an iterator over the contents read from r.
            </summary>
            <param name="r">Where to read objects from</param>
            <returns>An Iterator over the objects</returns>
        </member>
        <member name="T:OpenNLP.Tools.Util.Process.AbstractTokenizer`1">
            <summary>
            An abstract tokenizer.
            Tokenizers extending AbstractTokenizer need only
            implement the <code>getNext()</code> method. This implementation does not
            allow null tokens, since null is used in the protected nextToken 
            field to signify that no more tokens are available.
            
            @author Teg Grenager (grenager@stanford.edu)
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.Process.AbstractTokenizer`1.GetNext">
            <summary>
            Internally fetches the next token.
            </summary>
            <returns>the next token in the token stream, or null if none exists</returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.Process.AbstractTokenizer`1.Next">
            <summary>
            Returns the next token from this Tokenizer.
            </summary>
            <exception cref="T:System.Exception">if the token stream has no more tokens</exception>
        </member>
        <member name="M:OpenNLP.Tools.Util.Process.AbstractTokenizer`1.HasNext">
            <summary>
            Returns <code>true</code> if this Tokenizer has more elements
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.Process.AbstractTokenizer`1.Remove">
            <summary>
            This is an optional operation, by default not supported
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.Process.AbstractTokenizer`1.Peek">
            <summary>
            This is an optional operation, by default supported
            </summary>
            <exception cref="T:System.Exception">if the token stream has no more tokens</exception>
        </member>
        <member name="M:OpenNLP.Tools.Util.Process.AbstractTokenizer`1.Tokenize">
            <summary>
            Returns A list of all tokens remaining in the underlying Reader
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Util.Process.CoreLabelTokenFactory">
            <summary>
            Constructs {@link CoreLabel}s from strings optionally with
            beginning and ending (character after the end) offset positions in
            an original text.  The makeToken method will put the token in the
            OriginalTextAnnotation AND TextAnnotation keys (2 places!),
            and optionally records begin and position after offsets in BeginPositionAnnotation and
            EndPositionAnnotation.  If the tokens are built in PTBTokenizer with
            an "invertible" tokenizer, you will also get a BeforeAnnotation and for
            the last token an AfterAnnotation.You can also get an empty CoreLabel token
            
            @author Anna Rafferty
            @author Sonal Gupta (now implements CoreTokenFactory, you can make tokens using many options)
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.Process.CoreLabelTokenFactory.#ctor">
            <summary>
            Constructor for a new token factory which will add in the word, the
            "current" annotation, and the begin/end position annotations.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.Process.CoreLabelTokenFactory.#ctor(System.Boolean)">
            <summary>
            Constructor that allows one to choose if index annotation
            indicating begin/end position will be included in the label
            </summary>
            <param name="addIndices">if true, begin and end position annotations will be included (this is the default)</param>
        </member>
        <member name="M:OpenNLP.Tools.Util.Process.CoreLabelTokenFactory.MakeToken(System.String,System.Int32,System.Int32)">
            <summary>
            Constructs a CoreLabel as a string with a corresponding BEGIN and END position.
            (Does not take substring).
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.Process.CoreLabelTokenFactory.MakeToken(System.String,System.String,System.Int32,System.Int32)">
            <summary>
            Constructs a CoreLabel as a string with a corresponding BEGIN and END position, 
            when the original OriginalTextAnnotation is different from TextAnnotation
            (Does not take substring).
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Util.Process.ICoreTokenFactory`1">
            <summary>
            To make tokens like CoreMap or CoreLabel. An alternative to LexedTokenFactory
            since this one has option to make tokens differently, which would have been
            an overhead for LexedTokenFactory
            
            @author Sonal Gupta
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Util.Process.ILexedTokenFactory`1">
            <summary>
            Constructs a token (of arbitrary type) from a string and its position
            in the underlying text.  This is used to create tokens in JFlex lexers
            such as PTBTokenizer.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.Process.ILexedTokenFactory`1.MakeToken(System.String,System.Int32,System.Int32)">
            <summary>
            Constructs a token (of arbitrary type) from a string and its position
            in the underlying text. (The int arguments are used just to record token
            character offsets in an underlying text. This method does not take a substring of {@code str}.)
            </summary>
            <param name="str">The string extracted by the lexer.</param>
            <param name="begin">The offset in the document of the first character in this string.</param>
            <param name="length">The number of characters the string takes up in the document.</param>
            <returns>The token of type T</returns>
        </member>
        <member name="T:OpenNLP.Tools.Util.Process.ITokenizer`1">
            <summary>
            Tokenizers break up text into individual Objects. These objects may be
            Strings, Words, or other Objects.  A Tokenizer extends the Iterator
            interface, but provides a lookahead operation <code>peek()</code>.  An
            implementation of this interface is expected to have a constructor that
            takes a single argument, a Reader.
            
            @author Teg Grenager (grenager@stanford.edu)
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.Process.ITokenizer`1.Next">
            <summary>
            Returns the next token from this Tokenizer.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.Process.ITokenizer`1.HasNext">
            <summary>
            Returns <code>true</code> if and only if this Tokenizer has more elements.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.Process.ITokenizer`1.Remove">
            <summary>
            Removes from the underlying collection the last element returned by
            the iterator.  This is an optional operation for Iterators - a
            Tokenizer normally would not support it. This method can be called
            only once per call to next.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.Process.ITokenizer`1.Peek">
            <summary>
            Returns the next token, without removing it, from the Tokenizer, so
            that the same token will be again returned on the next call to next() or peek().
            </summary>
            <returns>the next token in the token stream.</returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.Process.ITokenizer`1.Tokenize">
            <summary>
            Returns all tokens of this Tokenizer as a List for convenience
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Util.Process.ITokenizerFactory`1">
            <summary>
            A TokenizerFactory is used to convert a java.io.Reader into a Tokenizer
            (an extension of Iterator) over objects of type T represented by the text
            in the java.io.Reader.  It's mainly a convenience, since you could cast down anyway.
            
            <i>IMPORTANT NOTE:</i>
            A TokenizerFactory should also provide two static methods:
            - public static TokenizerFactory NewTokenizerFactory();
            - public static TokenizerFactory NewWordTokenizerFactory(string options);
            
            These are expected by certain JavaNLP code (e.g., LexicalizedParser),
            which wants to produce a TokenizerFactory by reflection.
            
            @author Christopher Manning
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
            <typeparam name="T">The type of the tokens returned by the Tokenizer</typeparam>
        </member>
        <member name="T:OpenNLP.Tools.Util.Process.StreamTokenizer">
            <summary>
            The <code>StreamTokenizer</code> class takes an input stream and
            parses it into "tokens", allowing the tokens to be
            Read one at a time. The parsing process is controlled by a table
            and a number of flags that can be set to various states. The
            stream tokenizer can recognize identifiers, numbers, quoted
            strings, and various comment styles.
            
            Each byte Read from the input stream is regarded as a character
            in the range <code>'&#92;u0000'</code> through <code>'&#92;u00FF'</code>.
            The character value is used to look up five possible attributes of
            the character: <i>white space</i>, <i>alphabetic</i>,
            <i>numeric</i>, <i>string quote</i>, and <i>comment character</i>.
            Each character can have zero or more of these attributes.
            
            In addition, an instance has four flags. These flags indicate:
            <ul>
            <li>Whether line terminators are to be returned as tokens or treated
            as white space that merely separates tokens.</li>
            <li>Whether C-style comments are to be recognized and skipped.</li>
            <li>Whether C++-style comments are to be recognized and skipped.</li>
            <li>Whether the characters of identifiers are converted to lowercase.</li>
            </ul>
            
            A typical application first constructs an instance of this class,
            sets up the syntax tables, and then repeatedly loops calling the
            <code>nextToken</code> method in each iteration of the loop until
            it returns the value <code>TT_EOF</code>.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Util.Process.StreamTokenizer.peekc">
            The next character to be considered by the nextToken method.  May also
            be NEED_CHAR to indicate that a new character should be Read, or SKIP_LF
            to indicate that a new character should be Read and, if it is a '\n'
            character, it should be discarded and a second new character should be
            Read.
        </member>
        <member name="F:OpenNLP.Tools.Util.Process.StreamTokenizer.eolIsSignificantP">
            The line number of the last token Read 
        </member>
        <member name="F:OpenNLP.Tools.Util.Process.StreamTokenizer.Ttype">
            <summary>
            After a call to the <code>nextToken</code> method, this field
            contains the type of the token just Read. For a single character
            token, its value is the single character, converted to an integer.
            For a quoted string token, its value is the quote character.
            Otherwise, its value is one of the following:
            <ul>
            <li><code>TT_WORD</code> indicates that the token is a word.</li>
            <li><code>TT_NUMBER</code> indicates that the token is a number.</li>
            <li><code>TT_EOL</code> indicates that the end of line has been Read.
            The field can only have this value if the <code>eolIsSignificant</code> method 
            has been called with the argument <code>true</code></li>
            <li><code>TT_EOF</code> indicates that the end of the input stream has been reached.</li>
            </ul>
            
            The initial value of this field is -4.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Util.Process.StreamTokenizer.TtEof">
            <summary>
            A constant indicating that the end of the stream has been Read.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Util.Process.StreamTokenizer.TtEol">
            <summary>
            A constant indicating that the end of the line has been Read.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Util.Process.StreamTokenizer.TtNumber">
            <summary>
            A constant indicating that a number token has been Read.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Util.Process.StreamTokenizer.TtWord">
            <summary>
            A constant indicating that a word token has been Read.
            </summary>
        </member>
        <member name="F:OpenNLP.Tools.Util.Process.StreamTokenizer.TtNothing">
            <summary>
            A constant indicating that no token has been Read, used for
            initializing ttype.  FIXME This could be made public and
            made available as the part of the API in a future release.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Util.Process.StreamTokenizer.StringValue">
            <summary>
            If the current token is a word token, this field contains a
            string giving the characters of the word token. When the current
            token is a quoted string token, this field contains the body of the string.
            
            The current token is a word when the value of the
            <code>ttype</code> field is <code>TT_WORD</code>. The current token is
            a quoted string token when the value of the <code>ttype</code> field is
            a quote character.
            
            The initial value of this field is null.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Util.Process.StreamTokenizer.NumberValue">
            <summary>
            If the current token is a number, this field contains the value
            of that number. The current token is a number when the value of
            the <code>ttype</code> field is <code>TT_NUMBER</code>.
            
            The initial value of this field is 0.0.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.Process.StreamTokenizer.#ctor">
            <summary>
            Private constructor that initializes everything except the streams.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.Process.StreamTokenizer.#ctor(System.IO.TextReader)">
            <summary>
            Create a tokenizer that parses the given character stream.
            </summary>
            <param name="r">a Reader object providing the input stream.</param>
            <exception cref="T:System.ArgumentNullException">when r is null</exception>
        </member>
        <member name="M:OpenNLP.Tools.Util.Process.StreamTokenizer.ResetSyntax">
            <summary>
            Resets this tokenizer's syntax table so that all characters are
            "ordinary." See the <code>ordinaryChar</code> method
            for more information on a character being ordinary.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.Process.StreamTokenizer.WordChars(System.Int32,System.Int32)">
            <summary>
            Specifies that all characters <i>c</i> in the range
            <code>low &lt;= <i>c</i> &lt;= high</code>
            are word constituents. A word token consists of a word constituent
            followed by zero or more word constituents or number constituents.
            </summary>
            <param name="low">the low end of the range.</param>
            <param name="hi">the high end of the range.</param>
        </member>
        <member name="M:OpenNLP.Tools.Util.Process.StreamTokenizer.WhitespaceChars(System.Int32,System.Int32)">
            <summary>
            Specifies that all characters <i>c</i> in the range
            <code>low &lt;= <i>c</i> &lt;= high</code>
            are white space characters. White space characters serve only to
            separate tokens in the input stream.
            
            Any other attribute settings for the characters in the specified range are cleared.
            </summary>
            <param name="low">the low end of the range</param>
            <param name="hi">the high end of the range</param>
        </member>
        <member name="M:OpenNLP.Tools.Util.Process.StreamTokenizer.OrdinaryChars(System.Int32,System.Int32)">
            <summary>
            Specifies that all characters <i>c</i> in the range
            <code>low &lt;= <i>c</i> &lt;= high</code>
            are "ordinary" in this tokenizer. See the
            <code>ordinaryChar</code> method for more information on a character being ordinary.
            </summary>
            <param name="low">the low end of the range.</param>
            <param name="hi">the high end of the range.</param>
        </member>
        <member name="M:OpenNLP.Tools.Util.Process.StreamTokenizer.OrdinaryChar(System.Int32)">
            <summary>
            Specifies that the character argument is "ordinary" in this tokenizer.
            It removes any special significance the character has as a comment character, 
            word component, string delimiter, white space, or number character.
            When such a character is encountered by the parser, the parser treats it as a
            single-character token and sets <code>ttype</code> field to the
            character value.
            
            Making a line terminator character "ordinary" may interfere
            with the ability of a <code>StreamTokenizer</code> to count
            lines. The <code>lineno</code> method may no longer reflect
            the presence of such terminator characters in its line count.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.Process.StreamTokenizer.CommentChar(System.Int32)">
            <summary>
            Specified that the character argument starts a single-line
            comment. All characters from the comment character to the end of
            the line are ignored by this stream tokenizer.
            
            Any other attribute settings for the specified character are cleared.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.Process.StreamTokenizer.QuoteChar(System.Int32)">
            <summary>
            Specifies that matching pairs of this character delimit string constants in this tokenizer.
            
            When the <code>nextToken</code> method encounters a string
            constant, the <code>ttype</code> field is set to the string
            delimiter and the <code>sval</code> field is set to the body of the string.
            
            If a string quote character is encountered, then a string is
            recognized, consisting of all characters after (but not including)
            the string quote character, up to (but not including) the next
            occurrence of that same string quote character, or a line
            terminator, or end of file. The usual escape sequences such as
            <code>"&#92;n"</code> and <code>"&#92;t"</code> are recognized and
            converted to single characters as the string is parsed.
            
            Any other attribute settings for the specified character are cleared.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.Process.StreamTokenizer.ParseNumbers">
            <summary>
            Specifies that numbers should be parsed by this tokenizer.
            The syntax table of this tokenizer is modified so that each of the twelve
            characters:
            <blockquote><pre>0 1 2 3 4 5 6 7 8 9 . -</pre></blockquote>
            has the "numeric" attribute.
            
            When the parser encounters a word token that has the format of a
            double precision floating-point number, it treats the token as a
            number rather than a word, by setting the <code>ttype</code>
            field to the value <code>TT_NUMBER</code> and putting the numeric
            value of the token into the <code>nval</code> field.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.Process.StreamTokenizer.EolIsSignificant(System.Boolean)">
            <summary>
            Determines whether or not ends of line are treated as tokens.
            If the flag argument is true, this tokenizer treats end of lines
            as tokens; the <code>nextToken</code> method returns
            <code>TT_EOL</code> and also sets the <code>ttype</code> field to
            this value when an end of line is Read.
            
            A line is a sequence of characters ending with either a
            carriage-return character (<code>'&#92;r'</code>) or a newline
            character (<code>'&#92;n'</code>). In addition, a carriage-return
            character followed immediately by a newline character is treated
            as a single end-of-line token.
            
            If the <code>flag</code> is false, end-of-line characters are
            treated as white space and serve only to separate tokens.
            </summary>
            <param name="flag">
            <code>true</code> indicates that end-of-line characters
            are separate tokens; <code>false</code> indicates that
            end-of-line characters are white space.
            </param>
        </member>
        <member name="P:OpenNLP.Tools.Util.Process.StreamTokenizer.SlashStarComments">
            <summary>
            Determines whether or not the tokenizer recognizes C-style comments.
            If the flag argument is <code>true</code>, this stream tokenizer
            recognizes C-style comments. All text between successive
            occurrences of <code>/*</code> and <code>*&#47;</code> are discarded.
            
            If the flag argument is <code>false</code>, then C-style comments are not treated specially.
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Util.Process.StreamTokenizer.SlashSlashComments">
            <summary>
            Determines whether or not the tokenizer recognizes C++-style comments.
            If the flag argument is <code>true</code>, this stream tokenizer
            recognizes C++-style comments. Any occurrence of two consecutive
            slash characters (<code>'/'</code>) is treated as the beginning of
            a comment that extends to the end of the line.
            
            If the flag argument is <code>false</code>, then C++-style
            comments are not treated specially.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:OpenNLP.Tools.Util.Process.StreamTokenizer.LowerCaseMode" -->
        <member name="M:OpenNLP.Tools.Util.Process.StreamTokenizer.Read">
            <summary>
            Read the next character
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.Process.StreamTokenizer.NextToken">
            <summary>
            Parses the next token from the input stream of this tokenizer.
            The type of the next token is returned in the <code>ttype</code>
            field. Additional information about the token may be in the
            <code>nval</code> field or the <code>sval</code> field of this tokenizer.
            
            Typical clients of this class first set up the syntax tables and then sit in a loop
            calling nextToken to parse successive tokens until TT_EOF is returned.
            </summary>
            <returns>the value of the <code>ttype</code> field</returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.Process.StreamTokenizer.PushBack">
            <summary>
            Causes the next call to the <code>nextToken</code> method of this
            tokenizer to return the current value in the <code>ttype</code>
            field, and not to modify the value in the <code>nval</code> or
            <code>sval</code> field.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Util.Process.TokenizerAdapter">
            <summary>
            This class adapts between a <code>java.io.StreamTokenizer</code>
            and a <code>edu.stanford.nlp.process.Tokenizer</code>.
            
            @author Christopher Manning
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.Process.TokenizerAdapter.#ctor(OpenNLP.Tools.Util.Process.StreamTokenizer)">
            <summary>
            Create a new <code>TokenizerAdaptor</code>.
            In general, it is recommended that the passed in <code>StreamTokenizer</code> should
            have had <code>resetSyntax()</code> done to it, so that numbers are
            returned as entered as tokens of type <code>string</code>, though this
            code will cope as best it can.
            </summary>
            <param name="st">The internal <code>java.io.StreamTokenizer</code></param>
        </member>
        <member name="M:OpenNLP.Tools.Util.Process.TokenizerAdapter.GetNext">
            <summary>
            Internally fetches the next token.
            </summary>
            <returns>The next token in the token stream, or null if none exists.</returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.Process.TokenizerAdapter.SetEolString(System.String)">
            <summary>
            Set the <code>string</code> returned when the inner tokenizer
            returns an end-of-line token.  This will only happen if the
            inner tokenizer has been set to <code>eolIsSignificant(true)</code>.
            </summary>
            <param name="eolString">
            The string used to represent eol.
            It is not allowed to be <code>null</code> (which would confuse line ends and file end)
            </param>
            <exception cref="T:System.ArgumentException">When eolString is null</exception>
        </member>
        <member name="M:OpenNLP.Tools.Util.Process.TokenizerAdapter.IsEol(System.String)">
            <summary>
            Say whether the <code>string</code> is the end-of-line token for this tokenizer.
            </summary>
            <param name="str">The string being tested</param>
            <returns>Whether it is the end-of-line token</returns>
        </member>
        <member name="T:OpenNLP.Tools.Util.Process.WordTokenFactory">
            <summary>
            Constructs a Word from a string. This is the default
            TokenFactory for PTBLexer. It discards the positional information.
            
            @author Jenny Finkel
            
            Code retrieved on the Stanford parser and ported to C# (see http://nlp.stanford.edu/software/lex-parser.shtml)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.PropertiesUtils.HasProperty(System.Collections.Generic.Dictionary{System.String,System.String},System.String)">
            <summary>
            Returns true iff the given Properties contains a property with the given
            key (name), and its value is not "false" or "no" or "off".
            </summary>
            <param name="props">Properties object</param>
            <param name="key">The key to test</param>
        </member>
        <member name="M:OpenNLP.Tools.Util.PropertiesUtils.AsString(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Convert from properties to string and from string to properties
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.PropertiesUtils.AsMap(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Tired of Properties not behaving like a Dictionary of string
            This method will solve that problem for you.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.PropertiesUtils.ExtractPrefixedProperties(System.Collections.Generic.Dictionary{System.String,System.String},System.String)">
            <summary>
            Build a {@code Properties} object containing key-value pairs from
            the given data where the keys are prefixed with the given {@code prefix}.
            The keys in the returned object will be stripped of their common prefix.
            </summary>
            <param name="properties">Key-value data from which to extract pairs</param>
            <param name="prefix">Key-value pairs where the key has this prefix will be retained in the returned {@code Properties} object</param>
            <returns>A Properties object containing those key-value pairs from 
            {@code properties} where the key was prefixed by {@code prefix}. 
            This prefix is removed from all keys in the returned structure.</returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.PropertiesUtils.Get``1(System.Collections.Generic.Dictionary{System.String,System.String},System.String,``0,System.Type)">
            <summary>
            Get the value of a property and automatically cast it to a specific type.
            This differs from the original Properties.getProperty() method in that you
            need to specify the desired type (e.g. Double.class) and the default value
            is an object of that type, i.e. a double 0.0 instead of the string "0.0".
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.PropertiesUtils.GetString(System.Collections.Generic.Dictionary{System.String,System.String},System.String,System.String)">
            <summary>
            Load an integer property.  If the key is not present, returns defaultValue.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.PropertiesUtils.GetInt(System.Collections.Generic.Dictionary{System.String,System.String},System.String)">
            <summary>
            Load an integer property.  If the key is not present, returns 0.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.PropertiesUtils.GetInt(System.Collections.Generic.Dictionary{System.String,System.String},System.String,System.Int32)">
            <summary>
            Load an integer property.  If the key is not present, returns defaultValue.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.PropertiesUtils.GetLong(System.Collections.Generic.Dictionary{System.String,System.String},System.String,System.Int64)">
            <summary>
            Load an integer property as a long. If the key is not present, returns defaultValue.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.PropertiesUtils.GetDouble(System.Collections.Generic.Dictionary{System.String,System.String},System.String)">
            <summary>
            Load a double property.  If the key is not present, returns 0.0.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.PropertiesUtils.GetDouble(System.Collections.Generic.Dictionary{System.String,System.String},System.String,System.Double)">
            <summary>
            Load a double property.  If the key is not present, returns defaultValue.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.PropertiesUtils.GetBool(System.Collections.Generic.Dictionary{System.String,System.String},System.String)">
            <summary>
            Load a bool property.  If the key is not present, returns false.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.PropertiesUtils.GetBool(System.Collections.Generic.Dictionary{System.String,System.String},System.String,System.Boolean)">
            <summary>
            Load a bool property.  If the key is not present, returns defaultValue.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Util.PropertiesUtils.Property">
            Loads a comma-separated list of strings from Properties.  Commas may be quoted if needed, e.g.:
               property1 = value1,value2,"a quoted value",'another quoted value'
               
            getStringArray(props, "property1") should return the same thing as
               new string[] { "value1", "value2", "a quoted value", "another quoted value" };
        </member>
        <member name="T:OpenNLP.Tools.Util.Sequence">
            <summary>Represents a weighted sequence of outcomes. </summary>
        </member>
        <member name="P:OpenNLP.Tools.Util.Sequence.Outcomes">
            <summary>
            Returns a list of outcomes for this sequence.
            </summary>
            <returns> a list of outcomes.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.Sequence.#ctor">
            <summary>
            Creates a new sequence of outcomes.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.Sequence.#ctor(OpenNLP.Tools.Util.Sequence)">
            <summary>
            Creates a new sequence of outcomes by cloning an existing sequence.
            </summary>
            <param name="sequenceToCopy">
            The sequence to create the clone from.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Util.Sequence.#ctor(OpenNLP.Tools.Util.Sequence,System.String,System.Double)">
            <summary>
            Creates a new sequence of outcomes based on an existing sequence.
            </summary>
            <param name="sequenceToCopy">
            The sequence to base the new sequence on.
            </param>
            <param name="outcome">
            An additional outcome to add onto the sequence.
            </param>
            <param name="probability">
            An existing probability to add onto the sequence.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Util.Sequence.#ctor(System.Collections.Generic.List{System.String})">
            <summary>
            Creates a new sequence of outcomes based on a list of outcomes.
            Each is given a probability of 1.
            </summary>
            <param name="outcomes">
            List of outcomes to create the sequence from.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Util.Sequence.CompareTo(System.Object)">
            <summary>
            Compares two Sequence objects.
            </summary>
            <param name="o">
            Object to compare this Sequence to.
            </param>
            <returns>
            Value indicating which sequence is the larger.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.Sequence.Equals(System.Object)">
            <summary>
            Tests for equality of Sequence objects.
            </summary>
            <param name="o">
            Object to compare this Sequence to.
            </param>
            <returns>
            True if the objects are equal; false otherwise.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.Sequence.Add(System.String,System.Double)">
            <summary>
            Adds an outcome and probability to this sequence.
            </summary>
            <param name="outcome">
            the outcome to be added.
            </param>
            <param name="probability">
            the probability associated with this outcome.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Util.Sequence.GetProbabilities">
            <summary>
            Returns an array of probabilities associated with the outcomes of this sequence.
            </summary>
            <returns>
            an array of probabilities.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.Sequence.GetProbabilities(System.Double[])">
            <summary>
            Populates an array with the probabilities associated with the outcomes of this sequence.</summary>
            <param name="probabilities">
            a pre-allocated array to use to hold the values of the probabilities of the outcomes for this sequence.
            </param>
        </member>
        <member name="P:OpenNLP.Tools.Util.Sequence.Score">
            <summary>
            Returns the score of this sequence.
            </summary>
            <returns>
            The score of this sequence.
            </returns>
        </member>
        <member name="T:OpenNLP.Tools.Util.Set`1">
            <summary>
            This class manages a set of elements.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.Set`1.#ctor">
            <summary>
            Creates a new set.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.Set`1.#ctor(System.Collections.Generic.ICollection{`0})">
            <summary>
            Creates a new set initialized with ICollection object
            </summary>
            <param name="collection">
            ICollection object to initialize the set object
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Util.Set`1.#ctor(System.Int32)">
            <summary>
            Creates a new set initialized with a specific capacity.
            </summary>
            <param name="capacity">
            value to set the capacity of the set object
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Util.Set`1.Add(`0)">
            <summary>
            Adds an element to the set.
            </summary>
            <param name="item">
            The object to be added.
            </param>
            <returns>
            True if the object was added, false otherwise.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.Set`1.AddAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Adds all the elements contained in the specified collection.
            </summary>
            <param name="collection">
            The collection used to extract the elements that will be added.
            </param>
            <returns>
            Returns true if all the elements were successfuly added. Otherwise returns false.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.Set`1.ContainsAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Verifies that all the elements of the specified collection are contained into the current collection. 
            </summary>
            <param name="collection">
            The collection used to extract the elements that will be verified.
            </param>
            <returns>
            True if the collection contains all the given elements.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.Set`1.IsEmpty">
            <summary>
            Verifies if the collection is empty.
            </summary>
            <returns>
            True if the collection is empty, false otherwise.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.Set`1.Remove(`0)">
            <summary>
            Removes an element from the set.
            </summary>
            <param name="elementToRemove">
            The element to be removed.
            </param>
            <returns>
            True if the element was removed.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.Set`1.RemoveAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Removes all the elements contained in the specified collection.
            </summary>
            <param name="collection">
            The collection used to extract the elements that will be removed.
            </param>
            <returns>
            True if all the elements were successfuly removed, false otherwise.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.Set`1.RetainAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Removes all the elements that aren't contained in the specified collection.
            </summary>
            <param name="collection">
            The collection used to verify the elements that will be retained.
            </param>
            <returns>
            True if all the elements were successfully removed, false otherwise.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.Set`1.ToArray(`0[])">
            <summary>
            Obtains an array containing all the elements in the collection.
            </summary>
            <param name="objects">
            The array into which the elements of the collection will be stored.
            </param>
            <returns>
            The array containing all the elements of the collection.
            </returns>
        </member>
        <member name="T:OpenNLP.Tools.Util.SortedSet`1">
            <summary>
            This class contains methods to manage a sorted collection.
            RN note: this class (taken from the JLCA "support" code) doesn't actually
            sort anything.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.SortedSet`1.#ctor">
            <summary>
            Creates a new SortedSet.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.SortedSet`1.#ctor(System.Collections.Generic.ICollection{`0})">
            <summary>
            Create a new SortedSet with a specific collection.
            </summary>
            <param name="collection">
            The collection used to iniciatilize the SortedSetSupport
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Util.SortedSet`1.First">
            <summary>
            Returns the first element from the set.
            </summary>
            <returns>
            Returns the first element from the set.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.SortedSet`1.Last">
            <summary>
            Returns the last element of the set.
            </summary>
            <returns>Returns the last element from the set.</returns>
        </member>
        <member name="T:OpenNLP.Tools.Util.Span">
            <summary>
            Class for storing start and end integer offsets.  
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Util.Span.Start">
            <summary>
            Return the start of a span.
            </summary>
            <returns> 
            the start of a span.
            </returns>
        </member>
        <member name="P:OpenNLP.Tools.Util.Span.End">
            <summary>
            Return the end of a span.
            </summary>
            <returns> 
            the end of a span.
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.Span.#ctor(System.Int32,System.Int32)">
            <summary>Constructs a new Span object.
            </summary>
            <param name="startOfSpan">
            start of span.
            </param>
            <param name="endOfSpan">
            end of span.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Util.Span.Length">
            <summary>
            Computes the length of the span (end - start)
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.Span.Contains(OpenNLP.Tools.Util.Span)">
            <summary>
            Returns true is the specified span is contained by this span.  
            Identical spans are considered to contain each other. 
            </summary>
            <param name="span">
            The span to compare with this span.
            </param>
            <returns>
            true if the specified span is contained by this span; false otherwise. 
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.Span.ContainsStrictly(OpenNLP.Tools.Util.Span)">
            <summary>
            Returns true if the specified span is contained stritly by this span,
            ie if the current start if strictly less than the input span's start
            OR if the current end if strictly greater than the input span's end.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.Span.Intersects(OpenNLP.Tools.Util.Span)">
            <summary>
            Returns true if the specified span intersects with this span.
            </summary>
            <param name="span">
            The span to compare with this span. 
            </param>
            <returns>
            true is the spans overlap; false otherwise. 
            </returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.Span.Crosses(OpenNLP.Tools.Util.Span)">
            <summary>
            Returns true if the specified span crosses this span.
            </summary>
            <param name="span">
            The span to compare with this span.
            </param>
            <returns>
            true if the specified span overlaps this span and contains a non-overlapping section; false otherwise.
            </returns>
        </member>
        <member name="T:OpenNLP.Tools.Util.StringTokenizer">
            <summary>
            Class providing simple tokenization of a string, for manipulation.  
            For NLP tokenizing, see the OpenNLP.Tools.Tokenize namespace.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.StringTokenizer.#ctor(System.String)">
            <summary>
            Initializes a new class instance with a specified string to process
            </summary>
            <param name="input">
            string to tokenize
            </param>
        </member>
        <member name="T:OpenNLP.Tools.Util.StringUtils">
            <summary>
            Class for random string things, including output formatting and command line argument parsing.
            
            @author Dan Klein
            @author Christopher Manning
            @author Tim Grow (grow@stanford.edu)
            @author Chris Cox
            @version 2006/02/03
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.StringUtils.Find(System.String,System.String)">
            <summary>
            Say whether this regular expression can be found inside this string.
            This method provides one of the two "missing" convenience methods 
            for regular expressions in the string class in JDK1.4.
            This is the one you'll want to use all the time if you're used to Perl.
            What were they smoking?
            </summary>
            <param name="str">string to search for match in</param>
            <param name="regex">string to compile as the regular expression</param>
            <returns>Whether the regex can be found in str</returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.StringUtils.ContainsIgnoreCase(System.Collections.Generic.List{System.String},System.String)">
            <summary>
            Convenience method: a case-insensitive variant of Collection.contains
            </summary>
            <returns>true if s case-insensitively matches a string in c</returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.StringUtils.LookingAt(System.String,System.String)">
            <summary>
            Say whether this regular expression can be found at the beginning of this string. 
            This method provides one of the two "missing" convenience methods 
            for regular expressions in the string class in JDK1.4.
            </summary>
            <param name="str">string to search for match at start of</param>
            <param name="regex">string to compile as the regular expression</param>
            <returns>Whether the regex can be found at the start of str</returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.StringUtils.MapStringToArray(System.String)">
            <summary>
            Takes a string of the form "x1=y1,x2=y2,..." 
            such that each y is an integer and each x is a key.
            A string[] s is returned such that s[yn]=xn
            </summary>
            <param name="map">
            A string of the form "x1=y1,x2=y2,..." such that each y is an integer and each x is a key.
            </param>
            <returns>A string[] s is returned such that s[yn]=xn</returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.StringUtils.MapStringToMap(System.String)">
            <summary>
            Takes a string of the form "x1=y1,x2=y2,..." and returns Map
            </summary>
            <param name="map">A string of the form "x1=y1,x2=y2,..."</param>
            <returns>A Map m is returned such that m.get(xn) = yn</returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.StringUtils.SplitOnWhitespaces(System.String)">
            <summary>
            Splits on whitespace (\\s+).
            </summary>
            <param name="s">string to split</param>
        </member>
        <member name="M:OpenNLP.Tools.Util.StringUtils.Split(System.String,System.String)">
            <summary>
            Splits the given string using the given regex as delimiters.
            This method is the same as the string.Split() method 
            (except it throws the results in a List), and is included 
            just to give a call that is parallel to the other static regex methods in this class.
            </summary>
            <param name="str">string to split up</param>
            <param name="regex">string to compile as the regular expression</param>
            <returns>List of strings resulting from splitting on the regex</returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.StringUtils.Pad(System.String,System.Int32)">
            <summary>
            Return a string of length a minimum of totalChars characters 
            by padding the input string str at the right end with spaces.
            If str is already longer than totalChars, it is returned unchanged.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.StringUtils.Pad(System.Object,System.Int32)">
            <summary>
            Pads the ToString value of the given Object.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.StringUtils.PadOrTrim(System.String,System.Int32)">
            <summary>
            Pad or trim so as to produce a string of exactly a certain length.
            </summary>
            <param name="str">The string to be padded or truncated</param>
            <param name="num">The desired length</param>
        </member>
        <member name="M:OpenNLP.Tools.Util.StringUtils.PadLeftOrTrim(System.String,System.Int32)">
            <summary>
            Pad or trim so as to produce a string of exactly a certain length.
            </summary>
            <param name="str">The string to be padded or truncated</param>
            <param name="num">The desired length</param>
        </member>
        <member name="M:OpenNLP.Tools.Util.StringUtils.PadOrTrim(System.Object,System.Int32)">
            <summary>
            Pad or trim the ToString value of the given Object.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.StringUtils.PadLeft(System.String,System.Int32,System.Char)">
            <summary>
            Pads the given string to the left with the given character 
            to ensure that it's at least totalChars long.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.StringUtils.PadLeft(System.String,System.Int32)">
            <summary>
            Pads the given string to the left with spaces to ensure 
            that it's at least totalChars long.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.StringUtils.Trim(System.String,System.Int32)">
            <summary>
            Returns s if it's at most maxWidth chars, otherwise chops right side to fit.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.StringUtils.FileNameClean(System.String)">
            <summary>
            Returns a "clean" version of the given filename in which spaces 
            have been converted to dashes and all non-alphanumeric chars are underscores.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.StringUtils.NthIndex(System.String,System.Char,System.Int32)">
            <summary>
            Returns the index of the <i>n</i>th occurrence of ch in s, 
            or -1 if there are less than n occurrences of ch.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.StringUtils.Truncate(System.Int32,System.Int32,System.Int32)">
            <summary>
            This returns a string from decimal digit smallestDigit to decimal digit biggest digit. 
            Smallest digit is labeled 1, and the limits are inclusive.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.StringUtils.StringToProperties(System.String)">
            <summary>
            Converts a comma-separated string (with whitespace optionally allowed after the comma) 
            representing properties to a Properties object.
            Each property is "property=value".
            The value for properties without an explicitly given value is set to "true".
            This can be used for a 2nd level of properties, for example, 
            when you have a commandline argument like "-outputOptions style=xml,tags".
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.StringUtils.StringToProperties(System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            This method updates a Properties object based on a comma-separated string 
            (with whitespace optionally allowed after the comma) representing properties to a Properties object.
            Each property is "property=value".
            The value for properties without an explicitly given value is set to "true".
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.StringUtils.StripNonAlphaNumerics(System.String)">
             A simpler form of command line argument parsing.
             Dan thinks this is highly superior to the overly complexified code that
             comes before it.
             Parses command line arguments into a Map. Arguments of the form
             -flag1 arg1 -flag2 -flag3 arg3
             will be parsed so that the flag is a key in the Map (including the hyphen)
             and the
             optional argument will be its value (if present).
             In this version, if the argument is numeric, it will be a Double value
             in the map, not a string.
            
             @return A Map from keys to possible values (string or null)
        </member>
        <member name="M:OpenNLP.Tools.Util.StringUtils.SplitOnCharWithQuoting(System.String,System.Char,System.Char,System.Char)">
            <summary>
            This function splits the string s into multiple strings using the splitChar.
            However, it provides a quoting facility: it is possible to quote strings with the quoteChar.
            If the quoteChar occurs within the quotedExpression, it must be prefaced by the escapeChar.
            This routine can be useful for processing a line of a CSV file.
            </summary>
            <param name="s">The string to split into fields. Cannot be null.</param>
            <param name="splitChar">The character to split on</param>
            <param name="quoteChar">The character to quote items with</param>
            <param name="escapeChar">The character to escape the quoteChar with</param>
            <returns>An array of strings that s is split into</returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.StringUtils.LongestCommonContiguousSubstring(System.String,System.String)">
            <summary>
            Computes the longest common contiguous substring of s and t.
            The LCCS is the longest run of characters that appear consecutively in
            both s and t. For instance, the LCCS of "color" and "colour" is 4, because of "colo".
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.StringUtils.PennPosToWordnetPos(System.String)">
            <summary>
            Computes the WordNet 2.0 POS tag corresponding to the PTB POS tag s
            </summary>
            <param name="s">a Penn TreeBank POS tag.</param>
            <returns></returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.StringUtils.Capitalize(System.String)">
            <summary>
            Uppercases the first character of a string.
            </summary>
            <param name="s">a string to capitalize</param>
            <returns>a capitalized version of the string</returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.StringUtils.IsCapitalized(System.String)">
            <summary>
            Check if a string begins with an uppercase.
            </summary>
            <returns>true if the string is capitalized, false otherwise</returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.StringUtils.MakeHtmlTable(System.String[][],System.String[],System.String[])">
            <summary>
            Returns an HTML table containing the matrix of strings passed in.
            The first dimension of the matrix should represent the rows, and the second dimension the columns.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.StringUtils.MakeTextTable(System.Object[][],System.Object[],System.Object[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            Returns a text table containing the matrix of objects passed in.
            The first dimension of the matrix should represent the rows, 
            and the second dimension the columns. Each object is printed in a cell with ToString().
            The printing may be padded with spaces on the left and then on the right 
            to ensure that the string form is of length at least padLeft or padRight.
            If tsv is true, a tab is put between columns.
            </summary>
            <returns>A string form of the table</returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.StringUtils.MakeAsciiTableCell(System.Object,System.Int32,System.Int32,System.Boolean)">
            <summary>
            The cell string is the string representation of the object.
             If padLeft is greater than 0, it is padded. Ditto right
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.StringUtils.Chomp(System.String)">
            <summary>
            Returns the supplied string with any trailing '\n' removed.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.StringUtils.Chomp(System.Object)">
            <summary>
            Returns the result of calling ToString() on the supplied Object, but with any trailing '\n' removed.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.StringUtils.GetBaseName(System.String)">
            <summary>
            Strip directory from filename.  Like Unix 'basename'. <p/>
            Example: <code>getBaseName("/u/wcmac/foo.txt") ==> "foo.txt"</code>
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.StringUtils.GetBaseName(System.String,System.String)">
            <summary>
            Strip directory and suffix from filename.  Like Unix 'basename'.
            Example: <code>getBaseName("/u/wcmac/foo.txt", "") ==> "foo.txt"</code>
            Example: <code>getBaseName("/u/wcmac/foo.txt", ".txt") ==> "foo"</code>
            Example: <code>getBaseName("/u/wcmac/foo.txt", ".pdf") ==> "foo.txt"</code>
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.StringUtils.IsAlpha(System.String)">
            <summary>
            Given a string the method uses Regex to check if the string only contains alphabet characters
            </summary>
            <param name="s">a string to check using regex</param>
            <returns>true if the string is valid</returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.StringUtils.IsNumeric(System.String)">
            <summary>
            Given a string the method uses Regex to check if the string only contains numeric characters
            </summary>
            <param name="s">a string to check using regex</param>
            <returns>true if the string is valid</returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.StringUtils.IsAlphanumeric(System.String)">
            <summary>
            Given a string the method uses Regex to check 
            if the string only contains alphanumeric characters
            </summary>
            <param name="s">a string to check using regex</param>
            <returns>true if the string is valid</returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.StringUtils.IsPunct(System.String)">
            <summary>
            Given a string the method uses Regex to check 
            if the string only contains punctuation characters
            </summary>
            <param name="s">a string to check using regex</param>
            <returns>true if the string is valid</returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.StringUtils.IsAcronym(System.String)">
            <summary>
            Given a string the method uses Regex to check if the string looks like an acronym
            </summary>
            <param name="s">a string to check using regex</param>
            <returns>true if the string is valid</returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.StringUtils.GetCharacterNgrams(System.String,System.Int32,System.Int32)">
            <summary>
            Build a list of character-based ngrams from the given string.
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Util.TreeHeap`1">
            <summary>
            An implemention of the heap interface based on SortedSet.
            This implementation will not allow multiple objects which are equal to be added to the heap.
            Only use this implementation when object in the heap can be totally ordered (no duplicates). 
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.TreeHeap`1.#ctor">
            <summary> Creates a new tree heap.</summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.TreeHeap`1.#ctor(System.Int32)">
            <summary>
            Creates a new tree heap of the specified size.
            </summary>
            <param name="size">
            The size of the new tree heap.
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Util.TreeHeap`1.Extract">
            <summary>
            Pops the first element of the tree
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Util.TreeHeap`1.Top">
            <summary>
            Returns the first element of the tree
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.TreeHeap`1.Add(`0)">
            <summary>
            Adds an element to the tree
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.TreeHeap`1.Sort">
            <summary>
            Sorts the tree
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Util.TreeHeap`1.Size">
            <summary>
            Returns the size of the tree
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.TreeHeap`1.Clear">
            <summary>
            Clears the tree
            </summary>
        </member>
        <member name="P:OpenNLP.Tools.Util.TreeHeap`1.IsEmpty">
            <summary>
            Returns if the tree is empty
            </summary>
        </member>
        <member name="T:OpenNLP.Tools.Util.TreeSet`1">
            <summary>
            This class manages a tree set collection of sorted elements.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.TreeSet`1.#ctor">
            <summary>
            Creates a new TreeSet.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.TreeSet`1.#ctor(System.Collections.Generic.ICollection{`0})">
            <summary>
            Create a new TreeSet with a specific collection.
            </summary>
            <param name="collection">
            The collection used to initialize the TreeSet
            </param>
        </member>
        <member name="M:OpenNLP.Tools.Util.TreeSet`1.TreeSetClone">
            <summary>
            Creates a copy of the TreeSet.
            </summary>
            <returns>A copy of the TreeSet.</returns>
        </member>
        <member name="M:OpenNLP.Tools.Util.TreeSet`1.Size">
            <summary>
            Retrieves the number of elements contained in the set.
            </summary>
            <returns>
            An integer value that represent the number of element in the set.
            </returns>
        </member>
        <member name="T:OpenNLP.Tools.Util.XmlUtils">
            <summary>
            Provides some utilities for dealing with XML files, both by properly 
            parsing them and by using the methods of a desperate Perl hacker.
            </summary>
        </member>
        <member name="M:OpenNLP.Tools.Util.XmlUtils.XmlEscape(System.String)">
            <summary>
            Escape an unescaped xml string
            </summary>
        </member>
    </members>
</doc>
